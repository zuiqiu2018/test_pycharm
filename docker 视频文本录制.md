# docker 视频文本录制

## 67、docker 容器技术-I


### 1、容器技术介绍
[00:00/12:42]     我们先开始给大家介绍一下容器技术的相关内容
[00:02/12:42]     这应该是我们的第一节课
[00:04/12:42]     可能有很多的同学呢
[00:06/12:42]     以前并没有接触过像是这样的这种容器的技术
[00:12/12:42]     所以说呢
[00:13/12:42]     很多同学会对此抱有一定的疑问
[00:16/12:42]     就是说容器技术到底是个什么东西
[00:18/12:42]     然后学习容器技术能对我们测试这个行业带来什么样的改变
[00:25/12:42]     对我们来说有什么样的必要性
[00:27/12:42]     并且呢
[00:28/12:42]     我们应该如何去学习它
[00:29/12:42]     而学习容器它应该有什么样的一个学习线
[00:34/12:42]     学成之后呢
[00:35/12:42]     能够带来给我们带来什么样的价值
[00:38/12:42]     我们主来讨论这部分内容
[00:42/12:42]     容器技术的介绍
[00:44/12:42]     首先呢
[00:45/12:42]     我们先来介绍一下容器技术的价值
[00:49/12:42]     这里面先要介绍一下docker这个东西呢
[00:52/12:42]     它并不等于容器
[00:53/12:42]     这个先需要先跟大家去澄清一下
[00:56/12:42]     容器技术是一个范程
[01:00/12:42]     是一个范称
[01:02/12:42]     并不代表是docker创建了容器技术
[01:04/12:42]     其实在cker之前的时候
[01:07/12:42]     在docker之前的时候
[01:09/12:42]     容器就已经存在了
[01:11/12:42]     只不过docker的出现呢
[01:12/12:42]     把容器带向了全世界所有的开发者们
[01:17/12:42]     所有的软件工程师们
[01:19/12:42]     Docker的一些设计
[01:21/12:42]     尤其是一些关于镜像的设计呢
[01:23/12:42]     使得容器这门技术呢
[01:25/12:42]     能够大大的普及出来
[01:26/12:42]     以前的容器技术还是比较小众的
[01:29/12:42]     大家还是在云方案里也好
[01:31/12:42]     还是在测试环境里也好
[01:34/12:42]     用的都是虚拟机的这么一套方案
[01:36/12:42]     真正让容器流行起来的就是docker的出现
[01:40/12:42]     那刀客出现之后
[01:42/12:42]     它能够保证什么样的东西呢
[01:44/12:42]     就大来给我们带来什么样的价值呢
[01:46/12:42]     我们先从项目角度来出发从项目角度来出发
[01:51/12:42]     首先第一点它能够保证环境的一致性
[01:54/12:42]     不知道大家之前有没有这个注意过
[01:57/12:42]     就是说我们在测试领域里面经常会出现一种场景是什么呢
[02:02/12:42]     比如说在开发环境研发的自测的时候是没有bug的
[02:06/12:42]     就是很很正常的
[02:08/12:42]     但是到了测试环境里面就出现问题了
[02:12/12:42]     这些问题呢
[02:13/12:42]     可能有很多并不是bug
[02:15/12:42]     但是很是很多其他的环境相关的东西
[02:18/12:42]     比如说在机器上的内核版本的不一样
[02:22/12:42]     又或者说GDK的版本不一样
[02:25/12:42]     又或者说某些环境变量的不同
[02:27/12:42]     又或者说某些参数的不同
[02:30/12:42]     就导致于呢
[02:31/12:42]     可能同样的一个功能在开发的环境里面是OK的
[02:34/12:42]     但是在测试环境里面就不行了
[02:37/12:42]     这个我不知道大家这个这个的这个年龄是什么样子的多大了
[02:44/12:42]     就是说有没有经历过以前的这个云的这种方案在以前呢
[02:49/12:42]     如果说你要把你的应用上云呢
[02:51/12:42]     其实是挺麻烦的
[02:52/12:42]     你需要把自己的所有的东西打成一个包
[02:55/12:42]     然后上传到云的里面拟
[03:05/12:42]     可能叫虚拟
[03:06/12:42]     也有可能是一个虚拟化不的一个西
[03:10/12:42]     然后它的内核版本规
[03:11/12:42]     它的变量规
[03:13/12:42]     它的D等等
[03:24/12:42]     所以说经常造就一种因为环境不一致带来的一些问题这个
[03:30/12:42]     就的面包括你的G环变量了等一些其他软件都是打镜像里面
[03:56/12:42]     这是它带来的第一个价值
[03:58/12:42]     第二是什么
[04:00/12:42]     它是一个相比来说
[04:01/12:42]     它是一个非常级的虚拟化
[04:04/12:42]     的一个方案
[04:07/12:42]     它运行更快
[04:08/12:42]     资源使用更小
[04:10/12:42]     同时呢
[04:11/12:42]     也可以保证容器之间的隔离性
[04:13/12:42]     它比虚拟机更快容器经常号称是秒级启动
[04:18/12:42]     虚拟机是没有办法去秒级启动
[04:19/12:42]     大家不知道启没启动过虚拟机虚拟机就算你再小的虚拟机
[04:24/12:42]     其实它也是
[04:25/12:42]     它也是挺慢的
[04:28/12:42]     也是挺慢的
[04:29/12:42]     因为它毕竟有内核
[04:32/12:42]     这是第二个
[04:35/12:42]     我们在测试环境里也好
[04:37/12:42]     还有在生长环境也好
[04:38/12:42]     其实
[04:39/12:42]     都可以用更小的资源、更快的速度去运行我们的容器
[04:44/12:42]     对比虚拟来说
[04:45/12:42]     它的优势更大
[04:47/12:42]     然后部的一些类型
[04:52/12:42]     这个这个这个个我可写错了
[04:55/12:42]     这个可能写错写错了
[05:00/12:42]     他可以干什么呢
[05:01/12:42]     他可以这个云原生微服务的首选的技术方案
[05:07/12:42]     就是说我们目前的云生领域和微服务领域里面都是使用器来进行的
[05:15/12:42]     什么呢
[05:16/12:42]     我们说说微服务
[05:17/12:42]     微服务大家都知道
[05:18/12:42]     微服务大家说就是有很多把很多的功能拆的很细
[05:23/12:42]     一个一个小的服务
[05:24/12:42]     所以说一个一个系统动辄可能就有几百条
[05:28/12:42]     几百个服务器
[05:31/12:42]     几百个服务都是很有可能性的
[05:32/12:42]     像我所在这个公司
[05:34/12:42]     我们现在去年统计了一下
[05:37/12:42]     去年统计了我经一个项目
[05:39/12:42]     那个项目里面大概是百0
[05:43/12:42]     是203个服务
[05:44/12:42]     这只是服务
[05:45/12:42]     其实一个服务呢
[05:46/12:42]     可能有不同的副本
[05:47/12:42]     因为它是要高可用和负载均衡的嘛
[05:51/12:42]     所以说真正的这什么
[05:52/12:42]     真正的这个容器启动的数量大概是500多个
[05:57/12:42]     就一个系统就启动了500多个容器
[05:59/12:42]     如果你没有这个刀cker的
[06:08/12:42]     不管是运维来说
[06:14/12:42]     还是开发测试来说
[06:15/12:42]     都是很恐怖的一件事情
[06:17/12:42]     说封装载了
[06:24/12:42]     大家不要不要介意
[06:26/12:42]     不要介意
[06:32/12:42]     不用感知
[06:38/12:42]     你只需要使用它的容器运行起来就可以了
[06:41/12:42]     至于这个容器里面这个服务到底是怎么部署的
[06:44/12:42]     到底是怎么部署的
[06:46/12:42]     其实你可以不用管
[06:47/12:42]     就比如说现在我要一个link测试用的管理软件
[06:51/12:42]     比如说我们一个link大家都知道
[06:59/12:42]     你本的
[07:09/12:42]     所以说有容器之后就可以避免这种情况
[07:12/12:42]     尤其是说这个之后呢
[07:16/12:42]     我们还有K相关的
[07:18/12:42]     K现带带K编排所有的部相关的
[07:31/12:42]     把所有的部相关的复杂度全部封装起来
[07:35/12:42]     全部封装起来
[07:36/12:42]     大家用过K应该都知道
[07:38/12:42]     只要研发同学那边提供了一堆M文件
[07:40/12:42]     就是K8S配置文件
[07:41/12:42]     你一键执行
[07:43/12:42]     或者说把它封装成一个包一
[07:52/12:42]     大大减少了你的环境的成本部成
[07:57/12:42]     然后我们再说一下
[07:59/12:42]     对于测试人员来说
[08:00/12:42]     它有什么价值呢
[08:02/12:42]     对于测试人员来说
[08:03/12:42]     可以说他现在已经是未来测试人员技术展仅了的司去使用容器技术了
[08:18/12:42]     其实应该说除了除非那种传
[08:23/12:42]     除非那种传部
[08:29/12:42]     都是要使用容器技术的
[08:31/12:42]     所以说它已经是不管是对于开发还是测试来说
[08:35/12:42]     它都是未来你们必的一个础也说什么
[08:42/12:42]     他以后后面它会变成一个通用的技能
[08:46/12:42]     它会变成一个通用的技能
[08:48/12:42]     而
[08:50/12:42]     前市面的是在测试K8的还是比较少的
[09:06/12:42]     还是比较少
[09:07/12:42]     以们现在开始去把这项技能给给学会
[09:15/12:42]     那么可以增加你在市面上的一个竞争力
[09:19/12:42]     增加你在市面上的一个竞争力
[09:20/12:42]     尤其是如果说你把这个东西学的非常好
[09:23/12:42]     你把和K8S学的非常非常好的话
[09:27/12:42]     那么以后这个也可以什么呢
[09:31/12:42]     也可以
[09:33/12:42]     让你有一个新的一个发展的方向
[09:36/12:42]     比如说你去各种云公司
[09:37/12:42]     像是阿里云
[09:38/12:42]     腾讯云
[09:39/12:42]     华云牛云
[09:41/12:42]     灵雀云等等等各种云
[09:43/12:42]     这些云公司
[09:45/12:42]     都是可以成为你的这个下一个跳槽的这个对象的
[10:00/12:42]     永远不好学
[10:01/12:42]     这是容器技术的价值
[10:05/12:42]     那他的学习是一个什么样子
[10:08/12:42]     他的学习线是什么样子的我基本上列了
[10:11/12:42]     简单列了五点简单列五点第一点
[10:15/12:42]     我们要学习docker的基本命令
[10:19/12:42]     基本命令包括容器管理和镜像管理
[10:24/12:42]     容器管理和镜像管理
[10:26/12:42]     再然后
[10:27/12:42]     我们还要使用学习
[10:29/12:42]     使用docker去搭建常用的软件
[10:31/12:42]     当然这里面可能有些同学到现在还比较懵逼
[10:34/12:42]     说容器到底是个什么东西
[10:37/12:42]     在这里我给虚拟机来
[10:41/12:42]     它是跟虚拟机是一样的
[10:43/12:42]     是同样都是一种虚拟化解决方案
[10:45/12:42]     只不过他们用的虚拟化技术是不一样的
[10:48/12:42]     所以说docker实际上是是和虚拟机实际上是在很多场景是一样的
[10:56/12:42]     很多场景是一样
[10:57/12:42]     所以说你要把它虚拟机来看的话
[10:59/12:42]     你就可以看这个东西
[11:00/12:42]     其实就是比较还还比较好理解第个你需要了解docker的网络模式和对应的原理
[11:10/12:42]     网络模式
[11:13/12:42]     网络模式就是说你启动容器的时候
[11:15/12:42]     有不同的网络模式供你选择
[11:18/12:42]     不同的网络方案
[11:19/12:42]     不同的方案对应不同的场景
[11:22/12:42]     大家可以去去学习这方面的东西
[11:24/12:42]     这个方面是一个门槛
[11:26/12:42]     是一个门槛
[11:28/12:42]     再然后你要学习docker镜像的制作
[11:30/12:42]     你要自己能制作自己的镜像
[11:32/12:42]     通过do
[11:33/12:42]     通过dark fire去制作自己的镜像
[11:36/12:42]     最后就
[11:38/12:42]     当你把上面这些内容都已经了解完了之后
[11:42/12:42]     那就到了我们的一个什么呢
[11:46/12:42]     到了我们的一个进阶的一个
[11:49/12:42]     就是特别进阶的一个东西了
[11:51/12:42]     我们要学习K8SCU
[11:54/12:42]     是目前容器编排领域的事实标准
[12:00/12:42]     基本上他已经统治天下了统治天下了
[12:05/12:42]     所有公司基本上都是在用它的
[12:07/12:42]     已经非常已经有非常非常少的公司
[12:11/12:42]     已经很少有公司会使用其他容器发
[12:15/12:42]     那这个呢
[12:16/12:42]     就是docker的一个学习路线
[12:19/12:42]     这结束了们这



### 2、Docker 的安装与配置
[00:00/16:39]     [以下字幕均由机器生成]这节课我们来学习一下多客的安装与配置
[00:04/16:39]     [以下字幕均由机器生成]那么在多客的安装与配置里面
[00:06/16:39]     我们可以学到以下的一个内容
[00:08/16:39]     就是生OS怎么去安装多客
[00:11/16:39]     第二个就是我们操作多客服务的基本命令
[00:16/16:39]     第三个就是我们怎么为我们多可去配置一个镜像加速器
[00:23/16:39]     在前面的章节上来说
[00:25/16:39]     已经讲了容器这个概念
[00:27/16:39]     那么现在用的
[00:30/16:39]     比较广泛的一个容器工具来说就是多客
[00:34/16:39]     那多客这个工具来说
[00:36/16:39]     它是支持多个平台操作系统平台的一个容器化的一个工具
[00:42/16:39]     它在Windows上、Linux上和Mac OS都可以去安装
[00:47/16:39]     但是
[00:50/16:39]     因为我们这个生产上去部署这个doer的话
[00:54/16:39]     使用的就是Linux系统的
[00:56/16:39]     所以说推荐大家在学习doer的时候使用Linux这种模式
[01:03/16:39]     而Windows和Mac o这两个系统上面去安装多
[01:08/16:39]     它实际上也是在Windows或者是ma o上去启动一个Linux的一个子系统
[01:13/16:39]     然后去实现我们的一个doer的一个安装
[01:17/16:39]     所以说建议大家在学习这个docker的时候
[01:21/16:39]     直接使用Linux机器
[01:27/16:39]     那么Linux安装这边
[01:29/16:39]     我这边给大家演示的话
[01:31/16:39]     是我们渗OS去安装
[01:33/16:39]     然后乌邦图的一个安装的话
[01:35/16:39]     比这个渗S更简单
[01:37/16:39]     那乌邦图的安装的时候只需要那只需要
[01:42/16:39]     在我们这个
[01:44/16:39]     使用那个比较高版本的
[01:45/16:39]     比如说20.4
[01:50/16:39]     2.04这个版本的乌邦图
[01:52/16:39]     然后我们直接去可以去运行一个apt
[01:55/16:39]     也是多那个多跟11就OK了
[02:01/16:39]     那这边给大家演示的是我们在云服务器上怎么去安装我们的一个多客的一个服务
[02:08/16:39]     那首先我们用root用户登录一下我们的一个云服务器
[02:13/16:39]     如果没有用服务器的话
[02:15/16:39]     大家可能需要自己使用一个虚拟机来进行一个实际操作
[02:21/16:39]     那如果大家不是用root用户
[02:24/16:39]     那我们这时候我们可以去用
[02:26/16:39]     Su
[02:28/16:39]     就是我们去切换一下用户
[02:33/16:39]     因为我们这边现在已经是入推用户了
[02:35/16:39]     那这个时候执行只要命令效果是一致的
[02:39/16:39]     那第二个的话
[02:40/16:39]     我们需要去安装一下多客的一个依赖
[02:42/16:39]     那这边的话
[02:43/16:39]     我们在PPT上已经有注明一下他这边需要安装哪些依赖
[02:47/16:39]     我们这这时候可以去直接复制对应的一个命令就OK了
[02:52/16:39]     嗯
[02:54/16:39]     如果大家已经安装了这些依赖
[02:56/16:39]     那这时候他会去告诉我们已经安装成功了
[02:59/16:39]     那如果大家没安装好
[03:00/16:39]     大家只需要复制这条命令
[03:02/16:39]     把它安装一下就OK了
[03:05/16:39]     然后安装好之后
[03:06/16:39]     我们需要去配置一下下载的一个源
[03:09/16:39]     因为它如果没有这个源的话
[03:11/16:39]     我们是安装不成功的
[03:12/16:39]     我们可以先先尝试一下
[03:15/16:39]     安装一下
[03:19/16:39]     我们可以看到
[03:20/16:39]     这个时候它会去读取
[03:21/16:39]     会去读取我们的对应的一个圆上去找我们的一个多杠11
[03:28/16:39]     那实际上是找不到的
[03:29/16:39]     那这时候实际上我们可以去
[03:31/16:39]     我们
[03:32/16:39]     我们可以去我们的AC
[03:40/16:39]     我们可以看到这里面圆里面是实际上是没有没有我们的一个多客的一个圆的
[03:45/16:39]     那这时候我们只需要布置我们这里面的第二条命令
[03:55/16:39]     布置好这个第二条命令之后
[03:57/16:39]     它实际上就是把对应的一个源添加进去
[04:00/16:39]     然后这边我们可以看到这里面有一个
[04:03/16:39]     有一个对应的一个打印
[04:04/16:39]     就是说这个Li已经被保存到我们的ETClis.d里面的DO1然后点LA
[04:16/16:39]     这时候我们再去去安装一下我们的一个doer
[04:19/16:39]     然后我们doer的话就直接复制下面这条命令
[04:22/16:39]     首先使用这个make catchche就进行一个缓存
[04:25/16:39]     然后接执行我们的一个一个安装
[04:33/16:39]     我们可以看到
[04:35/16:39]     那这时候我们就可以去等待它的一个安装完成
[05:07/16:39]     然后在等待安装好
[05:09/16:39]     等待它的一个安装过程中的话
[05:11/16:39]     我们可以看一下
[05:12/16:39]     它实际上也会给我们去安装一些依赖
[05:15/16:39]     比如说多C1
[05:16/16:39]     比如说contain.io
[05:18/16:39]     然后doer干C1
[05:20/16:39]     然后干C2I就是一个脚手架
[05:24/16:39]     然后在多C1
[05:26/16:39]     他会帮我们把这些依赖
[05:28/16:39]     就是我们要运行多块的时候
[05:30/16:39]     那些依赖他也会给我们安装起来
[06:03/16:39]     然后这时候我们实际上是已经安装完成了
[06:06/16:39]     安装完成之后我们可以看一下
[06:08/16:39]     我们可以运行一下多ER
[06:19/16:39]     那这边的话我们
[06:22/16:39]     我们可以运行一下多杠version
[06:24/16:39]     它就可以看到就是我们当前的的一个版本
[06:30/16:39]     然后安装好之后
[06:32/16:39]     我们接下来看一下我们对这个多服务的一个常用操作
[06:35/16:39]     首先有一个启动
[06:37/16:39]     就是我们启动的一个命令
[06:39/16:39]     使用这边我们这个贴上的第一个命令
[06:43/16:39]     这边的话就是我们直接使用the
[06:50/16:39]     重启的话
[06:57/16:39]     这边的话就是帮我们把这些多先停止掉
[06:59/16:39]     然后再重启一下
[07:01/16:39]     然后还有就是说
[07:04/16:39]     因为我们这个doer通常来说是想开机
[07:07/16:39]     那它就会自动启动的
[07:08/16:39]     我们这边可以去设定一下
[07:14/16:39]     把对应的这个多的这个service加到我们的一个
[07:17/16:39]     重启就是自动在我们系统启动好之后
[07:22/16:39]     自动给启动起来
[07:23/16:39]     好
[07:24/16:39]     这时候我们可以去看一下它的一个运行状态
[07:29/16:39]     可以看到我们那个control到
[07:37/16:39]     Activity的一个状态
[07:40/16:39]     这边的话就是我们
[07:42/16:39]     安装好这个多客
[07:44/16:39]     以及我们可以去使用一些系统命令
[07:47/16:39]     查看一下我们多服务的一个状态
[07:52/16:39]     然后接下来我们去配置一下我们多克的一个加速器
[08:01/16:39]     那么如果我们不配置doer加速器的话
[08:04/16:39]     那么这个doer去拉取我们的一个镜像的时候
[08:08/16:39]     它实际上是通去国外的一个do上去下载
[08:13/16:39]     那这时候我们do的访问的话
[08:16/16:39]     实际上是网速会比较慢
[08:19/16:39]     也就大概20KB左右
[08:20/16:39]     所以说通常我们在使用多这个去做我们的一个的镜像拉取的时候
[08:28/16:39]     会去配置一个镜像源
[08:29/16:39]     那这时候会通过原地址去拉取
[08:32/16:39]     那这个时候下载可以根据自己的网速而定
[08:34/16:39]     那么可以达到十多兆每秒的
[08:37/16:39]     那这个配置我们这个加速源的话是这边步骤来说是在我们的PPT里有
[08:43/16:39]     然后这时候我们可以去看一下
[08:46/16:39]     我们先到对应的这个目录上去
[08:59/16:39]     嗯
[09:06/16:39]     这边的话我们可以去在这个径下去
[09:08/16:39]     执行一个
[09:09/16:39]     然后把
[09:11/16:39]     对应的这个
[09:13/16:39]     能省
[09:15/16:39]     创建一个对应的这个文件
[09:18/16:39]     创建好之后
[09:20/16:39]     我们进入编辑状态
[09:22/16:39]     把对应的一个原地址布置进去
[09:25/16:39]     那么这个圆的话
[09:27/16:39]     如果大家有那个
[09:29/16:39]     有对应的阿里云的一个
[09:32/16:39]     机器的话
[09:33/16:39]     我们这时候可以从我们自己的阿里云的机器上去复制一个地址过来
[09:39/16:39]     如果没有的话
[09:40/16:39]     我们可以使用一些
[09:42/16:39]     我们去找到的一些国内园
[09:46/16:39]     那配置好这个文件之后
[09:48/16:39]     我们需要保存一下
[09:58/16:39]     我们需要保存这个对应的这个文件
[10:01/16:39]     我们需要去重载一下我们do的配置文件
[10:08/16:39]     然后承载好之后
[10:10/16:39]     我们需要去把多可重启一下
[10:20/16:39]     然后重启好之后
[10:21/16:39]     我们再看一下多的一个配置信息
[10:28/16:39]     然后在配置信息
[10:29/16:39]     我们可以看到
[10:30/16:39]     就是我们这个国内源的一个地址已经被配置成我们刚才在PPT上复制这个地址
[10:37/16:39]     那这个地址的话
[10:39/16:39]     可能不是很快
[10:40/16:39]     那如果大家有那个阿里云的话
[10:42/16:39]     可以配置自己的一个地址
[10:45/16:39]     然后配置好之后我们可以去
[10:48/16:39]     试验一下我们对应的这个拉取的一个速度
[10:56/16:39]     我们只需要去执行一下do Pro
[10:59/16:39]     然后某一个镜像
[11:00/16:39]     它这边的话就会给我们去拉取一下
[11:03/16:39]     然后我们去验证一下我们对应的一个网速
[11:22/16:39]     这时候我们可以看到我们去拉取一个engine一个镜像的时候
[11:26/16:39]     刚才一个下摆速度的时候是实际上是比较OK的
[11:30/16:39]     那这时候我们就可以去把一个镜像拉到我们的一个本地
[11:33/16:39]     那接下来我们在后面的课程会教大家怎么去实际上去操作我们的一个镜像拉取
[11:41/16:39]     以及我们怎么去使用我们的一个镜像
[11:44/16:39]     那么在我们这个云服务器部署的时候
[11:48/16:39]     实际上在后边我们大家的学习过程中有使用这个
[11:54/16:39]     多可去启动我们的服务的话
[11:56/16:39]     需要有几个步骤
[11:57/16:39]     我们再提前讲一下
[11:59/16:39]     就是我们先进入一个阿里云
[12:52/16:39]     然后如果大家使用的是阿里云这种ecs这种模式的一个服务
[12:57/16:39]     云服务器的话
[12:58/16:39]     那大家在去启动
[13:01/16:39]     就是去启动我们的容器的时候
[13:03/16:39]     它实际上会有一个端口的一个映射
[13:06/16:39]     就是我们在后边会学到具体怎么操作
[13:09/16:39]     就是我们如果使用的
[13:11/16:39]     比如说这时候多ER run
[13:13/16:39]     的命令
[13:14/16:39]     后面大家都会去学到
[13:34/16:39]     那这个命令就是说我们会去进行一个端口的一个映射
[13:39/16:39]     就是因为engine engine大家都知道
[13:42/16:39]     通常来说我们去部署的是N
[13:44/16:39]     它是会开放一个八零端口
[13:46/16:39]     那八零端口这边
[13:48/16:39]     我们如果执行了一个杠P满8000
[13:52/16:39]     然后
[13:53/16:39]     冒号八零
[13:54/16:39]     也就是说把我们容器的八零端口映射到我们宿主机的一个8000端口上面来
[14:00/16:39]     那映射好这个之后
[14:02/16:39]     那如果我们大家是这个doer是在云服务器上去部署的话
[14:06/16:39]     那这时候我们直接去访问这个8000是访问不了的
[14:11/16:39]     那我们在云服务器上需要再进一步去做一个配置
[14:15/16:39]     那么在云服务器里面
[14:16/16:39]     实际上它是有一个安全组的
[14:19/16:39]     就是如果大家使用的是ecs
[14:20/16:39]     那这种云服务器它是有个安全组
[14:23/16:39]     那大大家进入安全组之后
[14:27/16:39]     这边会有一个方向的一个配置
[14:29/16:39]     就是我们去访问这个云服务器的一个端口配置
[14:33/16:39]     那这时候我们需要去做一个手工添加
[14:36/16:39]     然后把对应的我们映射到我们的一个数组机上的一个端口
[14:40/16:39]     我们要开放出去
[14:43/16:39]     然后这边配置我们直接配置所有IP原都OK
[14:48/16:39]     那这时候我们点击保存
[14:49/16:39]     那这时候做了这一步操作之后
[14:51/16:39]     我们就会把这个8000端口
[14:54/16:39]     把8000端口映射出去
[14:57/16:39]     那这个时候我们这个服务一旦被启动起来
[15:01/16:39]     就是我们的一个容器启动一个服务之后
[15:03/16:39]     那这时我们可以使用这个在云服务器里面一个公网IP
[15:08/16:39]     这个公网IP在对应我们这个命令
[15:11/16:39]     就是我们都会乱起了这个杠P这个前边的一个端口
[15:15/16:39]     通过这种方式
[15:17/16:39]     就是我们这个IP外网IP配上这个端口
[15:20/16:39]     就可以去访问我们在云服务器上通过多乱启动好的一个服务
[15:28/16:39]     那大家如果使用的是轻量级的
[15:31/16:39]     轻量级的一种云服务器的话
[15:33/16:39]     那通常来说它可能是没有这个
[15:36/16:39]     没有这个
[15:38/16:39]     安全组的
[15:39/16:39]     那这时候它可能是一个
[15:41/16:39]     那个防火墙
[15:43/16:39]     那大家在防火墙里面要对应的去开放对应的一个端口访问
[15:48/16:39]     这边的话就是在后边这个课程学习中
[15:52/16:39]     可能大家会碰到的一些
[15:55/16:39]     我们去启动一个服务在云上
[15:57/16:39]     然后防不到
[15:59/16:39]     这这个的一个操作怎么去配置
[16:02/16:39]     那我们简单总结一下了
[16:03/16:39]     就是说我们这节课主要学习到就是首先我们在生怎么去安装我们的一个多客
[16:10/16:39]     那第二的话
[16:11/16:39]     我们对doer server进行的一些基本的一个操作
[16:15/16:39]     怎么去启动
[16:16/16:39]     怎么设置它开机启动
[16:18/16:39]     第三个就是我们怎么去配置我们多的一个镜像加速器



### 3、Docker 容器管理
[00:00/13:26]     [以下字幕均由机器生成]我们来看一下常用的容器管理相关的内容
[00:05/13:26]     主要就是需要去跟我们的容器进行交互的
[00:11/13:26]     这些命令是我们这节课需要掌握的
[00:14/13:26]     特别的多
[00:26/13:26]     尤其是说常用的那命令呢
[00:28/13:26]     其实就这么几个
[00:31/13:26]     如果大家能够掌握PPT里面去列的这些命令呢
[00:35/13:26]     基本上可以满足95%以上的场景了
[00:39/13:26]     好吧
[00:41/13:26]     那么首先我们切到我们的教学服务器里面
[00:45/13:26]     大家可以看一下
[00:46/13:26]     这是我们的教学服务器
[00:48/13:26]     在教学服务器当中呢
[00:50/13:26]     我已经部署好了docker
[00:52/13:26]     并应器启动了很多的容器
[00:54/13:26]     那么让我们来看一下
[00:57/13:26]     就我们要学的第一个命令是什么呢
[00:59/13:26]     是docker PS命令
[01:02/13:26]     Docker PS命令
[01:03/13:26]     大家应该学过Linux吧
[01:05/13:26]     在Linux里面其实不是有一个命令嘛
[01:07/13:26]     就PXAX可以列出当前Linux系统当中所有的进程
[01:14/13:26]     而docker PS则代表了当前机器当中我们查询所有的启动的容器
[01:22/13:26]     然后我们用DOS命令
[01:23/13:26]     大家可以看到这里面有这么多
[01:26/13:26]     这里没有这么多
[01:27/13:26]     从这边开始
[01:28/13:26]     这都是我们当前这台机器里面启动的容器启动的容器大家可以看到
[01:35/13:26]     为什么有这么多呢
[01:36/13:26]     因为我在这台机上也部署了一个单机版的K8S机群单机版的
[01:41/13:26]     所以说这里面很多的容器都是K8S的
[01:47/13:26]     都是K8S的
[01:48/13:26]     当我们用do PS命令展示当前所有的容器的时候
[01:53/13:26]     大家可以看到这里面有几个字段
[01:55/13:26]     大家需要注意I
[02:05/13:26]     后面是image image是代表了我们当前的容器是使用哪一个镜像启动的
[02:13/13:26]     就叫当然后是在多长时间之前创建的容器
[02:29/13:26]     status是代表了当前容器的状态
[02:34/13:26]     容器的状态
[02:35/13:26]     然后names是代表容器的名称容器的名称
[02:42/13:26]     而如果
[02:45/13:26]     如果我们用docker PS命令时候再加一个杠a
[02:49/13:26]     这里面会列出什么呢
[02:51/13:26]     会列出所有非运行状态的
[02:53/13:26]     就包括非运行状态的
[02:57/13:26]     比如说退出状态的
[02:58/13:26]     比如说这种exist
[03:00/13:26]     这种状态的容器也会被列出来
[03:03/13:26]     因为我们用docker PS命令呢
[03:05/13:26]     默认的是只列出当前正在运行的处于运行状态的容器
[03:12/13:26]     处于运行状态的容器
[03:13/13:26]     这个大家能明白
[03:15/13:26]     大家能够明白
[03:19/13:26]     当我们能查看了当前的这些
[03:21/13:26]     容器之后呢
[03:23/13:26]     当然我们也可以去删除它也好
[03:25/13:26]     或者说创建一个新的容器也好
[03:28/13:26]     都是可以的
[03:29/13:26]     比如说如果我们要去创建一个新的容器
[03:34/13:26]     我们要创建一个新的容器
[03:36/13:26]     那要怎么做呢
[03:53/13:26]     去搭S
[03:54/13:26]     那么这里面运用到的就是什么呢
[03:57/13:26]     就是我们的命命
[04:01/13:26]     当然这里面有很多的参数
[04:04/13:26]     有很多的参数这个后面呢
[04:06/13:26]     我们给这个大家讲具体部署具体的服务的时候呢
[04:11/13:26]     会给大家讲到这里面我们先简单的看一下
[04:14/13:26]     如果我们用docker run命令去启动某一个容器的时候
[04:21/13:26]     那么只需要跟上什么呢
[04:23/13:26]     Sorry
[04:24/13:26]     只需要跟上它的镜像名称即可
[04:28/13:26]     通过这种形式
[04:30/13:26]     我们一回车
[04:31/13:26]     Cker就会帮我们可以可以看到这个杰的日志就可刷起来
[04:35/13:26]     CK会帮我们去创建一个容器
[04:41/13:26]     这个容器中已经启动起来了
[04:42/13:26]     大家可以看到这个容器能启动
[04:43/13:26]     当然这样的启动
[04:45/13:26]     它是最简单的
[04:46/13:26]     我们平时不会这样去用
[04:47/13:26]     所以说这里面最大的一个特点是什么
[04:50/13:26]     当我用CTRLC结束当前行的时候
[04:52/13:26]     这个容器也就退出运行了
[04:55/13:26]     也退出运行了
[04:56/13:26]     所以说我们一般呢
[04:58/13:26]     用docker run的时候会用杠D
[05:00/13:26]     用杠D命令
[05:03/13:26]     代表什么呢
[05:04/13:26]     代表让它在后台运行
[05:07/13:26]     让它在后台运行
[05:09/13:26]     这样的话呢
[05:11/13:26]     不会导致于什么
[05:12/13:26]     我当前的上退出之后
[05:14/13:26]     我们的容器就会退出执行
[05:16/13:26]     然后呢
[05:17/13:26]     我们还有一个杠杠name
[05:20/13:26]     我们可以给容器起一个名字
[05:21/13:26]     比如说我们就叫叫
[05:24/13:26]     News啊
[05:26/13:26]     然后我们用这个形式去创建
[05:28/13:26]     大家可以看到
[05:30/13:26]     由于我们加了杠D这个参数
[05:33/13:26]     所以说呢
[05:35/13:26]     我们的容器是在后台运行的
[05:38/13:26]     那我们用docker PS命令
[05:41/13:26]     去grape一下这个叫new jas的容器
[05:46/13:26]     就可以看到了
[05:47/13:26]     这个就是我们刚才通过docker run命令去启动的一个jas的容器
[05:53/13:26]     所以说使用doer还是比较简单的
[05:55/13:26]     当我们只需要拿到我们镜像开发者的镜所提供的镜像之后呢
[06:02/13:26]     我们是可以通过很简单的命令就把它部署起来的
[06:06/13:26]     就把它部署起来的
[06:07/13:26]     OK
[06:09/13:26]     那这是我们创建一个容器
[06:13/13:26]     以及刚才我们用doer PS去查询容器所需要的命令
[06:19/13:26]     所需要的命令
[06:20/13:26]     但当我们不需要这个容器的时候
[06:23/13:26]     可以怎么做呢
[06:25/13:26]     我们可以用
[06:28/13:26]     Stop这个容器
[06:31/13:26]     News这里面大家注意
[06:34/13:26]     也可以用ID
[06:37/13:26]     当然我们用do PS的时候
[06:39/13:26]     大家可以看到
[06:40/13:26]     我们除了能够看到我们之前这个这个new
[06:43/13:26]     这是我们命名
[06:44/13:26]     那我们给这个容器命名之外呢
[06:46/13:26]     还是可以看到它有一个ID
[06:48/13:26]     它这面ID你用ID也是可以的
[06:55/13:26]     你看它就stop掉了
[06:57/13:26]     这个时候我们用端命令你就看不到它了
[07:00/13:26]     MYS
[07:03/13:26]     News你是看不到它的
[07:04/13:26]     因为它处于停止状态
[07:06/13:26]     只有我们在使用杠a的时候
[07:10/13:26]     你可以看到才能看到它被查询出来
[07:13/13:26]     因为它处于停止运行状态
[07:15/13:26]     这里面标记的是13秒之前去停止的
[07:18/13:26]     当你停止之后呢
[07:20/13:26]     如果说
[07:21/13:26]     你不仅仅想想把它停止运行
[07:22/13:26]     你就不需要它了
[07:23/13:26]     你想把它删除
[07:24/13:26]     那就要用docker RM命令
[07:28/13:26]     把它删除掉
[07:30/13:26]     把它删除掉即可即可当然
[07:34/13:26]     这里面大家需要注意的一点是什么呢
[07:36/13:26]     我把这个容器重新启动回来
[07:38/13:26]     把这个重新重新启动起来
[07:40/13:26]     如果我们不不去停止一个容器
[07:44/13:26]     而是直接用调用刀口RM命令
[07:47/13:26]     去删除一个容器
[07:49/13:26]     他会抛一个错误
[07:51/13:26]     他会告诉你说什么呢
[07:52/13:26]     你没有办法删除一个正在运行的容器
[07:57/13:26]     他要求你先把它stop掉
[07:59/13:26]     所以说我们要先stop然后再删除
[08:02/13:26]     但是可能有些同学说这样太麻烦了
[08:04/13:26]     我们可以可不可以直接删除也是可以的
[08:07/13:26]     Hi I'm
[08:08/13:26]     一个参数杠F代表false
[08:11/13:26]     强制删除
[08:13/13:26]     你通过杠F这个参数就可以把它强制的删除掉
[08:18/13:26]     就可以把它强制的删除掉
[08:21/13:26]     这个是我们的docker了
[08:24/13:26]     RM命令也是我们的删除命令
[08:27/13:26]     也就是我们的删除命令
[08:31/13:26]     当然你还可以kill它
[08:33/13:26]     Kill掉它就直接把它杀掉也是可以的
[08:36/13:26]     当然其实Q不常用
[08:38/13:26]     基本上不常用就到不了
[08:40/13:26]     这就可以了
[08:42/13:26]     这是这一部分
[08:46/13:26]     当我们为了演示下面的命令呢
[08:48/13:26]     我还是把这个容器启动起来
[08:50/13:26]     我们要看一下怎么跟这个容器交互
[08:54/13:26]     那可能最常用的交互方式呢
[08:55/13:26]     就是我们希望看一下这个容器的启动日志
[08:59/13:26]     去排查一些问题
[09:00/13:26]     在测试过程中非常常见
[09:01/13:26]     而这个命令就是do log
[09:04/13:26]     Doctor
[09:06/13:26]     然后指定容器名称为车
[09:10/13:26]     这里面我们就可以看到这个容器的整体的启动日制启动日制了
[09:15/13:26]     刚才我们使用doer命令的时候
[09:17/13:26]     把我放大一点
[09:19/13:26]     放大野大家可以看到doctor loves命令的时候呢
[09:22/13:26]     这里面是
[09:24/13:26]     这里面这个它是
[09:28/13:26]     有一个参数是杠F
[09:30/13:26]     这个跟我们的那个在linkx里面的T命令那个不是那个对T命令那个杠F是一样的
[09:37/13:26]     就是能让它持续输出持续输出
[09:40/13:26]     而我们不用杠F的时候
[09:44/13:26]     不用杠F的时候
[09:45/13:26]     那他就你可以看到
[09:46/13:26]     只要输出到当前最新的是之后他就退出了
[09:50/13:26]     他就退出了
[09:51/13:26]     这是我们do命令去查看日志
[09:54/13:26]     当然还有一个可能不是特别常用的是do expect
[10:01/13:26]     是查容器的数据
[10:06/13:26]     数据是什么呢
[10:08/13:26]     我们可以看一下
[10:11/13:26]     New jacks
[10:12/13:26]     你可以看到这属于它的属性
[10:14/13:26]     你可能可以把这个原数据理解为它的属性吧
[10:19/13:26]     包括的IB地址
[10:20/13:26]     它的文件
[10:21/13:26]     它的网络等等等等的一些东西
[10:24/13:26]     它都设置在这里
[10:25/13:26]     一般来说不常用
[10:27/13:26]     但是我们对于我们一些排查错误信息
[10:31/13:26]     或者说要像当前的容器做一些故障的注入的时候
[10:38/13:26]     就会用得到
[10:39/13:26]     因为我们有一种测试类型叫故障注入测试嘛
[10:42/13:26]     也就是说混沌工程
[10:44/13:26]     也叫故障演练
[10:45/13:26]     它容器里面你要对它进行故障演练呢
[10:48/13:26]     那你就需要了解它的一些信息
[10:51/13:26]     那这些信息呢
[10:52/13:26]     都会通过docker back命令去查看
[10:55/13:26]     这个大家我需要大家注意一下
[10:57/13:26]     因为在后续我们讲这个故障注入的时候
[11:02/13:26]     讲故障注入的时候
[11:04/13:26]     我会去利用这个命令去找到这个容器的PI
[11:08/13:26]     然后进行故障注入的
[11:14/13:26]     OK
[11:15/13:26]     那接下来我们看最后一个命令
[11:18/13:26]     Docker exec啊
[11:20/13:26]     本质上docker exec命令是让容器去执行一条命令
[11:26/13:26]     就是说你在容器里执行一条命令
[11:28/13:26]     但是我们经常用来做什么呢
[11:31/13:26]     用来做登录到这个容器里面去
[11:33/13:26]     这也是非常常见的需求
[11:35/13:26]     也是非常常见的需求
[11:36/13:26]     因为我们总是需要什么呢
[11:38/13:26]     我们总是需要排查一些问题
[11:41/13:26]     都需要登录到溶质里面去查一些问题
[11:43/13:26]     那比如说查看配置文件
[11:46/13:26]     查看某些日志信息
[11:48/13:26]     又或者说看一下这个GM的一些运行状态等等等等
[11:53/13:26]     那么它的命令就是do inec
[11:56/13:26]     然后杠it
[11:58/13:26]     建立一个交互的shell
[12:00/13:26]     然后容器名称news
[12:04/13:26]     然后跟一个bash
[12:05/13:26]     就是大家可以想象一下
[12:07/13:26]     就让容器执行一个bash命令
[12:09/13:26]     就相当于你登录上去了回车大家可以看到
[12:12/13:26]     大家可以到
[12:19/13:26]     所以说这里面通过docker execc让容器执行一个BI式命令
[12:29/13:26]     可以变相的达到我们登录到容器里面的这么一个目的
[12:35/13:26]     这么一个目的
[12:36/13:26]     然后这里面你用命令好吧
[12:38/13:26]     这个容器里还没有命令
[12:40/13:26]     Anyway我看有没有icon
[12:43/13:26]     也没有
[12:44/13:26]     因为jacks提供的容器里面呢
[12:46/13:26]     它是比较精简的
[12:48/13:26]     所以说它容器非常少
[12:50/13:26]     它的容器非常少
[12:52/13:26]     它的命令非常少
[12:53/13:26]     OK
[12:54/13:26]     但是enemy我们已经把这个整个的容器环境切换到了我们的容器里面了
[12:59/13:26]     把我们整个的这个shell环境切换到容器里
[13:02/13:26]     然后这里面我们用exit就可以再退回我们的辅主机上面去
[13:09/13:26]     这就是我们常用的容器管理命令了
[13:14/13:26]     这是我们这节的内容
[13:15/13:26]     我们就到这里结束了



### 4、Docker 镜像管理
[00:00/12:33]     我们来看一下docker的镜像管理相关的内容
[00:06/12:33]     我之前也跟大家说过
[00:08/12:33]     这个docker之所以取胜呢
[00:12/12:33]     是因为它的镜像非常的强大
[00:14/12:33]     游戏它制作镜像的这么一个过程
[00:16/12:33]     就是也就说它的do file是非常的强的
[00:20/12:33]     可以说do file是成就了doer这么流行的这么一个原因吧
[00:25/12:33]     那在我们实际的去看doer file之前的时候呢
[00:30/12:33]     我们要先去看一下doer常用的镜像管理的命令
[00:34/12:33]     就是说如何他如何去下载镜像
[00:36/12:33]     推送镜像
[00:37/12:33]     查看镜像
[00:38/12:33]     删除镜像等等等等相关的一系列的内容
[00:45/12:33]     首先先跟大家介绍一下
[00:48/12:33]     这个我们肯定最关心的一个内容
[00:50/12:33]     就是说假如我需要一个镜像
[00:53/12:33]     我要去哪里去找
[00:55/12:33]     这个应该是我们现在最迫切的一个需求
[00:58/12:33]     比如说我们在我们公司的测试环境里面
[01:01/12:33]     我们需要搭建一个软件
[01:03/12:33]     比如说我们要去搭建Java
[01:04/12:33]     又或者说S
[01:06/12:33]     又或者说test link啊
[01:08/12:33]     这些这些软件都是我们测试人员常用的
[01:11/12:33]     对我们测试人员常用的
[01:12/12:33]     又或者说我们要去
[01:14/12:33]     比如说我们要搭建一个测试的服务
[01:17/12:33]     比如说我们自己有一个测试的工具
[01:19/12:33]     或者说测试的平台
[01:21/12:33]     这个测试平台是Java编写了
[01:23/12:33]     我想就就去下载一个Java相关的镜像
[01:26/12:33]     这样我不用自己去制作
[01:28/12:33]     那怎么办呢
[01:30/12:33]     我们最常用的手段是什么
[01:38/12:33]     Library
[01:52/12:33]     这个就是我们的这个最大的镜像仓库
[01:56/12:33]     全球最大的镜像仓库
[01:57/12:33]     也是刀ER官方提供的一个镜像仓库
[02:00/12:33]     我们都是到这个镜像仓库里面去进行下载
[02:05/12:33]     去下载镜像的
[02:08/12:33]     那比如说我们要下载一个JS或者MYS
[02:10/12:33]     我们要下载一个MYS镜像的话
[02:12/12:33]     我们只需要在这里面输入MYSQL
[02:15/12:33]     然后可以查询到各种各样的镜像
[02:18/12:33]     各种各样的镜像我们都可以使用
[02:20/12:33]     我们都可以使用
[02:21/12:33]     尤其是大家可以看到这边标记标记了official image代表什么
[02:28/12:33]     代表着是官方景象
[02:30/12:33]     官方镜像就不是个人制作的镜像
[02:32/12:33]     也不是某个组织制作镜像
[02:34/12:33]     而是MY赛克官方的镜像
[02:36/12:33]     所以说大家在去下载这些镜像的时候
[02:42/12:33]     尽量先找官方镜像去下载
[02:45/12:33]     因为它的文档
[02:46/12:33]     它的这个功能
[02:47/12:33]     肯定是最全的官方提供的对吧
[02:50/12:33]     你可以看到这里面光stars就有10K加
[02:53/12:33]     90K加
[02:55/12:33]     我们点击进来
[02:56/12:33]     它里面会有详细的文档
[03:00/12:33]     我们说官方镜像是非常全的嘛
[03:02/12:33]     它有详细的文档
[03:03/12:33]     这个镜像要怎么用
[03:04/12:33]     它都有什么样的参数
[03:07/12:33]     甚至它有什么样的版本都在这里面
[03:10/12:33]     都在这里面去这个这个这个
[03:12/12:33]     列好了
[03:14/12:33]     而我们要做的是什么
[03:16/12:33]     就是my circlemy circle
[03:20/12:33]     比如说我们在我们的教学服务器里面用铺MYSQL
[03:25/12:33]     回车
[03:28/12:33]     它就会到默认我们这个镜像仓库里面去下载MYSQL的这个镜像
[03:34/12:33]     MYSQL的镜像了当然这个下载的过程它比较长
[03:38/12:33]     因为毕竟买SQ的镜像还是有点大的
[03:41/12:33]     还是有点大的
[03:42/12:33]     所以这个我看一下吧
[03:45/12:33]     看看这个把这一条下完之后
[03:46/12:33]     他会不会接着下
[03:50/12:33]     OK
[03:51/12:33]     我们等一下等一下
[03:54/12:33]     应该很快
[03:59/12:33]     这样子的话我们就会
[04:02/12:33]     我们就会这个这个这个
[04:07/12:33]     把这个东西下载下来了
[04:10/12:33]     那么下载下来之后呢
[04:13/12:33]     我们的镜像下载下来之后呢
[04:15/12:33]     我们又可以用docker image4命令
[04:17/12:33]     Docker image去查看当前机器的所有的镜向
[04:22/12:33]     这是我们当前所有的镜像
[04:26/12:33]     我们当前机器所有的镜像叫docker images
[04:29/12:33]     Images这边有什么呢
[04:32/12:33]     会有这个也有几个字段
[04:36/12:33]     是的啊
[04:47/12:33]     然后tag代表的是版本号
[04:50/12:33]     镜像有版本的买色Q有5.55.65.7
[04:54/12:33]     后来没有说7.08.0等等等等
[04:56/12:33]     它是有版本的
[04:59/12:33]     就是T版本号
[05:00/12:33]     然后最后面是1IMAGE的ID
[05:02/12:33]     它制作的时间和它的大小
[05:05/12:33]     是没有本
[05:27/12:33]     这个景象
[05:29/12:33]     景它代表什么
[05:31/12:33]     代表俩最新的
[05:33/12:33]     而如果我们在这里面写5.5代表什么呢
[05:36/12:33]     我们要下载的是5.5版本的景象要指定版本呢
[05:40/12:33]     就是跟一个冒号
[05:41/12:33]     冒号后面跟着5.5回撤
[05:44/12:33]     这里面他应该去下载5.5的镜像了
[05:47/12:33]     就啊
[05:50/12:33]     当然我看看这里边儿
[05:51/12:33]     他提没提供5.5
[05:54/12:33]     他好像并没有
[06:00/12:33]     还是能找到的
[06:01/12:33]     只不过它的这个
[06:03/12:33]     它的这个这个文档里没有明确的写
[06:07/12:33]     但是其实是有5.5的这个镜像
[06:09/12:33]     对这里面就有这面就有的好的
[06:12/12:33]     这个就是我们的镜像的下载
[06:15/12:33]     当然还有一个命令是什么呢
[06:17/12:33]     就push
[06:19/12:33]     是把我的镜像
[06:21/12:33]     我本地的镜像呢
[06:23/12:33]     Push到镜像仓库里面去
[06:25/12:33]     这个有点麻烦
[06:27/12:33]     这个是在后面我们下一节去讲这个进行仓库的搭建的时候
[06:32/12:33]     再给大家演示这个命令
[06:33/12:33]     因为目前我们现在还没有进行仓库可以供我们推送
[06:37/12:33]     所以说这个我们先不讲
[06:40/12:33]     我们就是直接看
[06:43/12:33]     删除命令删除当前机器的一个镜像
[06:48/12:33]     删除一个
[07:00/12:33]     所以说它是r mi
[07:01/12:33]     我们把我们刚才的这个镜
[07:03/12:33]     比如说
[07:07/12:33]     你看
[07:08/12:33]     它是可以直接删除的
[07:10/12:33]     它是可以直接删的
[07:16/12:33]     然后呢
[07:17/12:33]     这里面大家需要注意的是什么
[07:19/12:33]     是删除镜像的时候
[07:23/12:33]     删除镜像的时候
[07:28/12:33]     是要有一个前提
[07:30/12:33]     就是说这个镜像不能被使用
[07:33/12:33]     就是假如说你已经运行一个容器
[07:35/12:33]     用当前这个镜像运行了这个容器
[07:38/12:33]     的话的话
[07:41/12:33]     它是不让删的
[07:42/12:33]     就会报错就会报错
[07:44/12:33]     他会告诉你当前镜像正在被使用中
[07:46/12:33]     你是不可以删除的这命
[07:54/12:33]     Doctor的命令比较有意思
[07:56/12:33]     他可以干一件什么事呢
[07:58/12:33]     他可以把这个我们当前的
[08:00/12:33]     比如说我们当前的这个
[08:02/12:33]     叫买色Q这个镜像我们刚才下了最新版本的那个蓝色镜像
[08:06/12:33]     你可以再给他打一个T
[08:10/12:33]     叫MY买
[08:11/12:33]     就是说叫new麦Q
[08:15/12:33]     蓝色狗
[08:16/12:33]     这个时候你在这个用docker image命令你再去查看的时候
[08:22/12:33]     只有一个有意思的事情
[08:24/12:33]     Sorry
[08:25/12:33]     你没这意思
[08:26/12:33]     然后grab my这里面你可以看到这里面有一个叫MY的
[08:32/12:33]     是我们刚才下载了最新的MYL版本的
[08:36/12:33]     上面还有一个new
[08:39/12:33]     两条记录两条记录
[08:42/12:33]     然后我们可以看到他们的image ID是一样的
[08:45/12:33]     它的这个这个有点像我们上面去在一个分支上打T一样
[08:49/12:33]     你可以打很多个T对于同一个
[08:52/12:33]     我们现在对于同一个镜像
[08:54/12:33]     你可以打很多个T
[08:56/12:33]     但是他们其实都是指向了同一个镜像
[08:59/12:33]     就相当于你给它起了一个新的名字一样
[09:01/12:33]     给原本的这个东西起了一个新的名字一样
[09:05/12:33]     这个它会比较重要是什么呢
[09:07/12:33]     它会比较重要是什么呢
[09:08/12:33]     因为我们一般打版本号的时候都是用这个东西去打的
[09:12/12:33]     比如说我们要给他给这个打一个版本号
[09:15/12:33]     就是给镜像打括号到images
[09:17/12:33]     然后tag
[09:18/12:33]     比如说my circle
[09:19/12:33]     然后my circle打一个版本号叫什么
[09:22/12:33]     叫OV1.0
[09:25/12:33]     不应该加image
[09:30/12:33]     这时候你再去还有sorry
[09:32/12:33]     这时候再去查的时候
[09:34/12:33]     你可以看到这又多了一个MY
[09:35/12:33]     只不过后面跟了一个叫V1.0的这么一个版本号
[09:39/12:33]     所以说doer塔克这个名还是很重要的
[09:41/12:33]     同时它也是要把这个
[09:45/12:33]     我们要去把一个镜像去推送到不同的镜像仓库里面
[09:51/12:33]     非常重要的一个机制
[09:54/12:33]     这个机制我们在讲镜像仓库那一节里头跟大家详细的讲解
[09:57/12:33]     在这里面大家都知道do t的命令能造成什么效果就可以了
[10:03/12:33]     然后再然后我们再看两个命令
[10:05/12:33]     一个是save
[10:06/12:33]     一个是他们两个主要是什么呢
[10:11/12:33]     他们两个主要是面对一些特殊的场景
[10:14/12:33]     就比如说
[10:16/12:33]     我们有一些场景可能是没有外网的
[10:19/12:33]     比如说我们做私有化的这种
[10:22/12:33]     场景
[10:24/12:33]     我在做私有化这个产品里面
[10:26/12:33]     我们可能有一些机房里面是防不了外网的
[10:29/12:33]     也就是说你没有办法从外部去下载
[10:31/12:33]     所以说你可能需要把这个
[10:35/12:33]     把这个一些镜像
[10:37/12:33]     保存到一个文件里面去
[10:40/12:33]     保存一个踏包里面去
[10:41/12:33]     然后呢
[10:42/12:33]     传到那个机器上
[10:43/12:33]     然后再把它load进去
[10:45/12:33]     而save和load就是干这个活的
[10:48/12:33]     首先我们需要docker save命令
[10:52/12:33]     Doer save命令
[10:53/12:33]     我先把它切到这个某一个目录下面去吧
[11:01/12:33]     我进七了
[11:02/12:33]     TP那吧
[11:03/12:33]     PP
[11:04/12:33]     我们可以用docker tag命令
[11:07/12:33]     不是save命令
[11:12/12:33]     当前的这个MYSQL的镜像打到一个踏包里边
[11:16/12:33]     叫MYSQL点塔
[11:19/12:33]     买口罩他
[11:21/12:33]     就是把这个镜像以文件的形式保存在这里
[11:25/12:33]     大家可以看到这里多了一个MYSQL
[11:27/12:33]     这样的话我们就可以把这个踏包传到我们的目标的服务器上
[11:31/12:33]     然后在目标的服务器安装好doer之后呢
[11:34/12:33]     再用docker load命令
[11:36/12:33]     再用一个符号
[11:41/12:33]     麦
[11:42/12:33]     但大家可以看到save的时候使用的是输出符号
[11:46/12:33]     这个大家这个用用用I命令的时候去写到一个文件夹里面的
[11:50/12:33]     就是这个这个命令输入重镜项符号
[11:52/12:33]     这个大家Li斯的命令应该都知道
[11:55/12:33]     我不详细解了
[11:56/12:33]     然后漏的命令是这样的
[11:58/12:33]     漏进去之后你可以看到它就会把这个东西搂进来了
[12:03/12:33]     把镜像给搂进来了
[12:05/12:33]     好的
[12:06/12:33]     这个就是我们常用的镜像管理命令
[12:09/12:33]     基本上你学会了这些之后
[12:10/12:33]     学会了这之后也可以满足你们95%以上的场景
[12:14/12:33]     好
[12:16/12:33]     这节课我们就录到这儿了



### 5、搭建 Web 服务器 Nginx
[00:00/10:39]     让我们来看一下实战相关的内容
[00:03/10:39]     我们想要希望通过一行命令就部署一个NGX武器
[00:08/10:39]     来带大家展示一下在docker里面
[00:13/10:39]     我们如何去部署我们的一些测试需要的服务
[00:16/10:39]     因为前几节课里面呢
[00:18/10:39]     我们可能都是学习的刀客的一些基本的命令
[00:21/10:39]     但是呢
[00:22/10:39]     可能没有涉及到一些实际的场景
[00:25/10:39]     那么在这里呢
[00:27/10:39]     我们先开始最简单的一个
[00:31/10:39]     一个场景吧
[00:32/10:39]     就是一键去部署NGX
[00:34/10:39]     因为毕竟NGX也是在我们的这个工作当中最常遇到的一种一种服务了
[00:40/10:39]     所以说我们使用它来进行这个讲解
[00:44/10:39]     那上节课的时候
[00:46/10:39]     就前节课的时候呢
[00:47/10:39]     我们曾经用docker run这个命令去启动过
[00:51/10:39]     启动过像是jacks这样的一个器
[00:55/10:39]     这个这样的一个容器
[00:57/10:39]     但是当时呢
[00:59/10:39]     我们配的这个使用参数还没有少
[01:01/10:39]     有很多问题没有解决
[01:03/10:39]     那么首先第一个让我们来看一下
[01:07/10:39]     如果说我们要启动这个
[01:10/10:39]     就像我们上节课一样
[01:11/10:39]     我们启动一个容器
[01:13/10:39]     一般来说要设置一个name
[01:15/10:39]     设置一个name代表的是我们的容器的名称
[01:20/10:39]     比如说我们就叫my andx啊
[01:23/10:39]     这叫MYX
[01:24/10:39]     然后用杠D
[01:26/10:39]     代表着是说我们在后台运行
[01:28/10:39]     这个大家应该都还记得对吧
[01:31/10:39]     然后后面跟着我们的镜像名称
[01:33/10:39]     镜像名称就是NGX
[01:36/10:39]     就是NGX
[01:37/10:39]     那这样去启动是可以启动起来的
[01:39/10:39]     但是它并不具备实际的意义
[01:42/10:39]     为什么呢
[01:43/10:39]     因为
[01:45/10:39]     动
[01:46/10:39]     首要问题是启动个外界
[01:52/10:39]     我们在外界是没有办法访问他的
[01:54/10:39]     因为我们没有做端口映射我们没有做端口映射
[01:58/10:39]     实际上呢
[01:59/10:39]     我们还需要一个杠P参数来去做我们的端口映设的
[02:03/10:39]     就像我们这套我在这个PPT里写的一样
[02:06/10:39]     要做一个端口映射
[02:07/10:39]     为什么要做一个端口映射呢
[02:11/10:39]     来讲一下
[02:13/10:39]     我们先把命令打在这里
[02:15/10:39]     之所以需要做端口映射的原因是因为docker是一个容器
[02:20/10:39]     它跟P拟机不一样
[02:22/10:39]     它跟虚机不一样
[02:24/10:39]     从原理上讲呢
[02:26/10:39]     它是隔离一切的
[02:28/10:39]     包括网络
[02:29/10:39]     包括进程等等等等这些东西
[02:31/10:39]     外界是没有办法访问它的
[02:33/10:39]     也就是说
[02:34/10:39]     假如说我现在从我的笔记本上要去访问我们现在教学服务器中的美容
[02:38/10:39]     这是访问不到的
[02:40/10:39]     是访问不到的
[02:41/10:39]     因为容器在启动之后
[02:44/10:39]     我们刚才说了
[02:45/10:39]     它的所有的这些东西都是隔离的
[02:47/10:39]     包括网络和进程
[02:48/10:39]     所以说它使用的IP地址也是一个私有的虚拟的IP地址
[02:53/10:39]     是这个IP地址是不进路由表的
[02:56/10:39]     我们在do启动docker的时候
[02:57/10:39]     其实doer就会在这台机器内部去维护一个虚拟的局域网
[03:03/10:39]     这个大家应该可以理解吧
[03:04/10:39]     就像我在家里面是没有办法访问公司的电脑的
[03:07/10:39]     在公司也是没有办法访问家里的网络环境是一样的是一样的
[03:12/10:39]     除非我们搭建VPN对不对
[03:14/10:39]     除非我们搭建VPN
[03:16/10:39]     所以说大家可以暂时理解做端口映射就好像是开了个VPN一样
[03:21/10:39]     虽然它从原理上是完全不一样
[03:23/10:39]     VPN使用的是隧道网是不
[03:37/10:39]     就是说我的在我的笔记本上是没有办法访问这个我们教学服务器上的容器的
[03:42/10:39]     对不对
[03:43/10:39]     但是我们教服务器可以
[03:44/10:39]     因为我们教服务器是启动容器的一个地方
[03:46/10:39]     所以说它是可以访问
[03:48/10:39]     对吧
[03:50/10:39]     所以说我们希望做一件什么事情呢
[03:52/10:39]     我们就把教学服务器
[03:53/10:39]     我们部署刀的这个服务器当做我们的一个跳板机
[03:57/10:39]     大家在很多公司工作
[03:59/10:39]     应该知道跳板机这个概念对吧
[04:01/10:39]     我们先通过连接教学服务器
[04:04/10:39]     然后呢
[04:05/10:39]     让教学服务器把我们的网络请求转发给容器转发给容器
[04:10/10:39]     那通过这样的一个形式呢
[04:12/10:39]     那我们就可以这个来到达到间接的与容器网络进行通信的这么一个目的通信这么一目的
[04:19/10:39]     那好我为了给大家来演示一下
[04:21/10:39]     我就得点回车
[04:23/10:39]     把这个东西启动起来这是我课的时候已经
[04:30/10:39]     大家还记得这个RM杠F命令吗
[04:32/10:39]     删除一个正在运行的一个东西
[04:35/10:39]     当我们删除之后呢
[04:37/10:39]     那我们就可以再去使用这个命令把它部署回来
[04:42/10:39]     那这样他们部署回来之后
[04:45/10:39]     我们在这里面
[04:48/10:39]     然后一刷新可以看到这里面就会有一个welcome to in啊
[04:53/10:39]     这是in的首页这是in的首页
[04:56/10:39]     那我们
[04:58/10:39]     再来给大家尝试一下
[05:00/10:39]     如果我们不这个
[05:03/10:39]     不加这个端口映射
[05:04/10:39]     会是什么样的
[05:07/10:39]     在这边我去刷新它是虽然容器启动起来了
[05:11/10:39]     但是它是没有办法访问的
[05:13/10:39]     不管你是访问八零端口还是访问5003
[05:17/10:39]     都是访问不了的
[05:19/10:39]     而做了端口映射
[05:27/10:39]     这样做端口映设
[05:28/10:39]     它达到一个什么效果
[05:29/10:39]     我们可以看到杠P这个参数
[05:32/10:39]     P就是port的缩写
[05:35/10:39]     Port的简写
[05:36/10:39]     杠P就是杠杠port的意思的意思做口
[05:45/10:39]     500303端口映射到容器的八零端口上
[05:51/10:39]     也就是说
[05:52/10:39]     当我们运行使用了这个参数之后
[05:55/10:39]     凡是发往当前宿主机的535003端口的网络请求都会被转发到容器的八零端口上
[06:04/10:39]     中间用一个冒号
[06:06/10:39]     冒号的左边是四主机的端口
[06:08/10:39]     冒号的右边是容器的端口通过这样的一个形式
[06:12/10:39]     我们再刷新一下
[06:13/10:39]     你可以看到这边就可以看到这个主页了
[06:17/10:39]     这个后面呢
[06:18/10:39]     我们会在实战课里面
[06:20/10:39]     会详细的给大家讲
[06:23/10:39]     讲这里面的原理是什么样子的这里面原理是什么样子的
[06:27/10:39]     这里面的一些知识点还是蛮有意思的
[06:29/10:39]     这些知识点也是你后续要这个如果你想在容器领域里面走的更远的话
[06:37/10:39]     需要掌握的知识点
[06:38/10:39]     这个我们在试堂课里面继续讲好吧
[06:42/10:39]     OK
[06:43/10:39]     这是我们要做的第一个需求
[06:44/10:39]     端口映射
[06:45/10:39]     只有通过端口映射
[06:47/10:39]     我们才能把我们才能访问我们部署起来的服务
[06:49/10:39]     但是这样的形式呢
[06:51/10:39]     其实也是非常
[06:54/10:39]     最直观缺陷就是我们要在这个服务器里面部署一些东西
[07:00/10:39]     部署一些东西
[07:01/10:39]     我怎么不说那但是可能有同学说
[07:03/10:39]     那我把文件拷贝到
[07:05/10:39]     比如说拷贝到这个容器里可不可以
[07:08/10:39]     因为因为这里面有一个doer cp命令
[07:10/10:39]     虽然不常用
[07:11/10:39]     它有这个命令
[07:12/10:39]     这个命令是用来往docker里边或者是从docker往次主机上去copy文件的
[07:19/10:39]     但是这个命令基本上没人用
[07:21/10:39]     所以说我在讲这个课程没给你讲
[07:24/10:39]     因为很多不常用的命令
[07:25/10:39]     因为我们有接下来要讲的这个机制接下来讲机制
[07:29/10:39]     为什么copy do copy这个命令不能用呢
[07:33/10:39]     就是说基本上没人用呢
[07:34/10:39]     就是因为它是这样的
[07:36/10:39]     就是说你这个命令无法达到给容器做持有化的这么一个需求
[07:41/10:39]     就比如说我现在就算把一个包的拷贝到了我们的容器里面
[07:49/10:39]     然后这个就是说
[07:51/10:39]     然后这个把它部署起来
[07:53/10:39]     但是当你把这个容器删掉之后
[07:55/10:39]     其实你们包也就没了就是容器本身是没有办法存储任何东西的
[08:01/10:39]     一旦你把这个容器删除
[08:04/10:39]     那么容器里面所有东西就没了
[08:06/10:39]     所以说do cp命令是不常用的
[08:08/10:39]     是不常用的
[08:09/10:39]     而取代我们是用另外一种形式
[08:11/10:39]     这种形式叫数据就挂载
[08:15/10:39]     就是这样的一个命令
[08:16/10:39]     它是这样的一个命令
[08:18/10:39]     我们肯定是需要一个HTML的一个东西
[08:23/10:39]     它在这这个我事先创建好了
[08:24/10:39]     这里边有一个index
[08:27/10:39]     HTM里面就是一个很简单的hello
[08:30/10:39]     这个我已经事先准备好是吧
[08:32/10:39]     OK
[08:33/10:39]     那我们是要把这一个文件挂载到容器里面去
[08:37/10:39]     挂载到容器里面去
[08:39/10:39]     这样的话
[08:40/10:39]     容器启动之后
[08:41/10:39]     NG读的是这个文件
[08:42/10:39]     那这里面你可以认为就是说刚才我们做的是端口上的映射
[08:46/10:39]     把四主机和容器的端口进行映射
[08:49/10:39]     这里面呢
[08:50/10:39]     其实就是文件的映射
[08:51/10:39]     其实它正确的叫法叫文件的挂载
[08:54/10:39]     我们把45G的一个目录挂载到容器里面去
[08:58/10:39]     而这里面用的就是这个
[09:00/10:39]     这个可以
[09:03/10:39]     这个还是得删除一下
[09:08/10:39]     MYX删除一下
[09:10/10:39]     然后才能用这个命令来看到docker
[09:17/10:39]     这个可能是我PPT又写错了
[09:19/10:39]     大家见谅
[09:20/10:39]     Run
[09:22/10:39]     杠D
[09:23/10:39]     我们多光车这里面多了一个杠VV是volume的意思
[09:27/10:39]     是啊
[09:30/10:39]     数据卷
[09:31/10:39]     专门用来做容器挂载的地方
[09:33/10:39]     这个时候呢
[09:34/10:39]     我们这里面就是什么呢
[09:35/10:39]     这里面就可以用这个
[09:39/10:39]     这个
[09:41/10:39]     Sorry
[09:43/10:39]     这个用PWD
[09:51/10:39]     DWD这个获取当前的目录
[09:54/10:39]     然后下面的HTML文件夹
[09:55/10:39]     然后映射到容器
[09:57/10:39]     就是挂在的容器的这个径下
[09:59/10:39]     这样N几就可以堵它
[10:00/10:39]     然后回撤
[10:01/10:39]     OK
[10:02/10:39]     当我们回撤完创建完之后
[10:05/10:39]     然后我们再回到这里面来再刷新
[10:08/10:39]     你看这里面就不是NGC首页了
[10:10/10:39]     直接就变成什么了
[10:13/10:39]     变成hardwork
[10:15/10:39]     所以说今天这两这一节小小内容
[10:18/10:39]     主要是通过部署in来给大家讲解一下我们最常用的两个场景
[10:25/10:39]     最常用的两个参数
[10:26/10:39]     也是端口映射用来做访问的
[10:28/10:39]     再一个就是持久化
[10:30/10:39]     再一个就是石油化
[10:31/10:39]     OK
[10:32/10:39]     那我们这节课就到这里了



### 6、搭建数据库服务 MySQL
[00:00/06:35]     [以下字幕均由机器生成]我们现在连续的好几节小小课呢
[00:03/06:35]     其实都是在讲一行命令
[00:05/06:35]     怎样部署一个服务出来
[00:07/06:35]     只不过每部署每次部署一个服务呢
[00:10/06:35]     可能我们都要我都要给大家领大家去看一下一个新的使用方式而已比如说在之前的一个小节
[00:20/06:35]     我们学习这个一行命令部署NG的时候呢
[00:24/06:35]     是带大家看了一下
[00:26/06:35]     端口映射和目录挂载这两种使用方式
[00:31/06:35]     是通过ndi这个实例
[00:34/06:35]     大家看一下这两个参数的使用方式
[00:37/06:35]     那MYSL这里面呢
[00:39/06:35]     我们还要介绍一个新的使用方法
[00:42/06:35]     这个实的使用方法就是环境变量
[00:44/06:35]     就是环境变量
[00:47/06:35]     为什么要去给容器设置环境变量呢
[00:51/06:35]     大家可以理解为是用户向容器传递一个参数
[00:57/06:35]     这个大家应该能理解
[00:58/06:35]     我们应该都编写过一些编程语言
[01:01/06:35]     比如说Java或者是Python
[01:02/06:35]     我们在定义一个函数的时候
[01:04/06:35]     其实很多的细节是没有办法固定下来的
[01:08/06:35]     需要用户传递
[01:09/06:35]     就是说我们调用这个函数的人去传递一些参数来去定制化相关的行为
[01:15/06:35]     这个应该都能理解
[01:16/06:35]     对吧
[01:17/06:35]     那容器也是一样的
[01:18/06:35]     这些镜像的开发者呢
[01:20/06:35]     其实他在开发镜像的时候是有很多细节没有办法固定下来的
[01:26/06:35]     比如说我开发一个买色Q的镜像
[01:29/06:35]     那这个镜像里面买SQL里面应该有什么样的用户
[01:33/06:35]     那这些用户有什么样的密码
[01:35/06:35]     什么样的权限
[01:37/06:35]     其实不能固定死的
[01:38/06:35]     因为你固定死的话
[01:41/06:35]     用户有很多场景是满足不了的
[01:44/06:35]     所以说是需
[01:45/06:35]     到暴露一些能力
[01:46/06:35]     让用户定制化
[01:48/06:35]     比如说用用户可以自己定制自己的密码
[01:51/06:35]     定制权限等等等等
[01:53/06:35]     就跟在我们编写函数的时候
[01:56/06:35]     传递参数是一样的
[01:57/06:35]     而在容器领域里面
[02:00/06:35]     传递参数的这个方式就是传递环境变量
[02:03/06:35]     我们在其中一个容器的时候呢
[02:05/06:35]     就直接传递一些环境变量进去
[02:07/06:35]     这样的话呢
[02:08/06:35]     这个镜像呢
[02:09/06:35]     里面的程序呢
[02:10/06:35]     规定好读取固定的环境变量来初始化自己的行为
[02:14/06:35]     就是这样子的
[02:17/06:35]     那我们来看一下
[02:19/06:35]     我们今天要讲的这个这个
[02:24/06:35]     其实我们可以在这个do里面
[02:27/06:35]     我们可以搜myco
[02:28/06:35]     我们之前曾经讲过
[02:30/06:35]     在在do里面这个标记为official image的镜像都是官方镜像
[02:37/06:35]     这是我们推荐使用的
[02:39/06:35]     推荐优先使用这个官方镜像
[02:41/06:35]     因为它功能比较齐全
[02:43/06:35]     有保障
[02:44/06:35]     它是有保障的
[02:45/06:35]     有专门维护
[02:46/06:35]     功能比较齐全
[02:47/06:35]     各个版本都有
[02:48/06:35]     你可以看到这边有个版本
[02:51/06:35]     各个版本都有
[02:52/06:35]     而且它的文档非常的
[02:53/06:35]     其实你看这里面都是变量
[02:56/06:35]     都是供时候量
[03:03/06:35]     那么
[03:06/06:35]     那么我们肯定是不会带大家这个一行一行去这个文档
[03:11/06:35]     这个文档肯定是效率太
[03:14/06:35]     直接的一个实例来给大家看一下
[03:18/06:35]     怎么样去环境传递环境变量
[03:27/06:35]     之外你可以发现
[03:32/06:35]     大家可以发现它多了一个参数就是杠一
[03:39/06:35]     开头字母e就是environment
[03:42/06:35]     开头字母代表变量
[03:44/06:35]     以是变量的K
[03:50/06:35]     然后等号
[03:51/06:35]     等号右边是环境变量的值
[03:55/06:35]     在启动这个容器的时候
[04:09/06:35]     那它初始化的这个目的呢
[04:10/06:35]     其实也就写在这个环境变量名字里面
[04:14/06:35]     就是给MYL的用户的密码设置一个值这样的话用户在启动的时候呢
[04:21/06:35]     可以自己设置自己的root密码的
[04:24/06:35]     自己设置自己的root密码的
[04:26/06:35]     那我们把这个复制下来
[04:30/06:35]     我们把这个复制下来
[04:32/06:35]     然后我们在教学服务器里面
[04:35/06:35]     桥梁运行一下
[04:37/06:35]     当我们把这个容器
[04:39/06:35]     把这个容器启动起来之后呢
[04:44/06:35]     我们可以看一下面这个
[04:54/06:35]     我们在之前的时候有讲过docker exec杠it
[04:58/06:35]     然后我们容器名称再跟一个bash
[05:00/06:35]     好
[05:01/06:35]     打开一个窗口
[05:02/06:35]     通过这样的一个形式
[05:04/06:35]     我们就可以登录到容器里面
[05:06/06:35]     与容器进行交互
[05:10/06:35]     那我们可以用MYSQL的客户端杠u root杠P
[05:18/06:35]     这条命令可以运行成功
[05:20/06:35]     就代表其实MYSQL已经启动起来了
[05:23/06:35]     它让你输入一个密码
[05:26/06:35]     就是我们刚才在这边
[05:30/06:35]     设置的密码我们复制一下
[05:33/06:35]     回车
[05:34/06:35]     可以看到
[05:37/06:35]     我们用data我们已经登录进来了
[05:41/06:35]     Show database
[05:44/06:35]     你可以看到
[05:46/06:35]     这个我们已经部署成功了
[05:48/06:35]     我们周一部功部署成功了
[05:51/06:35]     所以说今天要带大家看一下如何启动一个MY一启动一个MY
[05:58/06:35]     以及通过这个实例这节课通过这个实例来大家看一下这个环境变量的使方式
[06:06/06:35]     环境变量的使用方式
[06:11/06:35]     OKOK
[06:12/06:35]     那我们这一节小课就到这里结束了
[06:17/06:35]     大家拜拜



### 7、搭建持续集成平台 Jenkins
[00:00/09:21]     [以下字幕均由机器生成]这一节小课里面我们来大家看一下如何用一行命令去启动jas
[00:05/09:21]     [以下字幕均由机器生成]jas应该算是我们的测试开发这个岗位里面最常用的一个软件了
[00:11/09:21]     我们做了很多的一些自动化
[00:12/09:21]     都需要对接到J上去运行
[00:14/09:21]     那所以说这节课呢
[00:15/09:21]     我们来看一下如何用docker去启动S
[00:21/09:21]     然后在今天这一节课里面呢
[00:23/09:21]     我们也是给大家带来一些新的参数的使用和新的使用模式
[00:28/09:21]     那之前我们已经讲过了还有这个
[00:33/09:21]     还有这个MY
[00:36/09:21]     分别给大家带来了一些docker run的时候新的使用方式
[00:39/09:21]     我们再来看一下
[00:42/09:21]     我们还可以用一些什么其他的一些参数来优化我们的这个容器的运行
[00:50/09:21]     那首先我们还看当前这个PPT
[00:53/09:21]     当前这个PPT这里面呢
[00:55/09:21]     可以看到这个命令会比较长
[00:57/09:21]     这个命令会比较长
[00:59/09:21]     首先一点是什么呢
[01:00/09:21]     首先首先第一点就是它有一些参数
[01:04/09:21]     其实是可以设置多个的
[01:06/09:21]     你比如说
[01:07/09:21]     杠P
[01:09/09:21]     我们之前说的端口映射
[01:10/09:21]     那你之前的时候只是映射一个端口
[01:13/09:21]     那这回我们可不可以映射两个端口呢
[01:16/09:21]     完全是可以的
[01:19/09:21]     我们一说出两个端口来是完全可以没有任何问题
[01:22/09:21]     是没有任何问题的
[01:23/09:21]     再然后一个是什么呢
[01:26/09:21]     再然后是一个是我们又多了一些其他的参数就我们一个个来讲
[01:32/09:21]     首先我们从头来用run的时候
[01:36/09:21]     刚刚name指定容
[01:38/09:21]     杠D这杠杠it是可以不用
[01:43/09:21]     其实是可以不用写的
[01:44/09:21]     我们就看杠D
[01:45/09:21]     杠D代表在后台运行两个杠P代表端口映射
[01:49/09:21]     这个8080端口是S的主服务web服务的一个端口
[01:54/09:21]     而5万端口是JS的这个
[02:00/09:21]     Jens的这个slave要连接的端口号
[02:03/09:21]     Jens slave要连接的端口号
[02:06/09:21]     好吧
[02:07/09:21]     再然后杠杠这个是什么呢
[02:12/09:21]     这个是说如果你的容器因为异常原
[02:25/09:21]     自动会帮你重启的
[02:26/09:21]     这个参数比较方便
[02:28/09:21]     因为我们有时候部署的服务难免可能遇到什么一些一些错误
[02:33/09:21]     然后导致退出
[02:34/09:21]     这个时候需要如果不设置这个参数的话
[02:36/09:21]     需要我们手动的把容器再拉起来
[02:39/09:21]     而设计了这个参数之后
[02:41/09:21]     就能帮我们做一个这个事情
[02:42/09:21]     所以说这个参数也是蛮一个特权特殊的权限
[02:59/09:21]     模式啊
[03:09/09:21]     为了安全着想
[03:10/09:21]     他默认关闭了一些权限
[03:13/09:21]     它默认关闭了一些权限
[03:16/09:21]     那在Jack这里面我们把它打开
[03:17/09:21]     为什么要打开它呢
[03:18/09:21]     因为这里面我们要去介绍一种介绍一种这个容器的使用方式
[03:26/09:21]     就是docker out docker
[03:36/09:21]     外面的docker命令就是说什么呢
[03:38/09:21]     就比如说我们在杰S里面
[03:40/09:21]     我们是一个那什么嘛
[03:42/09:21]     我们是一个CI的一个工具
[03:44/09:21]     持续计升工具是JS是对吧
[03:47/09:21]     那么什么呢
[03:48/09:21]     那么啊
[03:49/09:21]     那么我们希望JS能调docker去启动一些容器
[03:54/09:21]     因为我们很多自动化的任务可能是在容器里面的
[04:05/09:21]     在后面的杠V这个参数里面
[04:18/09:21]     杠V这个参数里面
[04:21/09:21]     我们是什么呢
[04:22/09:21]     我们是把
[04:23/09:21]     专门把docker.sock这个文件映射到了
[04:28/09:21]     也就载到了我们容器里面的同样的目录里面去
[04:33/09:21]     为的就是什么呢
[04:34/09:21]     为的就是说我们这个
[04:45/09:21]     可能会有一些问题
[04:46/09:21]     就是没有相关的问题
[04:49/09:21]     第一特权杠
[05:01/09:21]     进行启动
[05:03/09:21]     使用户进行动
[05:06/09:21]     如不定的话
[05:07/09:21]     使用的认用户那的这个用户就是jes所以说你需要用root用户来去启动它
[05:17/09:21]     这个大家需要了解
[05:20/09:21]     就是我们之前都学过的内容了
[05:23/09:21]     杠杠EV其实就是杠e就是杠e指定环境
[05:27/09:21]     变量啊
[05:28/09:21]     你可以在这里面用杠e
[05:29/09:21]     也可以用杠杠in
[05:30/09:21]     为就它是指令环境变量的不同的方式而已
[05:33/09:21]     这里面我们jacks的指定一个Java OS啊
[05:36/09:21]     Java o啊
[05:38/09:21]     然后高我们做文件挂载
[05:41/09:21]     把JS的home这个挂载出来
[05:45/09:21]     然后在在这个我们刚才说到了
[05:47/09:21]     把docker的sock关联到容器的目录里面去
[05:51/09:21]     容器的某中领先
[05:52/09:21]     同时在这里边你也可以看到
[05:54/09:21]     我们也是把docker命令
[05:57/09:21]     你看b docker这个命令也挂到容器里面去了
[06:01/09:21]     挂载到容器里面去了
[06:02/09:21]     这样的话我们是可以在容器里面去调刀ER
[06:05/09:21]     在容器里面去调刀ER
[06:07/09:21]     那我们来看教服务器里面
[06:09/09:21]     那这个命令比较长
[06:10/09:21]     所以我事先写了一个脚本在这里面
[06:13/09:21]     事先就写了一个脚本在这里面
[06:16/09:21]     那我们运行一下这个脚本
[06:21/09:21]     Second
[06:25/09:21]     OK
[06:28/09:21]     我们查一下S是不是已经启动起来了
[06:35/09:21]     嗯
[06:40/09:21]     我们看一下日志
[06:42/09:21]     但是这启动的过程中有没有出现什么问题
[06:45/09:21]     这里报了个错误
[06:48/09:21]     这应该是插件
[06:49/09:21]     我之前安装的插件有一点问题
[07:04/09:21]     这应该是已经完成了
[07:09/09:21]     再去算
[07:13/09:21]     一功创建了很多job了
[07:25/09:21]     我是把这个数据进行持有化的
[07:27/09:21]     这个大家还记得吧
[07:28/09:21]     我们是有有杠V这个参数
[07:31/09:21]     是有杠V这个参数去把文件做一个持久化那所以理论上呢
[07:39/09:21]     如果我们再去访问
[07:41/09:21]     MYS
[08:58/09:21]     我们运行docker命令
[09:00/09:21]     你可以看到是可以运行的
[09:03/09:21]     虽然我们现在容器里面了
[09:05/09:21]     但我还可以运行docker这个命令
[09:07/09:21]     完全是因为我们已经通过文件挂载的方式
[09:11/09:21]     已经把docker命令给挂载出来了
[09:14/09:21]     把docker.sock和这个docker命令都已经挂载出来了
[09:19/09:21]     挂载出来之后呢
[09:21/09:21]     我们还开启了特权模式
[09:22/09:21]     使用root用户
[09:23/09:21]     那我们就可以
[09:25/09:21]     我面程一阶阶的用法
[09:45/09:21]     那那我们今天呢
[09:47/09:21]     也是通过这个jacks的这个实例来大家看一下这个使用方式
[09:52/09:21]     就是在容器里面去调用docker
[09:55/09:21]     这是很多之前很多同学都都会问到的一个内容
[10:00/09:21]     之前很多同学都会问到的一个内容后面在这个不知道大家会后面会不会参加那个持续集成课
[10:22/09:21]     持续集成课里呢
[10:23/09:21]     我也会给大家展示一下如何在JS里面与docker进行整合
[10:30/09:21]     那所以说到时候就会用这种方式去进行部署这的部署
[10:36/09:21]     那我们这节课就讲到这里



### 8、搭建项目管理平台 Jira
[00:00/09:06]     [以下字幕均由机器生成]那这一小节呢
[00:00/09:06]     [以下字幕均由机器生成]我们来看一下一行命令启动
[00:04/09:06]     又是我们的一行命令系列
[00:07/09:06]     我们用去启动一下
[00:09/09:06]     这个其实常简单
[00:11/09:06]     其实非常简单
[00:12/09:06]     这小里面
[00:14/09:06]     这小里们那并没有一些什么新的内容
[00:20/09:06]     我们使用这个东西呢
[00:23/09:06]     单纯的给大家看一下
[00:24/09:06]     如果要部署一个G的话
[00:26/09:06]     我们要怎么样去做怎么样去做
[00:30/09:06]     全给一
[00:51/09:06]     那我们看一下这个命令
[00:56/09:06]     是说要我们的
[01:02/09:06]     把我们的gra做一个文件的映射文件的映射
[01:08/09:06]     后面杠杠
[01:10/09:06]     这个给容器指定一个名称
[01:14/09:06]     杠D后台运行杠P端口映射
[01:17/09:06]     然后后面是我们的镜像的名称
[01:20/09:06]     我们镜像的名称我们可以把它复制一下
[01:24/09:06]     把它复制一下
[01:25/09:06]     然后
[01:28/09:06]     我先把之前的一个服务删除掉
[01:41/09:06]     不好意思
[01:42/09:06]     因为这个从PPT里面
[01:46/09:06]     复制过来的
[01:48/09:06]     它的这个字符集就会有一些问题
[01:51/09:06]     它的逗号还是中文的
[01:54/09:06]     OK
[01:55/09:06]     好
[02:00/09:06]     那么
[02:01/09:06]     在这里面我们刷新一下
[02:11/09:06]     口音说错了
[02:12/09:06]     而说我们的容器有
[02:16/09:06]     运行的错误我们看一下
[02:22/09:06]     原因是他没有启动起来
[02:26/09:06]     好
[02:28/09:06]     你看这里面是已经启动中
[02:31/09:06]     启动完毕
[02:32/09:06]     这里面跟大家要看一下几个注意的地方
[02:36/09:06]     用大号部署它比较简单
[02:39/09:06]     比较困难的是什么呢
[02:40/09:06]     是设置它这里面可能都是英文的
[02:43/09:06]     大家要看的不习惯的话
[02:44/09:06]     你可以在右角这边选language这边有这个应该是有中文的
[02:51/09:06]     然后保存
[02:53/09:06]     然后一般演示环境
[02:56/09:06]     我们把它设选择第二个
[02:58/09:06]     选择第二个就是不在互联网也是可以
[03:01/09:06]     没有接互联网也是可以行
[03:04/09:06]     点下一步
[03:05/09:06]     这里面要选择你是用内置的数据库还是用其他的数据库
[03:11/09:06]     内置数据库
[03:13/09:06]     就是说其实这个里面一个数据库
[03:17/09:06]     有一个数据库
[03:18/09:06]     当然你可以指定其他的数据库
[03:21/09:06]     这个大家可以试一下
[03:22/09:06]     我们之前讲买circleq的那个
[03:23/09:06]     你可以部署一个MYQL
[03:25/09:06]     然后在这边去连接一下去尝试
[03:27/09:06]     当然这里面我们可以写内使用内置的数据库
[03:31/09:06]     我们使用内容
[03:32/09:06]     然后点下一步
[03:34/09:06]     点下一步这会
[03:40/09:06]     大家耐心等待一下
[04:18/09:06]     嗯
[04:19/09:06]     这边设置完之后呢
[04:22/09:06]     可能可能这个
[04:30/09:06]     之准备一
[04:47/09:06]     这次等时间怎么这么长
[05:17/09:06]     好
[05:20/09:06]     那这里面其实我们设置开放
[05:23/09:06]     设置私有都是可以的
[05:25/09:06]     无所谓啊
[05:26/09:06]     我们点下一步
[05:27/09:06]     这时候就到了这儿了
[05:29/09:06]     我刚才说的这个是要需要什么
[05:31/09:06]     需要制定许可证
[05:34/09:06]     只能是用这个需要什么呢
[05:36/09:06]     需要需要你到G2这家公司的官方网站里面去进行注册
[05:42/09:06]     去进行注册
[05:44/09:06]     这里面有指引
[05:46/09:06]     在这里面有账户指引
[05:48/09:06]     你点击进来之后
[05:50/09:06]     是有指引的是有指引的
[05:53/09:06]     也可以点点这里这生成加试用去可证你可以生成试用的
[06:00/09:06]     适用的
[06:03/09:06]     到这边你可以随便写
[06:04/09:06]     然后点license就可以了当然我之前应该是
[06:12/09:06]     这呢
[06:13/09:06]     我之前生产过
[06:15/09:06]     生成过
[06:16/09:06]     在这里面我直接就写了
[06:17/09:06]     我就
[06:21/09:06]     你点之后呢
[06:23/09:06]     然后认证一下就可以了认证一下就可以了
[06:26/09:06]     然我们点下一步
[06:59/09:06]     大家再等一下
[07:00/09:06]     这个设置的时间是比较长
[07:14/09:06]     好
[07:16/09:06]     这这个就随便写了
[07:19/09:06]     这个就随便写了
[07:30/09:06]     还叫Frank
[07:36/09:06]     我们再点下一步
[07:42/09:06]     特点完成
[07:43/09:06]     因为它设置电子邮件通知嘛
[07:46/09:06]     这个我们就先不设置
[07:47/09:06]     因为我们毕竟是学习学习docker
[07:49/09:06]     不是在学习G2怎么用
[07:51/09:06]     其实用docker就的白设置了
[08:20/09:06]     好
[08:22/09:06]     选中文continue
[08:25/09:06]     然后选头像不用选
[08:27/09:06]     在这边你可以选择创建一个新的项目
[08:30/09:06]     然后点下一步这个随便了
[08:33/09:06]     因为我们就是看效果
[08:36/09:06]     就是看效果提交
[08:43/09:06]     那这个我们就输入成功了
[08:46/09:06]     看板都出来了
[08:48/09:06]     这个大家可以
[08:49/09:06]     这个我不详细讲Java的使用方式
[08:53/09:06]     主要给大家看一下
[08:54/09:06]     如果你用docker来去启动它的话
[08:56/09:06]     应该是一个什么样子
[08:57/09:06]     其实很简单其实很简单
[08:59/09:06]     那我们这节课就到这里



### 9、搭建测试用例管理平台 testlink
[00:00/07:59]     [以下字幕均由机器生成]那这一节这一节小课呢
[00:02/07:59]     [以下字幕均由机器生成]我们带大家
[00:05/07:59]     来看一下我们一行命令系列的最后一小节
[00:09/07:59]     怎么去启动t link
[00:10/07:59]     但是其实实际上
[00:12/07:59]     其实实际上那个这已经不算是一行命令了
[00:16/07:59]     它是两行命令
[00:17/07:59]     因为我们要启动的是两个容器了
[00:19/07:59]     就是说部署一个test需要两个容器来启动
[00:22/07:59]     为什么呢
[00:25/07:59]     T办保存的需要
[00:35/07:59]     还要部署一个
[00:39/07:59]     这里面主要需要为大家展示的是什么呢
[00:43/07:59]     需要展示的是两个容器之间如何通信的问题
[00:49/07:59]     因为我们现在我们虽然我们现在说
[00:54/07:59]     数据在哪里
[00:59/07:59]     因为我们之前讲过
[01:01/07:59]     容器在启动的时候
[01:04/07:59]     Docker生成的是一个随机的IP地址
[01:07/07:59]     而且这个IP地址是
[01:09/07:59]     虚拟的IP地址不进路由表的
[01:12/07:59]     你启动容器的时候是没有办法这个指定它的IP地址的
[01:18/07:59]     是没有办法IP地址的
[01:19/07:59]     那也就是说我的一个容器要去通往另一个器进行发送网请的话
[01:25/07:59]     你得知道一个容器IP址
[01:28/07:59]     那这个问题要怎么解决呢
[01:30/07:59]     这个问题要怎么解决呢
[01:31/07:59]     就是我们link容器要怎么知道
[01:36/07:59]     马瑞DB容器的相关的网络信息呢
[01:39/07:59]     这个关键就在什么呢
[01:40/07:59]     这个关键就是我们今天要讲的这个内容
[01:43/07:59]     它关键就是我们这个杠杠link参数
[01:46/07:59]     杠杠link个参数
[01:48/07:59]     这个只有这一个参数是我们这一课新最新要介绍的
[01:53/07:59]     其他的一些使用形式都是我们之前已经讲过了
[01:56/07:59]     包括你看我们这边启动MYDB的时候
[01:58/07:59]     用刚去指定环境变量
[02:00/07:59]     设置password
[02:01/07:59]     设置user
[02:03/07:59]     然后初始化的database database的名称
[02:07/07:59]     数有化database database的名称
[02:09/07:59]     然后把文件进行数据进行持有化
[02:12/07:59]     端口映射等等等等
[02:13/07:59]     这些都是我们之前讲过的了
[02:15/07:59]     已经不不再详细的讲
[02:17/07:59]     不再详细的讲
[02:18/07:59]     只是介绍一下你初始化数据库的时候
[02:20/07:59]     你需要指定这些环境变量去进行初始化才可以
[02:25/07:59]     才可以一
[02:47/07:59]     因为t link在尝试连接这个数据库
[02:48/07:59]     所以说你这个只要是一样的只要是一样
[02:52/07:59]     那关最关键的是什么呢
[02:53/07:59]     就是我们的杠杠link这个参数了
[02:56/07:59]     杠杠link参数是什么
[02:57/07:59]     你可以认为是什么
[03:00/07:59]     你可以认为一旦用杠杠link
[03:01/07:59]     然后后面跟着买DB
[03:03/07:59]     就是容器的名称
[03:04/07:59]     你可以看到我们启动买DB的时候
[03:06/07:59]     给它起了一个名字叫买DB
[03:08/07:59]     而我们杠杠link买DB就代表着什么呢
[03:10/07:59]     代表着把两个容器进行了链接
[03:13/07:59]     因为link就是链接的意思嘛
[03:16/07:59]     翻译成中文就是链接的意思嘛
[03:17/07:59]     这样他们两个可以进行通信
[03:20/07:59]     你暂时可以这么理解
[03:21/07:59]     暂时可以这么理解
[03:23/07:59]     那把他们两个
[03:26/07:59]     把他们两个启动起来以后
[03:29/07:59]     那我们的这个这个我已经事先启动好了
[03:32/07:59]     我们回车一下
[03:33/07:59]     您可以看到已经启动好了
[03:34/07:59]     我们test link可就已经部署好
[03:46/07:59]     这些都是可以的
[03:47/07:59]     这些都都是可以的
[03:51/07:59]     说化完之后
[03:52/07:59]     你可以看到这些右边的这些东西都已经出来了
[03:55/07:59]     但不是重点test link的介绍并不是重点
[03:59/07:59]     重点是说我们
[04:01/07:59]     是链接的意思嘛
[04:12/07:59]     它是把两个容器进行链接
[04:15/07:59]     这样他们俩就可以互相访问了
[04:16/07:59]     当然这是说给用户听的接下来我要讲一些原理
[04:20/07:59]     就是说为什么通过杠杠link这个参数
[04:25/07:59]     是可以
[04:26/07:59]     那什么可以把这个
[04:29/07:59]     两个容器进行通信的原是什么
[04:33/07:59]     其实它的原理简单也简单
[04:35/07:59]     当我们在启动link容器的时候使用杠DB时候
[04:43/07:59]     代表么DB络以环境变量的形式
[04:53/07:59]     以环境变量的形式
[04:57/07:59]     以环境变量的形式注入到我们的t link容器里面去
[05:04/07:59]     是
[05:15/07:59]     会用环境变量的形式注入到我们link容器了
[05:19/07:59]     你可以认为刚刚link它就是一个语法仓
[05:22/07:59]     就是个就是个简单
[05:44/07:59]     它的IP会变的
[05:44/07:59]     你每一次启动你都得去查一下
[05:46/07:59]     这很麻烦
[05:48/07:59]     而你用刚刚link之后
[05:49/07:59]     其实就没有这个问题
[05:51/07:59]     它会自动的帮你把这些网络信息注入到以环境变量的形式注入到这里面去
[05:57/07:59]     OK
[05:58/07:59]     这个大家明白吗
[06:00/07:59]     这个大家应该明白
[06:01/07:59]     其实如果说你你们到门到test link这个容器里面
[06:05/07:59]     我看看我能不能登进去
[06:07/07:59]     用docker exec杠it test link
[06:14/07:59]     然后用env
[06:16/07:59]     我们查看一下MYDB相关
[06:19/07:59]     你可以看到DB
[06:22/07:59]     相关的信息都都在这里了
[06:26/07:59]     都在这里
[06:30/07:59]     我们再看一下整体的
[06:34/07:59]     整体的
[06:36/07:59]     我们刚才搜是买DB呢
[06:39/07:59]     但是我要搜my circlel嘛
[06:41/07:59]     因为毕竟其实大家都知道买RDB和MYSQL是一家
[06:44/07:59]     所以说虽然它叫买RDB
[06:45/07:59]     但其实有很多的
[06:47/07:59]     内部的一些名称都叫买
[06:53/07:59]     他区分大小写的
[06:56/07:59]     白色狗
[07:02/07:59]     或者说我用DB再搜一下
[07:07/07:59]     这里就全了
[07:09/07:59]     你可以看到mar DB Mr DB的IP address是这个IP地址
[07:14/07:59]     然后它的端口号端口这TCP port端口号3306都是在这里
[07:21/07:59]     刚才搜图信息比较少
[07:22/07:59]     是用一个小写的
[07:23/07:59]     它这里边是搜索时候区分大小写
[07:25/07:59]     我把这个忘了换成大写的
[07:27/07:59]     你把这些信息都就都已经能显查询到了
[07:32/07:59]     所以这也证了我们之前讲的刚link之后
[07:35/07:59]     它是以的量RDB容器一注
[07:41/07:59]     好
[07:43/07:59]     那就是这节课的内容



### 10、部署分布式 UI 自动化测试环境
[00:00/15:05]     [以下字幕均由机器生成]这一小节呢
[00:01/15:05]     [以下字幕均由机器生成]来看一下
[00:02/15:05]     如用来UI动一个测试
[00:06/15:05]     不知道大家有没之前有没有从这个UI自动化的课程中学习到这个相关的内容
[00:14/15:05]     因为我们在做UI自动化的时候呢
[00:16/15:05]     其实跟在在公司里面做这种企业级的us的化
[00:21/15:05]     和我们在自己学习的时候写DEMO是完全不一样的
[00:26/15:05]     最主要的区别是测试用的B动化放到企业级产品里的时候就会完全的不一样
[00:42/15:05]     因为我们的企业的产品
[00:43/15:05]     它的业务逻辑会比较复杂
[00:46/15:05]     如果他要做UI自动化的话
[00:48/15:05]     其实它的测试用力的规模会比较庞大
[00:51/15:05]     To的的两三千左右两三千条u自动化测试用率这样的一个规模左右那
[01:07/15:05]     在面对这样的一种测试的用力的规模的时候
[01:12/15:05]     很显然你再向在学习的时候
[01:15/15:05]     在本地跑us自动化
[01:16/15:05]     那肯定是不行的
[01:18/15:05]     我们起码得放到一台服务器上去运行
[01:20/15:05]     而且放到一台服务器上也也不太行的
[01:23/15:05]     因为单机的这个运行总会有性能平静的
[01:28/15:05]     虽然说我们不管是用Python的这种P框架
[01:33/15:05]     又或者是说Java的g unit或者TNG这样的框架
[01:37/15:05]     它可能都有并发执行的这么一个
[01:40/15:05]     并发执行的这么一个机制在
[01:54/15:05]     尤其浏览器是非常消耗CPU资源的这么一个软件
[01:59/15:05]     所以说呢
[02:00/15:05]     我们需要把我们的浏览器分布在不同的机器上去执行测试用例
[02:07/15:05]     才能够满足我们日益增长的测试用例的规模的这个需求
[02:12/15:05]     而针对于这样的一个背景呢
[02:14/15:05]     其实slina团队他们官方推出了这样的一种分布式UI自动化的解决方案
[02:19/15:05]     叫做grade
[02:20/15:05]     我在网上也给大家搜了这么一个图家以边这个图其实简简单
[02:28/15:05]     我请求
[02:33/15:05]     这些机器上
[02:54/15:05]     是在远程的这些机器上的
[02:55/15:05]     它非常适合作为我们这种并发的浏览器的测试的解决方案
[03:01/15:05]     也比较适合做什么
[03:02/15:05]     做这个兼容性测试
[03:04/15:05]     浏览器的兼容性测试也比较适合使用这种方案
[03:09/15:05]     可以把自动化UI的自动化测试用例
[03:14/15:05]     放到不同的浏览器上去跑放到不同的浏览器上去跑
[03:19/15:05]     这个我不不再详细的叙述了
[03:21/15:05]     为个竟是讲部署它
[03:29/15:05]     关于这部分内容呢
[03:32/15:05]     你们可以去咨询一下UI自动化老师
[03:34/15:05]     所以说我我在这里不详细不详细的去讲解
[03:37/15:05]     大家就说知道现在目前来说
[03:39/15:05]     我们是需要是需要使用这种方案去为我们的UI自动化提速的
[03:45/15:05]     如果用单单浏览器跑几千条case的话
[03:49/15:05]     那得跑到猴年马月对吧
[03:51/15:05]     所以说
[03:53/15:05]     部署这一套东西呢
[03:54/15:05]     以前还是挺挺费劲的
[03:56/15:05]     你需要安装好多台机器
[03:58/15:05]     然后每台机器上你都要装GDK
[04:00/15:05]     然后装这些包
[04:02/15:05]     然后你果里的话
[04:13/15:05]     你会发现它会更轻松
[04:15/15:05]     这个我我们再讲K8S
[04:17/15:05]     我再给大家演示
[04:18/15:05]     那我们先说一下如何用docker去部署这一套东西其实这套东西大家从这个里以到是两种
[04:28/15:05]     一种可以是的点实际上
[04:44/15:05]     Node节点
[04:45/15:05]     Node节点是真正注册浏览器的地方
[04:47/15:05]     Node节点在启动之后呢
[04:49/15:05]     它会向他会把自己的信息注册到主节点上
[04:52/15:05]     这样的话呢
[04:53/15:05]     用户发来的测试请求才可以通过主点转发到这些noe节点上
[04:58/15:05]     所以说实际上我们要启动两个容器
[05:01/15:05]     我们要启动两个容器这里面
[05:04/15:05]     不好意思
[05:06/15:05]     其中两个容器在这里面
[05:08/15:05]     首先第一个就是我们的容器
[05:10/15:05]     第一个就是我们容器
[05:13/15:05]     大家可以看这条命令
[05:14/15:05]     这条命令里面其实还是比较简单的
[05:18/15:05]     比较简单的都是我们之前讲过的内容
[05:21/15:05]     这些参数
[05:22/15:05]     只不过这里需要注意的是什么
[05:23/15:05]     这里边算是一个语法堂
[05:25/15:05]     因为什么呢
[05:26/15:05]     因
[05:37/15:05]     其中四四端口是外部服务
[05:38/15:05]     4442和4443呢
[05:40/15:05]     都是那什么都是这个用来做通信的
[05:44/15:05]     就是noe几点
[05:53/15:05]     那你不想三个端口
[05:54/15:05]     不想写三个杠P露的话
[05:56/15:05]     那你们就可以用一个横杠代表着你一下要露三个口号连续的三个端口号暴露出来
[06:06/15:05]     那我们把它启动起来
[06:12/15:05]     就是我们的这个部署为了回撤
[06:16/15:05]     当启动完之后
[06:17/15:05]     我们需要访问5444端口
[06:20/15:05]     因为我们映射出来的是5444端口
[06:23/15:05]     大家还记得端口映射对吧
[06:25/15:05]     五这个因为544端口映射的就是容器的4444端口
[06:29/15:05]     刚才我说过4444就是它的web服务
[06:33/15:05]     所以说这边你要
[06:35/15:05]     用5444
[06:39/15:05]     这里边你可以看到这里边great图形界面就是这样
[06:44/15:05]     因为上面还没有注册任何一台点
[06:46/15:05]     所以说告诉你great has no
[06:53/15:05]     Note了
[06:55/15:05]     就是浏览器的节点
[06:56/15:05]     注册浏览器的节点
[06:57/15:05]     这里面需要大家注意一些东西
[06:59/15:05]     这里面我在PPT里面也给大家看了
[07:01/15:05]     给家看了你看这里面
[07:03/15:05]     的图形界面的
[07:16/15:05]     览器界面
[07:25/15:05]     当然也是有的
[07:26/15:05]     就是因为我们这个镜像里面部署了一个就是docker官方公布的这个no镜像里面署了一个VVNC的server v nc其实就是雷nux的图形界面服务
[07:37/15:05]     远程桌面访问服务
[07:39/15:05]     它暴露一个这东西
[07:40/15:05]     所以说我们是可以通过这个端口号去访问这个远程桌面的
[07:46/15:05]     这样我们可以看到浏览器实际的运行效果
[07:49/15:05]     这个也在测试中
[07:50/15:05]     也是非常有常用的
[07:51/15:05]     然后后面我们开始设置环境变量的第一个是
[07:59/15:05]     当前的
[08:17/15:05]     你不能限制限上限
[08:27/15:05]     然后后面还有一个比较重要的参数是这个这两个
[08:30/15:05]     这两个参数分别对应着你刚才暴露的这个5442和5443
[08:34/15:05]     大家可以看到这两个
[08:37/15:05]     这两个端口号是用来给no的节点和节点去进行通信的
[08:44/15:05]     去进行通信的
[08:45/15:05]     然后其他的就没有什么特别的其他的就没有什么特别的
[08:49/15:05]     至于这个文件挂载是为了优化内存用的
[08:51/15:05]     这个大家可以不用在意可以不用在意
[08:55/15:05]     那我们把它也启动起来
[09:00/15:05]     把它启动起来
[09:01/15:05]     把它启动了之后呢
[09:03/15:05]     我们回到这个一个图形界面上
[09:05/15:05]     我们刷新它
[09:07/15:05]     他应该过一会应该会看就注册出来了朱
[09:12/15:05]     这里有个20的标志
[09:14/15:05]     代表注册了20个浏览器
[09:15/15:05]     跟我们刚才这个参数是一
[09:21/15:05]     代表你的最高的发也是二十全是
[09:28/15:05]     这全是我们在这里
[09:31/15:05]     我们在这里
[09:33/15:05]     这设置的这个参数
[09:35/15:05]     就是
[09:53/15:05]     他就是像我们刚才说的
[09:54/15:05]     就说露了e了一个去露的远程桌面服务对吧
[10:02/15:05]     我们可以下载一个叫做VC的这么一个客户端
[10:08/15:05]     远程桌面访问服的客户端
[10:09/15:05]     然后在这里面呢
[10:11/15:05]     我们去编写什么呢
[10:13/15:05]     在这里面我们去编写我们启动note的时候的这台机器的IP地址和它的暴露出来的动括号
[10:21/15:05]     然后我把它双击启动
[10:25/15:05]     连接上之后呢
[10:26/15:05]     它会要求你输入一个密码
[10:27/15:05]     密码默认就是secret
[10:45/15:05]     再一步步在PPT里写
[10:46/15:05]     然后我们就通过一段代码去访问
[10:50/15:05]     一段代码去访问
[10:51/15:05]     这是我们的示例的代码
[10:55/15:05]     这是我们的示例代码
[10:57/15:05]     这是我用Python去写的
[10:59/15:05]     在这段代码里
[11:00/15:05]     大家需要注意一个东西
[11:02/15:05]     首先第一点呢
[11:03/15:05]     我使用的是什么呢
[11:05/15:05]     我使用的一个
[11:10/15:05]     使用的包叫
[11:13/15:05]     叫sliing
[11:14/15:05]     这是Python的一个UI自动化的测试框架
[11:19/15:05]     也是根据sli衍生而来的
[11:22/15:05]     衍生来这个测试框架比较好用
[11:24/15:05]     我就用它了
[11:41/15:05]     然后
[11:45/15:05]     Base u l就是你的测试的测试的地址
[11:47/15:05]     这个我就起
[11:48/15:05]     就以我们的这个图形界面为例
[11:53/15:05]     我在这写这样一地址
[11:54/15:05]     然后它的控件的超时时间访问
[11:57/15:05]     这一个控件的搜索
[11:58/15:05]     控件的超时时间是否截图等等等等一些配置都可以通过类
[12:06/15:05]     去进行设置后面remoteb
[12:11/15:05]     Option web driver chome options就是要设置我们的什么呢
[12:16/15:05]     可以设置我们的这个整个谷歌浏览器的一个option
[12:22/15:05]     包括在里边设置上的下载目录等等等等这些东西
[12:26/15:05]     这些可以不用在意
[12:27/15:05]     可以不用在意
[12:29/15:05]     这个都是我我为了告诉你们怎么去设置浏览器的一些属性而而在这边写的
[12:36/15:05]     关键在哪呢
[12:37/15:05]     关键在于这conflict driver这边你要用一个slim web driver remote remote web我们现在用的是我们驱动本地浏览器
[12:47/15:05]     用的就是普通的web
[12:49/15:05]     但是呢
[12:50/15:05]     如果我们要驱动这种远程的浏览器
[12:53/15:05]     这边要用remote web
[12:54/15:05]     然后command
[13:00/15:05]     打开了greatb的地址
[13:02/15:05]     只不过我这边写IP地址
[13:04/15:05]     这边用的是域名
[13:05/15:05]     但是都是可以的
[13:09/15:05]     都是可以的
[13:11/15:05]     那
[13:14/15:05]     当你这些东西都设置好之后
[13:16/15:05]     然后brother.open就可以打开浏览器打开浏览器
[13:20/15:05]     那我的这边也是准备了这个实验代码
[13:22/15:05]     我们可以试验一下
[13:24/15:05]     我在这边打一个断点
[13:27/15:05]     然后用第八个模式运行
[13:31/15:05]     用第八个模式运行
[13:33/15:05]     我们来观察这
[13:34/15:05]     看看远程浏览器会不会启动起来
[13:41/15:05]     大家应该刚才已经一闪而过
[13:43/15:05]     那大家刚才已经看到了
[13:45/15:05]     这已经访问到了我们的浏览器了
[13:48/15:05]     系统浏览器也访问到了我们的室内环境里面
[13:51/15:05]     那说明我们这个DEMO已经成功
[13:55/15:05]     是测试
[14:07/15:05]     是
[14:26/15:05]     连接这里就行
[14:27/15:05]     你可以把这一套东西就当成一个浏览器的机群一个资源至至于就是他不会管并发控制的
[14:34/15:05]     他只管过了一个请求就分
[14:41/15:05]     比如说你用PI test
[14:42/15:05]     那你就去下载那个test charest去做多线程测试去
[14:47/15:05]     如果你用的是T级T机
[14:49/15:05]     自己这边就有那个并法测试的那个机制
[14:52/15:05]     你连插件也不用下
[14:55/15:05]     这是我们这一节课的内容



## 68、docker 容器技术-II



### 1、Docker 与虚拟机解析
[00:00/09:02]     我们来看一下容器和虚拟汁机机之间的区别
[00:04/09:02]     在之前的课程里面呢
[00:05/09:02]     我曾经跟大家说过
[00:07/09:02]     可以暂时把容器当成虚拟机来看
[00:11/09:02]     因为他们都是他们都是虚拟化领域中的方案
[00:15/09:02]     他们的使用的一些技术是不一样的
[00:20/09:02]     他们全都是一种虚拟化的一个方案
[00:24/09:02]     所以说
[00:25/09:02]     他们在很多场景里面其实是一样的
[00:29/09:02]     所以说对于这个容器还不了解的同学呢
[00:32/09:02]     就把容器当成一个小型的虚拟机来看
[00:35/09:02]     也是没有什么问题的
[00:37/09:02]     因为这样的话比较方便大家理解
[00:39/09:02]     学习一些命令什么的因为不知道容器是什么东西的
[00:45/09:02]     或者说对容器这个东西没有什么一些形象
[00:47/09:02]     有比较形象的概念的时候
[00:49/09:02]     我们去学习呢
[00:50/09:02]     可能会比较理解的不清晰
[00:54/09:02]     所以说呢
[00:56/09:02]     在之前我建议大家把容器当成虚拟机来看是没有什么问题的
[01:01/09:02]     只不过在这节课里面呢
[01:03/09:02]     我们就来详细的讲解一下
[01:05/09:02]     容器和虚拟机之间的区别到底是什么首先我们先从架构上来看
[01:13/09:02]     我们从架构上来
[01:25/09:02]     你可以看到左边的这个图里面呢
[01:28/09:02]     就比右边这个图高出了一块
[01:30/09:02]     它多出了一块
[01:31/09:02]     多出一块绳呢
[01:34/09:02]     让我们来仔细看一下serve操一个软件
[01:46/09:02]     这个软件是虚拟机的管理软件
[01:50/09:02]     虚的管理软件之上呢
[01:52/09:02]     是每一个虚拟机可以看到每个虚太一样的是什么呢
[02:07/09:02]     虽然它同样有server和server的OS
[02:09/09:02]     然后它这边启动的是一个docker engine
[02:13/09:02]     作为容器管理软件
[02:14/09:02]     但是在它之上虚拟化的方案
[02:16/09:02]     你会发现它虚拟化出的东西
[02:19/09:02]     它都是没有内核的
[02:23/09:02]     它是没有内核的
[02:24/09:02]     直接是软件
[02:25/09:02]     它并没有虚拟化内核
[02:26/09:02]     这个是docker和虚拟机最大的区别
[02:31/09:02]     Docker和虚拟机最大的别虚拟
[02:33/09:02]     虚拟出来的方是有是独整操作系统
[02:37/09:02]     而是虚拟软件
[02:41/09:02]     没有虚拟操作系统
[02:43/09:02]     那这时候可能会有同学会问
[02:45/09:02]     就没有虚拟化内核的话
[02:46/09:02]     那软件用什么呢
[02:48/09:02]     因为我们都知道一个软件运行必须有内核
[02:50/09:02]     对吧
[02:51/09:02]     一个操作系统的前提就装对
[03:01/09:02]     用的就是我们宿主机的内核
[03:06/09:02]     也就是说啊
[03:07/09:02]     也就是说docker并没有隔离内核
[03:12/09:02]     并没有隔离内核
[03:13/09:02]     隔离这个词呢
[03:15/09:02]     也是虚拟化方案里面
[03:17/09:02]     虚拟化领域里面非常常见的一个词
[03:19/09:02]     因为虚拟化就是最主要的就是要隔离
[03:21/09:02]     对吧
[03:22/09:02]     你在虚拟机a里面不能看到虚拟B里的东西
[03:25/09:02]     就比如说虚拟机a里面这个你启动了一个进程
[03:29/09:02]     那你在虚拟机B里面是不能看到它的
[03:33/09:02]     们两一定是隔的
[03:35/09:02]     一定是隔的
[03:36/09:02]     而而个方案看到隔
[03:42/09:02]     它是没有隔离内核
[03:43/09:02]     他们使用他们他们是使用同一个内核
[03:45/09:02]     所以说有导致一个什么情况呢
[03:48/09:02]     导致就是说如果doer启动以后
[03:51/09:02]     就是说我们假如说在这台机器里面启动了十个容器
[03:54/09:02]     你在其中一个容器里面把内核搞挂了
[03:58/09:02]     那么就相当于你整个机器就都挂了
[04:00/09:02]     包括四五会挂
[04:01/09:02]     然后你的这个上面所有的容器也会挂
[04:06/09:02]     这在虚拟机中是不会出现的
[04:08/09:02]     因为虚拟机里面是有独立内核的
[04:10/09:02]     你把虚拟机a里的内核搞挂了
[04:12/09:02]     其实虚拟机B也好
[04:13/09:02]     它整个的这个部署虚拟机的服务器是不会受到影响
[04:18/09:02]     这是们有内核
[04:21/09:02]     内核之间的区别
[04:22/09:02]     这也是为什么为什么就是在时候
[04:27/09:02]     有一定的默认
[04:28/09:02]     会有一定的权限限制
[04:30/09:02]     就像我们之前讲那个讲部署S的时候一样
[04:35/09:02]     模是
[04:52/09:02]     把这东西搞了
[04:53/09:02]     包括你在启动的容器里面
[04:56/09:02]     你输入一些类似IP tables这样的命
[05:00/09:02]     你也是也是没有这个权限的
[05:02/09:02]     因为IP tables
[05:10/09:02]     把整个机器都给搞挂了
[05:13/09:02]     所以说他也不会什么呢
[05:15/09:02]     他也默认不会给你操作IP tables这个权限的这个原因就是因为这个它不隔离内核
[05:23/09:02]     你是有可能在一个容器里面
[05:25/09:02]     把所有的这个容器
[05:26/09:02]     包括四五级的网络都给我搞挂的
[05:30/09:02]     这出了入混
[05:40/09:02]     那么
[05:43/09:02]     那么在里面
[05:48/09:02]     你没有相关的权限去操作网络这些东西去注入网络权
[05:52/09:02]     网络这种故障
[05:53/09:02]     那你要怎么办呢
[05:55/09:02]     这个我们在后续的课程里面讲到name的时候会详细讲解
[05:59/09:02]     会详细讲解这里面我们先留下这么一个问题
[06:04/09:02]     大家也可以思考一下
[06:06/09:02]     在容器里面没有相关的这种权限的这种情况下
[06:10/09:02]     你要怎么注入这种
[06:12/09:02]     网络的故障去进行这种故障测试
[06:15/09:02]     大家可以思考一下
[06:16/09:02]     那么回到我们的这个架构区别上来看那
[06:19/09:02]     为什么会这样呢
[06:23/09:02]     什么呢
[06:25/09:02]     核追求是追求
[06:28/09:02]     是方案
[06:30/09:02]     我们在网络上应该已经见过有人形容刀cker
[06:33/09:02]     说刀cker的容器是秒级启动
[06:35/09:02]     它非常的快
[06:36/09:02]     非常的轻
[06:38/09:02]     占用资源非常小
[06:39/09:02]     它是秒级启动
[06:40/09:02]     它为什么呢
[06:41/09:02]     能这么快呢
[06:42/09:02]     就是因为它没内核嘛
[06:44/09:02]     所以说它的区别就是它跟虚拟机的这个区别
[06:47/09:02]     就相当于什么呢
[06:48/09:02]     虚拟机就相当于你要假如说你要打开QQ这个软件的话
[06:52/09:02]     就是如果你用虚拟机这个方案的话
[06:55/09:02]     相当于你要先把整个机器启动一遍
[06:58/09:02]     然后在图形界面上双击QQ这个图标
[07:02/09:02]     然后再等待QQ启动起来
[07:05/09:02]     内核的话
[07:25/09:02]     就它启动也会很快的
[07:27/09:02]     它启动也会很快的
[07:29/09:02]     比如说最近其实
[07:30/09:02]     其实是那个有一些业界是有一些很轻量级的这种虚拟的
[07:36/09:02]     比如a出了一虚拟
[07:39/09:02]     就它是里面极简的就常精简的核的虚拟启
[07:47/09:02]     但是快
[07:55/09:02]     就不可能比容快
[08:01/09:02]     选择了这种方案
[08:04/09:02]     就带来的这种非常小的资源的开销
[08:06/09:02]     以及非常快的启动速度
[08:10/09:02]     是核的
[08:16/09:02]     就是直接把那核弄挂了
[08:21/09:02]     也不会有这种情况
[08:22/09:02]     所以说他选择这种方案呢
[08:24/09:02]     会让用户在大部分的场景里面都能获得更快和更快的体验和更小的资源开销
[08:34/09:02]     这是容器和虚拟值之间的区架构上的一个区别
[08:39/09:02]     当是它还有一些使这些架构的上的区别
[08:42/09:02]     就导致于它会有一些使用场景的区别
[08:44/09:02]     那么下一个里面就会讲它使用场景的一个区别
[08:49/09:02]     就是说什么情况下使用什么情况下使用虚拟机这这一节呢
[08:55/09:02]     我们就先讲到这里



### 2、Docker 和虚拟机的使用场景
[00:00/11:48]     [以下字幕均由机器生成]那我这节课来我们来继续讲一下容器和虚拟之之间的一个差差别就是它使用场景的一个差别使用场景的一个差别
[00:11/11:48]     在上一个小节的时候
[00:13/11:48]     我们其实已经讲了容器和虚拟机的一个架构差别
[00:16/11:48]     就是这种图
[00:18/11:48]     就是这张图
[00:19/11:48]     我虚拟
[00:39/11:48]     虚拟化内核的前提下进行的
[00:43/11:48]     前提下因家可能会有隔离核核核那器之的呢
[00:52/11:48]     那所以说正因为虚和容器之间这样的一个区别
[00:56/11:48]     所以导致于后面他们的隔离方案是完全不一样的
[01:01/11:48]     是完全不一样的
[01:02/11:48]     虚拟有操作系统是没的
[01:05/11:48]     那么需要个的所有容器共享一个内的前提下要去
[01:11/11:48]     要去搞各种各样的隔离机制
[01:13/11:48]     那后面我们就会讲到name space啊
[01:17/11:48]     C groups这种在同一个Li下去进行隔离的资源
[01:20/11:48]     进行资源隔离
[01:21/11:48]     网络隔离相关的一些东西
[01:24/11:48]     相关的一些东西的时候呢
[01:25/11:48]     其实
[01:27/11:48]     其实到那个时候我们会就会知道为什么会是这个样子
[01:34/11:48]     大家是要跟大家强调
[01:36/11:48]     就大家一定要弄
[01:37/11:48]     一定要记清楚
[01:39/11:48]     所有虚拟机和内核之间的差别的起点
[01:43/11:48]     虚拟机和内核不是虚拟机和容器的差别的
[01:47/11:48]     无论是架构的差别还是使用的差别的起点就是在于容器不虚拟化
[01:53/11:48]     内核就是它不不虚拟化
[01:55/11:48]     单独的那独立的内核而已开始的
[01:57/11:48]     后面所有的方案的这个不同都是从这开始的
[02:01/11:48]     都是从这开始大
[02:04/11:48]     然后
[02:07/11:48]     什么场是不可用容器需使的讨
[02:24/11:48]     首先啊
[02:25/11:48]     大家应该能想到就是从景虚窄一为虚拟机有独立的内核
[02:35/11:48]     所以说它能够覆盖的使用场景肯定会更多
[02:40/11:48]     这个是一定的对吧
[02:42/11:48]     这个是一定的情况
[02:47/11:48]     都不太适合去
[03:01/11:48]     使用容器
[03:03/11:48]     比如说什么呢
[03:04/11:48]     比如说在测试领域
[03:05/11:48]     我以测试领域领域为主在测试领域里面最常见的是什么呢
[03:10/11:48]     常见的就是
[03:12/11:48]     做测试的时候
[03:16/11:48]     不知道大家有多少人是在to里面的你的件to to软件有一个特点是什么
[03:24/11:48]     大部分的to
[03:54/11:48]     你软的一个一个测试的类型
[04:04/11:48]     就叫做部署测试
[04:07/11:48]     叫做部署测试
[04:08/11:48]     因为因为什么呢
[04:09/11:48]     因为它跟互联网完全不一样
[04:11/11:48]     因为互联网完全机器都是受你操控的
[04:14/11:48]     所以说用什么样的操作系统
[04:16/11:48]     用什么内核本
[04:18/11:48]     用什么样的资源
[04:20/11:48]     置什么的硬等什么系等等
[04:26/11:48]     都是受你掌控的而且呢
[04:28/11:48]     就是说如果出现了任何部属性的问题
[04:31/11:48]     你的运维人员可以直接就干预去去进的可能使用red hat的
[04:47/11:48]     可能使用这个FY的
[04:49/11:48]     有可能使用这个u版图的
[04:51/11:48]     有可能用可能u版都少
[04:53/11:48]     可能多一些
[04:55/11:48]     像是一些可能一些金融领域呢
[04:59/11:48]     可能会买一些商商用的那种操作系统
[05:01/11:48]     比如说直接买IBM的提供的服务
[05:05/11:48]     或者买redd提供的服务
[05:06/11:48]     或者直接用SUC11这种就是这种商用的这种这种操作系统
[05:13/11:48]     那所以说呢
[05:15/11:48]     很多时候呢
[05:16/11:48]     你必须要验证自己的软件能够自己的系统能够部署在不同的操作系统里面去
[05:25/11:48]     因为有些时候它的这个你的软件里边
[05:28/11:48]     因为你的系统比较复杂嘛
[05:30/11:48]     你可能安装在一个系一个操作系统
[05:32/11:48]     那可能另一个操作系统就会出问题
[05:34/11:48]     所以说我们要做这样的一个部署测试
[05:36/11:48]     那么问题来了
[05:38/11:48]     如果我们用做部测试
[05:40/11:48]     我们可以说
[05:41/11:48]     假如说我们下载一个名字叫6.5的镜像
[05:45/11:48]     再下载一个S7.2像
[05:48/11:48]     或者后面再下一个的一个镜像
[05:50/11:48]     然后把它们启动成容器
[05:52/11:48]     然后在容器里边对我们的这个系统安部安装部虽你下
[06:17/11:48]     大家知道吧
[06:26/11:48]     而已
[06:35/11:48]     它并没有里面并没有六.s6.5所官方的那个6.5这个操作系统版本所配的官方的那个内核
[06:46/11:48]     形动
[06:57/11:48]     你启动一个容器
[06:58/11:48]     或者是在容器里面启动一个进程
[07:00/11:48]     都是跟在四五机上直接启动一个进程是一样的
[07:04/11:48]     只不过docker用了一各种各样的一些手段
[07:07/11:48]     各种手段去欺骗用户的眼睛
[07:11/11:48]     让他以为他是在一个独立的操作系统上去运行
[07:15/11:48]     那其实不是的其实不是的
[07:17/11:48]     之前有的同学也会问
[07:19/11:48]     就是说我在这个叫S点五的镜镜像的这个启动的容器里面
[07:24/11:48]     我使用的命令
[07:25/11:48]     都是6.5的他他以为他认为他就是在一个点五的操作系统里面去操作
[07:32/11:48]     是装同我
[07:40/11:48]     我用的是M这个命令来安装软件的
[07:42/11:48]     这个是在乌班图里没有的
[07:44/11:48]     乌班图和这系列的这个就是系的操作系统里面他用的那个
[07:50/11:48]     他的用的那个软件管理命令不都是AP嘛
[07:53/11:48]     A apd install这这种这种这种命令
[07:57/11:48]     但是他说他在这个容器里面用的是MM是标
[08:12/11:48]     是也是可以的
[08:24/11:48]     都是可以的
[08:25/11:48]     只不过是什么呢
[08:26/11:48]     只不过S的这个官方的操作系统
[08:29/11:48]     它默认只安装了而已大家一事情什么是什么是是你得到
[08:43/11:48]     不是内核
[08:44/11:48]     内核是你没有办法直接操作的
[08:48/11:48]     没有办法直接操作
[08:49/11:48]     直接接触的
[08:50/11:48]     只能通过软接核打交
[08:57/11:48]     所以之同学一个误界
[09:10/11:48]     令它也是软件
[09:16/11:48]     就凡是你能看得见摸得着的东西都是软件
[09:20/11:48]     都是软件
[09:21/11:48]     所以说所以说在这种做部署测试的这种场景下
[09:25/11:48]     消停消停的用虚拟机
[09:29/11:48]     肖像用虚拟机
[09:30/11:48]     因为容器是不行的
[09:33/11:48]     它没有办法虚拟化内核的
[09:35/11:48]     你消停了用虚拟机
[09:37/11:48]     当然可能会有同学问
[09:39/11:48]     有同学问这个
[09:42/11:48]     为么
[09:51/11:48]     的本是什么
[10:12/11:48]     你当然乎
[10:16/11:48]     核
[10:18/11:48]     部分核核不代的核核
[10:34/11:48]     所以说我们安装软件的时候根本就不关心我
[10:38/11:48]     一般来说
[10:39/11:48]     我们根本就不关心我用系统的版本是什么
[10:42/11:48]     对吧
[10:43/11:48]     我相信大家在自己在做这个测试的时候
[10:46/11:48]     或者说自己在做环境的这个部署的时候
[10:49/11:48]     从基本上不太关心
[10:51/11:48]     我的那个版本是什么
[10:53/11:48]     除非是在测试里面
[10:54/11:48]     他基不太
[10:56/11:48]     对吧
[10:58/11:48]     这核带你更快
[11:06/11:48]     而且源使用更少
[11:11/11:48]     这
[11:25/11:48]     会在后面带来非常大的这个便利性和灵活性
[11:32/11:48]     OK
[11:33/11:48]     讲到了是不
[11:43/11:48]     这节课我们就先到这儿



### 3、Docker 与容器网络
[00:01/19:54]     [以下字幕均由机器生成]大家好
[00:03/19:54]     [以下字幕均由机器生成]从这一节课开始呢
[00:05/19:54]     我们开始介绍一下docker的一些进阶相关的内容了
[00:09/19:54]     已经算是就是它的网络模式
[00:12/19:54]     因为docker的网络模式呢
[00:14/19:54]     在我们整个容器的这个学习路线当中
[00:16/19:54]     是非常重要的一个节点
[00:21/19:54]     因为它可以设置不同的网络模式呢
[00:23/19:54]     去去这个完成各种各样不同的场景
[00:26/19:54]     尤其是说我们在后续接触K8S的时候
[00:31/19:54]     就是这个KS是全民CU
[00:34/19:54]     是目前容器集群的一个事实标准
[00:40/19:54]     就是说全世界基本上所有的公司呢
[00:42/19:54]     都是在用KS来去构建自己的容器机群的
[00:45/19:54]     而在KBS当中
[00:47/19:54]     它的很多的网络方案
[00:49/19:54]     其实就是根据我们当前要学的这个docker的网络模式所扩展出来的
[00:55/19:54]     所以说今天要讲的几种网络模式呢
[00:57/19:54]     其实在我们后续都会用得到
[01:02/19:54]     在K当中都会到
[01:03/19:54]     所以说也是比重要
[01:04/19:54]     而它背后的原理也重要
[01:07/19:54]     那我们在后面讲解name呢
[01:12/19:54]     会再去详细的讲解一下
[01:15/19:54]     就是网络模式背后的原理
[01:16/19:54]     那今天我们先介绍一下网络模式
[01:19/19:54]     这这几种网络模式都用来做什么的
[01:21/19:54]     以及怎么去设置他们
[01:23/19:54]     好
[01:24/19:54]     首先我们要看的第一个模式
[01:28/19:54]     其实就是网桥模式
[01:29/19:54]     也叫桥接模式
[01:31/19:54]     因为它是有一个bridge
[01:34/19:54]     Links的网桥来去构建它的本地的容器网络的一个o网络
[01:40/19:54]     大家可以看这个图
[01:42/19:54]     可以是在看这个图
[01:44/19:54]     然在我们的这个副主机上可以看到有一个E0
[01:48/19:54]     就是以太网的网卡头
[01:50/19:54]     什么是以网
[01:51/19:54]     以网的网卡以网的网卡
[01:54/19:54]     它与一个网桥连接
[01:57/19:54]     大家可以看到这个叫DOCKER0的网桥
[02:03/19:54]     这个刀CKER0的网桥
[02:04/19:54]     就是我们在安装刀cker之后呢
[02:06/19:54]     刀ER就会帮我们创建了一个网桥设备
[02:09/19:54]     它主要用来调节所有的容器
[02:12/19:54]     构建容器网络
[02:13/19:54]     所以说你可以看到
[02:16/19:54]     在所有的容器启动之后
[02:20/19:54]     那它都会有两块虚拟网卡
[02:25/19:54]     第一块虚拟网卡呢
[02:26/19:54]     是放在容器内部的
[02:28/19:54]     第二块网卡是放在网桥上的是放在网桥上的
[02:32/19:54]     那通过这种形式呢
[02:35/19:54]     一个网桥连接了所有的容器的网络
[02:39/19:54]     连接了所有的容器的网络
[02:40/19:54]     并且呢
[02:41/19:54]     网桥呢
[02:42/19:54]     也跟我们宿主机之间呢
[02:44/19:54]     也有一个通信的一个机制
[02:46/19:54]     所以通过这种形式构建网模式
[02:50/19:54]     它也这种模式也是我们默认的使用的模式
[02:55/19:54]     在我们的docker里面呢
[02:56/19:54]     如果你在启动容器的时候没有这个特设定网络模式话
[03:02/19:54]     认使用是网式
[03:04/19:54]     网式是要
[03:10/19:54]     就是要做端口映射
[03:12/19:54]     大家可大家还记不记得
[03:14/19:54]     就之前课程讲的时候呢
[03:16/19:54]     就是说我们的思
[03:17/19:54]     我们与容器网络进行通信的思是什
[03:21/19:54]     是把我们的丝主机作为跳板先把我们的先把我们的网络请求发送到宿主机上
[03:31/19:54]     然后由宿主机把我们的请求转发到容器网络里面
[03:35/19:54]     而这里面呢
[03:36/19:54]     就是说发送到我们的速据网卡之后
[03:38/19:54]     你可以看到这里面有一个内核参数叫IP forward
[03:48/19:54]     它是可以让你的复主机具有转发能力
[03:52/19:54]     正常的网络请求的处理方式是什么呢
[03:54/19:54]     如果说我一台机器收到了一段网络报文
[03:57/19:54]     那我们会把这个网络报文的那个头给拆开
[04:02/19:54]     把网络包拆开
[04:03/19:54]     然后去检查他的IP头
[04:04/19:54]     看他的这个目的IP地址是不是我们的
[04:09/19:54]     它的目的IP地址是不是我们当前机器的IP地址
[04:12/19:54]     如果是的话
[04:13/19:54]     那我们处理
[04:14/19:54]     如果不是的话
[04:15/19:54]     就会直接把这个包丢掉
[04:19/19:54]     那我们就知道
[04:20/19:54]     如果说按照这种形式的话
[04:21/19:54]     我们是没有办法转发的
[04:22/19:54]     因为我们的网络请求发送给我们的这个发送给了我们这个那什么
[04:27/19:54]     我们的这个四级之后发现IP地址不是我自己
[04:30/19:54]     那我就丢掉了
[04:31/19:54]     我丢掉了
[04:34/19:54]     对吧
[04:35/19:54]     那这里这就是有问题的
[04:37/19:54]     这时候呢
[04:38/19:54]     他没有办法转发了
[04:40/19:54]     所以说呢
[04:43/19:54]     我们要做什么事
[04:44/19:54]     我I
[04:47/19:54]     内核参数打开
[04:48/19:54]     内核打参数打开
[04:50/19:54]     实际上在我们在安装docker的时候
[04:52/19:54]     根据那个ER的官方文档里面
[04:55/19:54]     在部署docker的时候
[04:56/19:54]     他就会给告诉你一个
[04:58/19:54]     有一段话就告诉你要检查内核参数
[05:01/19:54]     其中一个内核参数就是IP否的也得把这个打开
[05:04/19:54]     不打开的话
[05:05/19:54]     容器网络是没有办法访问的
[05:06/19:54]     所以说当我们把请求发送给宿主机之后发送给速主机之后
[05:12/19:54]     发送到速主机
[05:13/19:54]     然后根据我们的那个端口映射规则
[05:17/19:54]     根据我们端口映射的规则
[05:19/19:54]     它会把宿主机
[05:22/19:54]     它会把发送给宿主机某个特定端口号的
[05:27/19:54]     特定端口号的网络请求
[05:29/19:54]     根据端口应射规则转发到容器网络上去当然你开了IP之后
[05:33/19:54]     你才能转发过去
[05:34/19:54]     这个时候我们就转发到了DOER0上
[05:37/19:54]     然后DOER0再根据广播的性质广播的性质去把这个IP报文请求发送给这些容器
[05:45/19:54]     那这个就是网桥模式的一个
[05:48/19:54]     稍微浅显一点的原理吧
[05:50/19:54]     它背后当然它背后还有很多的一些原理
[05:53/19:54]     比如说它是如何定规则的
[05:55/19:54]     IP tables如何定制网络规则
[06:00/19:54]     我们如何去转做转发的
[06:02/19:54]     我们如何利用net网络去做这个流量转发的等等等等
[06:06/19:54]     这个我们会在后面的讲
[06:08/19:54]     那space讲
[06:09/19:54]     你们只是需要知道网模式是长这个样子的
[06:14/19:54]     是我默认的一个网络模式
[06:16/19:54]     因为之前我们已经通过这个doer run这个命令个已经给大家演示过了
[06:21/19:54]     所以说在这里我不演示了
[06:23/19:54]     然后下一个模式是什么
[06:25/19:54]     下模式是host模式
[06:27/19:54]     就是主机模式
[06:29/19:54]     翻译成中文可能就主机模式
[06:31/19:54]     它主要是为了解决什么问题呢
[06:34/19:54]     有些时候有些时候
[06:36/19:54]     就是说可能有些同学之前就问
[06:38/19:54]     就是使用容器的话太麻烦了
[06:39/19:54]     因为你要维护端口映射规则嘛
[06:42/19:54]     你要维护这个光映射规则
[06:44/19:54]     它比较麻烦
[06:45/19:54]     而且有些时候呢
[06:47/19:54]     我要启动一个软件或者启动一个服务
[06:53/19:54]     当然大部分的时候
[06:54/19:54]     启动服务的时候跟45G没什么太大关系
[06:56/19:54]     我用容器启动着
[06:57/19:54]     但是如果我们的公司的网络有一些安全上的设置
[07:05/19:54]     安全上的设置
[07:07/19:54]     那么它有可能什么呢
[07:09/19:54]     有可能会造成一种情况
[07:10/19:54]     就是你的宿主机是可以访问的
[07:13/19:54]     但是你的容器访问不了
[07:15/19:54]     你在宿主机之上启动的容器访问不了
[07:17/19:54]     因为你的容器里面有自己独立的网络
[07:19/19:54]     民生空间等等的一些东西
[07:21/19:54]     有独立的网络民称空间
[07:24/19:54]     所以说它使用的那个网络配置和数据是不一样
[07:28/19:54]     就容器的网络配置和速据是不一样的
[07:30/19:54]     这个大家能理解对吧
[07:31/19:54]     所以说导致于什么呢
[07:32/19:54]     导致于假如假设说我们的这个网络安全是认什么
[07:36/19:54]     是按认IP地址的
[07:38/19:54]     IP地址的
[07:39/19:54]     只有固定的IP地址才能访问你的
[07:42/19:54]     访问你的公司的资源
[07:43/19:54]     又或者说SSH的那个K的
[07:47/19:54]     大家应该用过SK吧
[07:49/19:54]     或者是SK这种形式去做安全认证的
[07:53/19:54]     那这会导致于什么呢
[07:54/19:54]     你在主机上你是可以访问这些资源
[07:56/19:54]     但是你一旦在四主机上启动一个容器
[07:59/19:54]     那个容器就访问不了
[08:00/19:54]     因为它有不同的IP地址和不同的SSH的T
[08:04/19:54]     那所以说呢
[08:06/19:54]     基于某某种原
[08:07/19:54]     基于这这些原因吧
[08:09/19:54]     所以说我们希望启动容器的同时
[08:11/19:54]     它还能够使用副主机的网络
[08:15/19:54]     速一的网络
[08:16/19:54]     那这个时候host模式就
[08:20/19:54]     Host模式就就这个什么了
[08:21/19:54]     就是非常有用的了
[08:23/19:54]     实际上呢
[08:24/19:54]     我之前呢
[08:25/19:54]     我之前我们公司做C的时候
[08:27/19:54]     我们的容器用的都是host模式
[08:32/19:54]     编译容器都是用的host模式
[08:34/19:54]     因为我们当时的G有一个设置
[08:37/19:54]     他们把把HTPTP的访问给禁掉了
[08:40/19:54]     我只能用SSH去那个K去访问
[08:43/19:54]     那于是乎呢
[08:44/19:54]     我就在四主机上配置了这个SK
[08:46/19:54]     然后呢
[08:48/19:54]     启动的容器全启动的编译容器全部用host模式启动的
[08:54/19:54]     这样的话呢
[08:55/19:54]     它能够共享45G的网络配置
[08:57/19:54]     也就共享了那个FSH的设置
[08:59/19:54]     它就能够启动的任何一个容器都可以访问我们的gate的这个什么
[09:03/19:54]     我们的gate的这个仓库
[09:06/19:54]     那使用后侧模式
[09:17/19:54]     大家可以看到
[09:18/19:54]     你可以相当于说我们之前用bridge模式的时候
[09:22/19:54]     你可以看到它是有独立的网卡拟链接网使
[09:38/19:54]     它使用的直接是你可以看到这个图
[09:39/19:54]     就它直接就指向了40级的这块网卡上那如何指定如何使用host网络模式呢
[09:47/19:54]     其实也很简单
[09:55/19:54]     的脚本脚本这里边其实可以看到的
[09:58/19:54]     我把这个东西放大一点
[10:01/19:54]     放大一点这个东西大家可以看到所有的参数跟之前都是一样的
[10:07/19:54]     只有一个例外就是这个
[10:09/19:54]     杠杠等于host
[10:11/19:54]     杠杠就是在指定你的网络模式
[10:14/19:54]     你启动这个容器的网络模式
[10:19/19:54]     网络模式其他都是一样的
[10:22/19:54]     你可以对比上面我已经注释的这个东西
[10:25/19:54]     唯一不同的就是什么呢
[10:26/19:54]     没有杠P参数了
[10:28/19:54]     因为我使用四据模式次数不需要端口运输不需要端口的时候
[10:31/19:54]     我只需要指定它是四主机了
[10:33/19:54]     那么一会儿我其实我就可以用8080端口去访问了当然我们的教学服务器好像是不是没开8080端口anyway anyway
[10:42/19:54]     那我们可以试着运行一下这个脚本
[10:47/19:54]     听一下
[10:53/19:54]     怎么又没有这个
[10:56/19:54]     怎么又没有这个这个这个这个
[11:00/19:54]     定向了
[11:02/19:54]     可能要更新了
[11:03/19:54]     那我们稍稍等一下
[11:05/19:54]     等他下载完
[11:22/19:54]     为了不耽误大家时间
[11:24/19:54]     我们接着往下讲
[11:25/19:54]     这是我们的host模式
[11:28/19:54]     我们先把原理讲清楚
[11:29/19:54]     后面再讲实操
[11:30/19:54]     然后再看contain模式
[11:32/19:54]     Contain模式就是容器模式
[11:34/19:54]     就是我们理解了这个host网络模式
[11:36/19:54]     我理解模式其实也比较好理解
[11:38/19:54]     如果说host模式是我们在启动容器的时候不构建自己的网络
[11:44/19:54]     是直接使用这个容器
[11:47/19:54]     这个自主机的网络的话
[11:48/19:54]     那么content模式是content模式就是说我启动容器的时候使用另外一个容器的
[11:54/19:54]     网络设置
[11:56/19:54]     大家可以看这个图
[11:57/19:54]     启动的时候直接指向了另外一个容器的网卡上
[12:02/19:54]     那可能有些同学有些同学会问
[12:04/19:54]     就就是这么搞是为什么
[12:06/19:54]     如果说你我们用后侧网络是还可以理解
[12:09/19:54]     我们还可以理解
[12:11/19:54]     我直接用四主机的这个网络的话会很方便
[12:14/19:54]     在很多有安全设置的场景呢
[12:17/19:54]     或者说做一些路由的场景是比较是比较
[12:20/19:54]     这什么的是比较方便的就刚才我可能忘讲了一个就是host模式经常也被作为路由
[12:25/19:54]     因为host模式是使用次主机的网络嘛
[12:28/19:54]     使四机网络其实我们是可直接可以跟这个容器里面的进程进行网络通信呢
[12:35/19:54]     不需要做端口映设
[12:36/19:54]     而它本身又启动在容容器集群里面
[12:39/19:54]     所以说在KPS里面经常用host网络模式去做路由
[12:43/19:54]     因为它既能访问本地的集群集群集群容器集群的网络
[12:47/19:54]     那又能够访问这个外部网络
[12:49/19:54]     所以说它是十分适合做路由
[12:52/19:54]     实际上在K8S里面
[12:53/19:54]     它的就是一个七七层路由
[12:55/19:54]     它这种后侧模式启动的
[12:57/19:54]     这个给大家补充一下大家补充一下
[12:59/19:54]     那回到刚才的问题
[13:00/19:54]     那量模式是为了啥
[13:02/19:54]     这个这个使用场景好像大家一般来说
[13:05/19:54]     第一次接触的同学都会比较费解
[13:10/19:54]     那它的使用场景是干嘛
[13:12/19:54]     它主要是为了方便容器和容器之间进行通信
[13:17/19:54]     我们之前在说启动一个t link的这么一个实践的时候
[13:25/19:54]     我们曾经说要启动两个容器
[13:26/19:54]     然后用杠杠link这么一个参数
[13:29/19:54]     链接这两个链接这两个
[13:32/19:54]     那什么链接这两个容器的
[13:34/19:54]     但是呢
[13:35/19:54]     刚刚link的缺陷是什么呢
[13:38/19:54]     刚刚link的缺陷是其他很多缺陷
[13:40/19:54]     它最主要缺陷是什么
[13:41/19:54]     它只能在同一台机器
[13:45/19:54]     它只能够在同一台机器里面
[13:49/19:54]     去去去启动
[13:51/19:54]     当然模式也是这样的
[13:53/19:54]     有一个缺陷是什么杠的缺陷
[14:00/19:54]     它是以
[14:02/19:54]     你个网络设置变量形式入当
[14:10/19:54]     注入到当前容器的
[14:11/19:54]     所以说它要求什么
[14:12/19:54]     它要求首先你的当前容器
[14:15/19:54]     你的当前容器一定要去读取固定的
[14:20/19:54]     环境变量
[14:21/19:54]     这是第一点
[14:24/19:54]     那第二点是什么呢
[14:26/19:54]     第二点是如果你之前的容器的IP地址发生了变化
[14:32/19:54]     比如说它重启了
[14:34/19:54]     那其实你环境置变量
[14:40/19:54]     值都是老的值了
[14:42/19:54]     都是旧的值
[14:43/19:54]     你得更新
[14:44/19:54]     你唯一就要更新的手段就是你得把当前这个容器也启动起来
[14:49/19:54]     就大家能不能理解
[14:50/19:54]     就是说我们都说docker在容器在启动的时候
[14:54/19:54]     它的IP地址是随机的
[14:56/19:54]     所以说如果这个容器被删除掉了
[14:58/19:54]     重建
[14:59/19:54]     那它就是一个新的IP地址了
[15:01/19:54]     所以说你之前通过环境变量注入进的IP地址就是就是用不了的
[15:06/19:54]     就是用不了的
[15:08/19:54]     所以说这是杠刚LINK2个两个比较大的缺陷
[15:11/19:54]     这其实三个比较大的缺陷
[15:12/19:54]     但是第三个缺陷就是我们最开始说的那个缺陷
[15:16/19:54]     就是它必须在同一台机器上
[15:18/19:54]     实际上contain模式也有这个缺陷
[15:21/19:54]     那其实也不算缺陷吧
[15:23/19:54]     这算它的一个设计的特点
[15:24/19:54]     那contain模式代表什么呢
[15:26/19:54]     Contain模式就是说如果你又遇到了这两个容器之间需要配合的才一个务
[15:35/19:54]     和DB这样的这样的这种情况
[15:39/19:54]     那你就可以用contain模式启动
[15:41/19:54]     这样的话两个容器使用的是同一个IP地址
[15:44/19:54]     它们之间互相用I localhot就可以互相分
[15:49/19:54]     这是
[15:54/19:54]     这个模式非常重要
[15:55/19:54]     尤其在KS里面非常重要
[15:58/19:54]     它是因为我们后续学习的时候
[16:00/19:54]     你会发现有很多很复杂的服务都是需要多个容器进行配合的
[16:05/19:54]     那多个种之间配合
[16:06/19:54]     他们就需要交互
[16:07/19:54]     他们需要网络上的交互
[16:09/19:54]     需要文件上的交互
[16:10/19:54]     那文件交互用什么呢
[16:12/19:54]     文件交互用杠V
[16:13/19:54]     就是我们讲到了之前讲到了这个volume
[16:16/19:54]     就是我们的文件载只要两个容器一个径
[16:19/19:54]     那么可以做文件的交互
[16:22/19:54]     那网络交互是怎么交互呢
[16:24/19:54]     就是通过模式进行交互
[16:45/19:54]     都也是通过模式去编写
[16:48/19:54]     比如说我们要编写一个server
[16:50/19:54]     这个server怎么去拦截
[16:52/19:54]     怎么才能拦截到这个目标服务的用户请求呢
[16:58/19:54]     怎么拦截呢
[16:59/19:54]     那就是用content模式
[17:00/19:54]     先让他们处于同一个IP地址下
[17:03/19:54]     然后用IP命令
[17:06/19:54]     所以说content模式是一个比较重要的一个模式
[17:09/19:54]     那么我们看刚才
[17:11/19:54]     刚才我们已经通过这个
[17:14/19:54]     启动起来了
[17:16/19:54]     已经通过这个启动起来了
[17:17/19:54]     然后我们看一下8080端口能不能访问看一下8080端口
[17:25/19:54]     还真的访问不了
[17:27/19:54]     因为这个咱们的教学服务器是在是在阿里云上的
[17:34/19:54]     好像是然后安全组里面是没有开8080端口的
[17:37/19:54]     所以在这我可以必须映射到5003端口
[17:40/19:54]     但实际上我们可以通过日志可以看出来
[17:44/19:54]     我通过日志给大家看吧
[17:45/19:54]     因为我们的教研服务器的限制
[17:49/19:54]     我们可能是看不到这个图形界面了
[17:57/19:54]     叫什么名我起的
[18:02/19:54]     Do lo啊
[18:04/19:54]     刚才用C条log你可以看到它已经启动完了
[18:08/19:54]     这个异常你不用管
[18:09/19:54]     这个异常是那什么
[18:10/19:54]     这个异常是那个是那个
[18:13/19:54]     我下一个插件下载了一个插件
[18:18/19:54]     个它已经启动起来了已经启动起来
[18:30/19:54]     只不过因为这个教学服务器的限制
[18:33/19:54]     我们现在访问不了
[18:36/19:54]     然后我把这个删了
[18:39/19:54]     买这个
[18:41/19:54]     接着我们看
[19:02/19:54]     他们两个要通信那
[19:03/19:54]     Co要去连接后端那
[19:06/19:54]     第一个容器正常启动
[19:08/19:54]     只不过在启动第二个容器的时候抗模式大家可以看到
[19:14/19:54]     这里面怎么写刚刚后这个错了
[19:18/19:54]     我看是不是在这里面
[19:32/19:54]     Contain代用
[19:36/19:54]     那个contain网络模式了
[19:38/19:54]     然后冒号代表着你要使用哪个容器的网络模式的那个网络
[19:43/19:54]     那我们使用的是第一个
[19:46/19:54]     我们名字叫做Co难的这么一个
[19:50/19:54]     容器
[19:51/19:54]     那通过这种形式启动的容器呢
[19:53/19:54]     就会发现它们两个容器使用的IP地址是同一个
[19:56/19:54]     他们两个的IP一直是同一个
[19:59/19:54]     好
[20:00/19:54]     这就是我们的网络模式了网络模式了
[20:06/19:54]     这节课我们先到这里



## 69、docker 容器技术-III

### 1、docker 容器镜像简介
[00:00/10:59]     我们开始进入到镜像相关的学习内容来
[00:05/10:59]     我们还是要先简单的去介绍一下我镜像到底它是一个什么东西
[00:13/10:59]     那实际上呢
[00:14/10:59]     我可能个人觉得
[00:16/10:59]     不需要特别详细的去讲这个这方面的东西
[00:19/10:59]     因为我们之前在学习容器的时候呢
[00:24/10:59]     已经通过镜像去启动各种各样的服务了
[00:27/10:59]     所以说其实理论上大家现在应该已经从直觉上已经体会到了
[00:33/10:59]     就是说镜像它是一个什么样的一个东西
[00:35/10:59]     只是说可能它缺少一些可能底层的一些介绍可能我们现在只是说直到镜像它是一个
[00:45/10:59]     它是一个把我们需要的服务和相关的一些环境依赖全都打包成一个这么一个东西然后呢
[00:54/10:59]     只要用这个东西启动成容器
[00:56/10:59]     那就可以得到我们当时需要的环境的依赖和对应的服务了
[01:03/10:59]     当然更底层的原理呢
[01:06/10:59]     更底层的原理呢
[01:09/10:59]     它涉及到了一些lix相一主要主pace这门课呢
[01:21/10:59]     我们是打算到后面更进阶的内容的时候呢
[01:24/10:59]     才会讲解
[01:25/10:59]     那现在呢
[01:26/10:59]     可能只是简单的引出来
[01:28/10:59]     简单的引出来
[01:31/10:59]     给大家稍微的比较浅显的介绍一下
[01:34/10:59]     那namespace呢
[01:35/10:59]     是Linux的一个隔离机制
[01:38/10:59]     其实之前我们也留下过一个伏笔
[01:41/10:59]     就是说没有虚拟化内核
[01:44/10:59]     没有独立的内核怎么做隔的呢
[01:47/10:59]     其实的
[01:51/10:59]     你可以理解为namespace是
[01:54/10:59]     就像是为每一个进程分配的一个独立的一个空间疫苗
[02:06/10:59]     对
[02:07/10:59]     所以说其实是什么呢
[02:09/10:59]     其实你可以理解为我们在做镜像的时候
[02:14/10:59]     做镜像的时候就已经把非常多的软件文件还有目录
[02:20/10:59]     这些你可以这些文件类类型的这种东西呢
[02:26/10:59]     全都
[02:28/10:59]     打包打包起来
[02:30/10:59]     挂载到了什么呢
[02:32/10:59]     挂载到了一个叫做mountain namespace的这么一个名称空间
[02:38/10:59]     就文件的就会把启动的时候
[02:45/10:59]     就会把我们制作镜像里面里面所有的文件
[02:49/10:59]     全都通过载到这个容器的root FS上面去
[02:55/10:59]     这样的话
[02:57/10:59]     你的这个容器启动的时候
[02:59/10:59]     你看到的所有的文件
[03:01/10:59]     还有这个目录
[03:04/10:59]     这些东西都是你在做镜像里面的
[03:06/10:59]     镜像里面你规定的那些东西了
[03:09/10:59]     所以说镜个什么东西
[03:12/10:59]     你可实可以简单为一
[03:19/10:59]     一
[03:22/10:59]     你是在制作镜像的时候
[03:25/10:59]     就把你需要的所有的软件
[03:28/10:59]     把你需要所有的软件目录配置文件等各种各样的东西
[03:34/10:59]     全都是文件的形式
[03:38/10:59]     保存到你机器中的某一个目录下面去
[03:41/10:59]     只不过在启动镜像的时候会把这些目录全都以一定的规则挂载到这个容器的FS上
[03:49/10:59]     这样你进入容器的时候
[03:50/10:59]     你会发现你看到的就都是这些东西了
[03:53/10:59]     这是从底层原理讲
[03:55/10:59]     就什么是镜像当然了
[03:57/10:59]     大家如果到了这里
[03:59/10:59]     其实听不懂的话没有
[04:08/10:59]     这个内容的
[04:10/10:59]     它的用处是什么东西
[04:20/10:59]     OK
[04:22/10:59]     案当中脱颖而出的关键
[04:45/10:59]     实际上在docker出现之前的时候呢
[04:49/10:59]     大家还是使用类似于像open stack的这种形式
[04:53/10:59]     是维护自己的环境
[04:56/10:59]     包括很多云服务商呢
[04:58/10:59]     也都是用类似的这种open stack的这样的一个系统去为用户去提供云服务的
[05:06/10:59]     可以理解为就是虚拟机
[05:08/10:59]     就虚拟机事实上呢
[05:10/10:59]     当初在刚出现的时候
[05:13/10:59]     就是说社区里面曾经有一个比较出名的一个PM
[05:16/10:59]     就一个产品经理
[05:17/10:59]     他曾经调研过这个docker
[05:20/10:59]     并且呢跟自家的产品进行了比较
[05:24/10:59]     比较其实他当时下了一个结论是什么呢
[05:26/10:59]     说doer并没有特别多的
[05:28/10:59]     就是并没有什么原创的这种新的这种技术点
[05:33/10:59]     他利用的仍然是去完成的隔离也就是说其实
[05:50/10:59]     就容器并不是创造出来的
[05:52/10:59]     在出现之前的概念就存在社区
[05:56/10:59]     实际上呢
[05:58/10:59]     刚才我说这位出名的
[06:11/10:59]     当时他下断言说是并不会覆这个行业
[06:15/10:59]     并不会颠覆这个行业
[06:17/10:59]     大家不于
[06:18/10:59]     但很快就被打脸了
[06:21/10:59]     也就是大概半年吧
[06:22/10:59]     之后吧
[06:23/10:59]     刀客就已经迅速的在全世界内范围内流行
[06:27/10:59]     流行了起来
[06:28/10:59]     并且啊
[06:29/10:59]     让很多的这种虚拟机为基础站
[06:31/10:59]     Opens sta open stack为基础站的运维人员呢
[06:35/10:59]     他们所拥有的技能就被淘汰了
[06:38/10:59]     就就占的忽略了doer镜像的存在
[06:49/10:59]     尤其是CK的存在
[07:01/10:59]     而且维护非常可维护性非常的高
[07:05/10:59]     自动化
[07:06/10:59]     它是完全自动化的
[07:08/10:59]     而且是有记录的
[07:09/10:59]     而且是维性非常高的
[07:12/10:59]     成本非常的非常的这么一种
[07:15/10:59]     像制作的一个方式
[07:18/10:59]     的
[07:23/10:59]     所以说只要你的内核是相同的
[07:30/10:59]     那么它的镜就能够保证什么呢
[07:33/10:59]     就能保证你在任何一台内核相同的一个机器上去启动的话
[07:40/10:59]     你的就能获得完全的环境的一致性
[07:43/10:59]     完全的环境的一致性
[07:46/10:59]     就大家这个之前如果接触过
[07:49/10:59]     就出之的时候
[07:51/10:59]     接过云领的一些产话
[07:53/10:59]     就应该知道上云其实是一件非常
[07:58/10:59]     难的一件事情
[07:59/10:59]     虽然前就有腾讯云服商
[08:10/10:59]     环是常
[08:20/10:59]     它中间设计了非常复杂的流程
[08:22/10:59]     即便你觉得你的两边的环境应该是一致的
[08:25/10:59]     也经常会因为
[08:27/10:59]     是的
[08:35/10:59]     而现就镜
[08:37/10:59]     现就完全
[08:41/10:59]     这的试来
[09:09/10:59]     其实很简单的
[09:10/10:59]     如果没有docker的话
[09:11/10:59]     可能对于我们来说
[09:12/10:59]     我们要学习对应软件所需要的环境配置
[09:15/10:59]     你要搭建就Java的环境变量的
[09:36/10:59]     你要部属一个hi度集群
[09:38/10:59]     你要部属一个集群
[09:41/10:59]     又或者说你要部属于你们自家的产品
[09:43/10:59]     你自家产品可能是有好几百个微服务
[09:47/10:59]     或者没有几百微服
[09:48/10:59]     也是几十个微服务共同组成的这么一个系统
[09:52/10:59]     这些微服务里有各种各样的语言组成的
[09:55/10:59]     那就是很麻烦的一件事
[09:56/10:59]     而有了镜像之后呢
[09:58/10:59]     你就可以避免这些场景
[10:00/10:59]     这些东西程度杂装
[10:09/10:59]     后面呢
[10:10/10:59]     就是说这个当我们系统越来越复杂的时候
[10:15/10:59]     要把我们的系统上按部署到KS里面那编
[10:30/10:59]     它后面可能还会有一些像是harm chart这样的一些专门搞部署的项目
[10:36/10:59]     在KS里面就是专门搞这个自动化部署
[10:42/10:59]     这些东西呢
[10:43/10:59]     都是依赖于刀镜像
[10:45/10:59]     好
[10:46/10:59]     那我们这个这一课的内容就先到这里了
[10:49/10:59]     下节课我们看如何去制作一个镜像好吧



### 2、docker 容器镜像制作命令
[00:00/16:03]     我们来看一下在中如何
[00:04/16:03]     去制作一个镜像
[00:18/16:03]     Do命令呢
[00:19/16:03]     可以从一个正在已经启动的一个容器里面去去制作一个新的镜像
[00:28/16:03]     不知大家有没有在虚拟机做过镜像
[00:31/16:03]     虚拟也有镜像实也是说什么呢
[00:33/16:03]     虚拟镜像制方式呢
[00:35/16:03]     也是你需要一个镜像
[00:37/16:03]     比如说一个Windows的基础镜像
[00:39/16:03]     根据这个基础镜像
[00:41/16:03]     你启动出一个
[00:42/16:03]     你启动成一个这个虚拟机以后
[00:46/16:03]     然后你在这个虚拟机里面再去制作自己的这个软件
[00:50/16:03]     比如说安装软件
[00:51/16:03]     然后做配置文件
[00:53/16:03]     做各种各样的事情
[00:54/16:03]     然后呢
[00:55/16:03]     再给这个虚拟机打一个stand shop
[01:07/16:03]     其实对于docker来说也是类似的
[01:10/16:03]     对于docker来说也是类似的
[01:12/16:03]     你也是需要有一个基础镜像去启动一个容器
[01:15/16:03]     然后在这个容器里面你再去安装一下自己所有的服务的
[01:20/16:03]     然后你再把这个容器
[01:22/16:03]     把它给制作成一个新的镜像
[01:24/16:03]     这个我想大家应该都能理解
[01:26/16:03]     不能理解于一制作镜像最简单的一个步骤来
[01:31/16:03]     我们需要启动镜
[01:33/16:03]     我们启动一个
[01:34/16:03]     要不启动一个容器
[01:36/16:03]     这个容器可以是任何一个东西可以咱比如说我们这边有一个叫magicens的
[01:40/16:03]     就是我这个之前启动的ens的一个容器S的一个容器
[01:45/16:03]     假设说我们已经在这个容器里面安装好了我们需要的软件了
[01:50/16:03]     已经
[01:51/16:03]     那这个时候制作镜像最简单的方式是什么呢
[01:56/16:03]     最简单的方式就是do commit
[01:59/16:03]     名称给他制作一个新的版本
[02:11/16:03]     比如说叫V0
[02:14/16:03]     V10
[02:15/16:03]     然后回撤
[02:19/16:03]     这样子的话呢
[02:20/16:03]     我们就制作了一个新的镜像出来了
[02:23/16:03]     这个新的镜像就是max v10
[02:25/16:03]     我们可以通过docker images命令去看一下
[02:31/16:03]     YS
[02:34/16:03]     你看到这边就有一个SV10
[02:37/16:03]     是在14秒钟之前去创建的
[02:41/16:03]     去创建了
[02:44/16:03]     然后我们赶紧把它删掉
[02:47/16:03]     不要让他占
[02:48/16:03]     在这边占磁盘空间
[02:54/16:03]     忘了跟V0了
[02:56/16:03]     大家要记住
[02:57/16:03]     一旦你带了版本号之后
[03:00/16:03]     你要写清楚版本
[03:03/16:03]     那
[03:16/16:03]     为什么不推荐呢
[03:18/16:03]     因为虽然足够简单
[03:46/16:03]     也就是说当你制作完这个镜像之后
[03:48/16:03]     没有任何人知道你这个镜像具体做了什么样的事情
[03:54/16:03]     可能过几个之后
[03:56/16:03]     你就为的开发你自己了
[04:02/16:03]     可能你自己都忘了
[04:03/16:03]     维护
[04:16/16:03]     非常困难的一件事情
[04:19/16:03]     这是第1.2了一
[04:30/16:03]     很难再去个
[04:52/16:03]     是非常大过是领虚拟化领头关键现在家看一什么样子
[05:20/16:03]     首先它本身就是一个文件
[05:24/16:03]     它本身就是一个文件
[05:26/16:03]     这里面有一个的文件
[05:28/16:03]     我们可以用命令看一下它长什么样子
[05:32/16:03]     可以看到它是由一系列指令
[05:37/16:03]     组成的每一条令内容
[05:43/16:03]     任镜from令代镜的说
[06:02/16:03]     你要是根据这个基础镜像
[06:04/16:03]     基础镜像这个去进行扩展
[06:09/16:03]     去进行扩展
[06:10/16:03]     你没有办法生成一个出来
[06:14/16:03]     那当然可能有些会
[06:16/16:03]     就是那一定一个镜的
[06:19/16:03]     一定有一个基础镜像
[06:21/16:03]     那世界上第一个镜像是哪来的
[06:24/16:03]     因为我们作为用户
[06:25/16:03]     我们是不可能做出基础的
[06:27/16:03]     就好像是鸡生蛋
[06:28/16:03]     蛋生鸡的这个问题
[06:30/16:03]     现有鸡还是现有蛋的这么一个问题
[06:31/16:03]     那第一个定向是哪来的
[06:33/16:03]     你说是一定要是一定是由各个的容器厂商提供的
[06:48/16:03]     是的
[06:56/16:03]     一个定出来个大
[07:00/16:03]     不过于注定是
[07:06/16:03]     会提供的
[07:07/16:03]     然后再然后我们看指令是把外部文件加到加载到我们的
[07:13/16:03]     镜像里面的令运行的地方令
[07:20/16:03]     设置容器的启动脚本的地方
[07:25/16:03]     里面存在很多令
[07:27/16:03]     常用的也么几令不到到
[07:35/16:03]     大家可以把它理解为就把它理解为一个自动化的脚本
[07:41/16:03]     把它理解为自动化的脚本
[07:42/16:03]     它可以把
[07:45/16:03]     制作镜像的步骤
[07:47/16:03]     脚本的形式
[07:49/16:03]     记录下来
[07:51/16:03]     然后我们运行一个命令
[07:53/16:03]     就可以把do file中的脚本执行起来
[07:55/16:03]     自动化的去执行我们的镜像制作的过程
[07:59/16:03]     制作镜像
[08:11/16:03]     那个需要人工呢
[08:12/16:03]     到镜像里面去执行各种各样的命令
[08:14/16:03]     去安装软件
[08:15/16:03]     去搞一些配置
[08:29/16:03]     技术定向加载外部文件
[08:32/16:03]     然后RA指令你看它到安装各种各样的软件
[08:35/16:03]     全自动化安装的
[08:37/16:03]     所以说你完全可以把它当成一个自动化的脚本
[08:41/16:03]     自动化的脚本
[08:42/16:03]     当我们准备好这个脚本以后
[08:50/16:03]     避免用缓存
[08:51/16:03]     我修改一下
[08:53/16:03]     那我们可以用什么命令呢
[08:55/16:03]     叫刀
[08:57/16:03]     Build
[08:59/16:03]     命令杠T
[09:00/16:03]     杠T后面跟着什么呢
[09:02/16:03]     杠T后面跟着
[09:04/16:03]     你要制作的镜像的名称
[09:08/16:03]     比如说我们叫TP
[09:10/16:03]     然后V1.0
[09:12/16:03]     这是我们的制度定向
[09:14/16:03]     然后最后面指定工作目录
[09:17/16:03]     我们的工目录就是当前目录
[09:19/16:03]     用点来代替这个目录是干嘛
[09:21/16:03]     干什么的呢
[09:22/16:03]     就是用来读取文件来目录
[09:25/16:03]     你到哪个文件
[09:26/16:03]     你到哪个目录下读取
[09:29/16:03]     你到哪个那个目录下去读取其他的外部文件
[09:34/16:03]     这是工作目录
[09:36/16:03]     默认build命令会认找工作目录下面的名字叫这个文件
[09:42/16:03]     所以说我在当前目录下
[09:56/16:03]     这个文件我就把它起名为
[09:58/16:03]     它默认就是找这个文件
[10:00/16:03]     如果你不喜欢这个名字
[10:04/16:03]     你非得要命成其他的名字的话
[10:06/16:03]     那你就要这边用杠F命令去指定
[10:10/16:03]     它的文件的目录
[10:13/16:03]     文件的地址
[10:14/16:03]     当然没有人这么基本上俗
[10:18/16:03]     俗
[10:25/16:03]     所以说点击回车
[10:28/16:03]     点击回车
[10:29/16:03]     这个时候就令一步一步去
[10:36/16:03]     一步一步一下
[10:41/16:03]     我们可以看一下它的执行步骤
[10:43/16:03]     大家能不能对于大家这个更深刻的理解doer file的运行机制是有帮助的
[10:57/16:03]     是什么呢
[10:58/16:03]     是把当前的制作镜像的上下文发送给docker的守护进程这个上下文大小一共是4.608KB
[11:08/16:03]     它这个是在干嘛呢
[11:09/16:03]     它这个就是把工作目录下所有的文件全都加载到内存中
[11:15/16:03]     并且发送给docker
[11:20/16:03]     这样刀客才能制作镜像
[11:22/16:03]     就是上下上下
[11:43/16:03]     上下上下西
[12:00/16:03]     它会严重
[12:01/16:03]     它会严重的消耗你当前机器的资源
[12:06/16:03]     以及影响你的镜像制作的速度
[12:09/16:03]     我们当前这个例子里面只有4.608KB
[12:12/16:03]     那所以说呢
[12:13/16:03]     它发送的时间很短的
[12:14/16:03]     你可以不用管
[12:15/16:03]     但是如果说你这个目录里面你有100个G的其他的不相关的文件的话
[12:21/16:03]     那是很难受的
[12:24/16:03]     所以说
[12:25/16:03]     刚才我们说的第一个规则大家清楚
[12:28/16:03]     要独立的保存在一个独立的目录里面
[12:31/16:03]     这个目录里面不能有其他跟制作镜像无关的东西
[12:34/16:03]     大家弄清楚
[12:37/16:03]     然后往下看
[12:47/16:03]     它它会根据这个镜像启动一个临时的容器
[12:52/16:03]     会启动一个临时的容器
[12:56/16:03]     然后下面去运行什么呢
[12:57/16:03]     运行你的这些指令呢
[12:59/16:03]     开始开始运行这些指在这个临时容器里面运行指令了
[13:03/16:03]     运行指令你可以看到
[13:05/16:03]     你可以在这一步里面可以看到running一个什么什么ID
[13:08/16:03]     这个ID就是那个临时的容器
[13:12/16:03]     也就是说这个指令是在这个临时容器里面去运行的
[13:31/16:03]     这是干什么呢
[13:32/16:03]     去删除中间状态的容器
[13:36/16:03]     因为令运
[13:43/16:03]     然后呢
[13:46/16:03]     后面会告诉你
[13:48/16:03]     Successfully built
[13:50/16:03]     然后这么一个镜像ID已经把这个镜像
[13:57/16:03]     把它打了一个新的叹号
[13:59/16:03]     就是我们命名的那个精享名称
[14:03/16:03]     所以到一个file里面定义的这些指令
[14:14/16:03]     然后呢
[14:15/16:03]     再通过commit命令
[14:28/16:03]     答案里边了
[14:29/16:03]     能够看懂这个过程的
[14:40/16:03]     自动化脚本
[14:41/16:03]     最后它也是用do commit
[14:44/16:03]     去制作了镜像
[14:46/16:03]     然后再用docker tag去给这个镜像打一个tag出来
[14:52/16:03]     也是要起离身容器去运行这些东西的这些指令的
[14:57/16:03]     所以说这个大家需要这个应该可以理解理解了对吧
[15:02/16:03]     那么
[15:04/16:03]     这就是在刀客当中两种制作镜像的方法
[15:08/16:03]     当然了
[15:09/16:03]     我们业界里流行一句话是什么呢
[15:12/16:03]     永远不要用docker commit命令直接制作镜像
[15:16/16:03]     为什么呢
[15:17/16:03]     因原因我们大家说过们到个问题呢
[15:22/16:03]     因整个来说还是对于这个镜像的使用者来说
[15:29/16:03]     只要他能够得到do file
[15:31/16:03]     他就可以知道你追这镜像做了些什么样的事情
[15:34/16:03]     并且可以在任何一台有doer的这个
[15:38/16:03]     有刀cker的这么一个
[15:40/16:03]     服务器上去把这个镜像重新制作出来
[15:44/16:03]     以后就算你的镜像了
[15:46/16:03]     只要你的还在
[15:48/16:03]     你就可以完全复制一个一模一样
[15:52/16:03]     这就可以复制出一个一模一样的镜像出来
[15:56/16:03]     这就是我们这一小节的内容



### 3、docker 制作容器镜像实战
[00:00/09:59]     [以下字幕均由机器生成]我们来看一下的详细上一大概的介绍了一下do fire的一个运行形式
[00:12/09:59]     那么在上一节里面并没有详细的介绍每一个指令的一些作用
[00:19/09:59]     那这节课呢
[00:20/09:59]     我们来看一下这部分的内容这部分内内容
[00:24/09:59]     的令
[00:51/09:59]     它代表着你
[00:55/09:59]     要从一个基础上扩展
[00:59/09:59]     这个在上一节课里面我们详细讲解过
[01:02/09:59]     需要注意的是
[01:03/09:59]     如果我们把do当成一门编程语言的话
[01:07/09:59]     这个大家可以
[01:19/09:59]     在Python里面去
[01:20/09:59]     你去引入那些包的时候
[01:21/09:59]     也是用from指令对吧
[01:23/09:59]     然你可以
[01:24/09:59]     但是这里面你可以把它当成一个继承的一个概念
[01:28/09:59]     把它当成一个继承的概念
[01:39/09:59]     局限
[02:11/09:59]     占据内容最多的一个指令了占据内容最多的一个指令了
[02:14/09:59]     因为我们往往需要在我们制作的镜像里面呢
[02:19/09:59]     去运去运行很多的shell命令
[02:22/09:59]     包含了我们要去安装软件以及配置相关的配置文件等等等等
[02:27/09:59]     所以说run指令是非常多的
[02:29/09:59]     指令是非常多的
[02:31/09:59]     大家可以看到指令是可以用多个的
[02:36/09:59]     实际上这些指令
[02:37/09:59]     这些指令都是可以有有
[02:42/09:59]     你可以完全一一看起来清清
[03:04/09:59]     是ADD和copy指令ADD和copy指令
[03:10/09:59]     他们两个都是从
[03:13/09:59]     都是
[03:15/09:59]     从外部把文件copy到
[03:19/09:59]     Copy到里面细微
[03:23/09:59]     的
[03:38/09:59]     把这个压缩包拷到我们的镜里面之后
[03:41/09:59]     它会自动帮你解压
[03:44/09:59]     它会自动的帮你解压
[03:46/09:59]     而这个这个这个copy指令是不具备这个能力
[03:52/09:59]     这个是令具当个里面拷个拷
[04:09/09:59]     当前这个景段构建里面
[04:12/09:59]     我们刚才讲的多阶段构建里面
[04:14/09:59]     这个我们后面会讲
[04:16/09:59]     我们后面会讲好吧
[04:28/09:59]     他们的语法是一样的
[04:30/09:59]     从文件就是这是径
[04:34/09:59]     然后就是镜像的径
[04:36/09:59]     就是说把工作目录
[04:38/09:59]     大家注意这个是工作目录下
[04:41/09:59]     录这个
[05:02/09:59]     比如说我可以干什么事呢
[05:04/09:59]     我可以在这边用user root
[05:09/09:59]     代表什么
[05:10/09:59]     代表是用
[05:13/09:59]     下面的所有的指令
[05:17/09:59]     比如说我一定能
[05:23/09:59]     我才能够安装这些指令
[05:25/09:59]     假如说是这样的
[05:27/09:59]     后还可以用另外一个是么呢
[05:31/09:59]     比如我需要用能这个在启动器使用这个镜像去启动一个容器之后
[05:39/09:59]     我不希望用用户去执行
[05:43/09:59]     所以说那我还可以在这边用user
[05:45/09:59]     比如说用一个什么呢
[05:47/09:59]     比如说就叫这个词
[05:50/09:59]     我在这里面我我规定用执行下面的一系列的操作
[05:55/09:59]     包括什么呢
[05:56/09:59]     包括我们容器在启动之后读取的就是最后一个user指令
[06:02/09:59]     规定的用户
[06:03/09:59]     比如说我现在用这个东西
[06:05/09:59]     当前的这个制作一个镜像的时候
[06:08/09:59]     制作一个镜像的时候
[06:10/09:59]     那么
[06:15/09:59]     我在容器启用之后
[06:16/09:59]     其实容器启用之后
[06:18/09:59]     它使用了这个user
[06:19/09:59]     就是S
[06:21/09:59]     这个需要大家需要知道
[06:23/09:59]     这个大家需要知道
[06:25/09:59]     OK
[06:26/09:59]     再然后
[06:27/09:59]     令
[06:34/09:59]     Work电这里我的PPT里面写
[06:36/09:59]     因为它真的不常用
[06:37/09:59]     Work电就工作目录
[06:39/09:59]     比如说工作目录叫root
[06:41/09:59]     指
[06:47/09:59]     容器启动以后
[06:50/09:59]     它默认的目录是哪个目录
[06:52/09:59]     就是干这个用的
[06:53/09:59]     我们在这里面就指定root目录
[06:56/09:59]     令器的启动脚本启动命令
[07:11/09:59]     你容器的启动命令就是说镜像启动一个容器之后
[07:15/09:59]     它运行的第一个命令是什么
[07:35/09:59]     我启动MYSQ的命令
[07:37/09:59]     这个大家需要弄清楚
[07:38/09:59]     而使式使用SH
[07:55/09:59]     况下呢
[08:06/09:59]     你的启动的脚本是比较复杂
[08:09/09:59]     是较复杂
[08:10/09:59]     写写命令杂十
[08:21/09:59]     你倒不如引入一个外部文件
[08:25/09:59]     然后在这里面去认Pro里面执行这个外部的脚本就可以
[08:30/09:59]     Copy进来的脚本就可以
[08:33/09:59]     这是
[08:34/09:59]     然后还有一个什么指定变量指
[08:40/09:59]     比如说
[08:41/09:59]     我们装的是一个Java的一个服务
[08:44/09:59]     那我们肯定要配置什么呢
[08:45/09:59]     肯定要配置JA home呀
[08:47/09:59]     对吧
[08:49/09:59]     因为那我们就可以配置
[08:50/09:59]     比如说叫Java home
[08:54/09:59]     等于
[08:55/09:59]     这
[08:57/09:59]     然后因为比如说红
[09:02/09:59]     也是可以的也是可以的
[09:05/09:59]     是配置环境变量的
[09:07/09:59]     毕竟我们的服务启动还需要很多的环境变量
[09:10/09:59]     需要很多的环境变量
[09:12/09:59]     OK
[09:14/09:59]     这就是我们
[09:17/09:59]     常用的
[09:22/09:59]     质量
[09:25/09:59]     这是我们常用的指令
[09:28/09:59]     常用的
[09:31/09:59]     就分之九十以上的使用场景
[09:45/09:59]     90%以上的使用场景
[09:48/09:59]     大家可以多实验一下
[09:52/09:59]     这节课我们就讲到这里



### 4、docker 私有镜像仓库实战
[00:00/09:25]     [以下字幕均由机器生成]大制作我们的镜像
[00:09/09:25]     [以下字幕均由机器生成]其实cker的镜像制作的实操方面可讲的东西是非常少的
[00:15/09:25]     [以下字幕均由机器生成]就像我们课程一开始说的
[00:17/09:25]     一开始说的在世
[00:24/09:25]     我来形容就是说只要会写she的人就会做
[00:27/09:25]     实际上其实掌握了那几个常用指令以后
[00:29/09:25]     剩下的大部分工作就是在
[00:32/09:25]     安装软件配置一些服务的配置等等
[00:38/09:25]     它常用指令就没那么几个
[00:41/09:25]     那这节课呢
[00:42/09:25]     我们看一下搭建镜像仓库怎么搭建
[00:44/09:25]     其实搭建镜像仓库也是一个非常简单的一个操作的步骤
[00:50/09:25]     也是非常简单的操作步骤
[00:54/09:25]     大家而且大家呢
[00:56/09:25]     不需要对于搭建镜像仓库这部分的内容了解的多么深刻
[01:01/09:25]     因为呢
[01:02/09:25]     我们是测试人员嘛
[01:03/09:25]     我们只需要干什么呢
[01:05/09:25]     我们只说这个我们的测试环里面
[01:09/09:25]     我们了下的就好在测试环里面维护一个简单的仓库
[01:24/09:25]     因为如果你建设仓库
[01:27/09:25]     你要放到公司里面
[01:28/09:25]     一定要加公司的各种各样的策略
[01:30/09:25]     包括安全的设置
[01:32/09:25]     包括一些磁盘的一些优化
[01:35/09:25]     天能仓库磁盘的优化
[01:36/09:25]     包括一个安全的设置
[01:37/09:25]     你要用SSL协议或者TRS协议去加密等等等等等等一些东西
[01:42/09:25]     那个东西过于繁琐过于复杂
[01:45/09:25]     而且都是运维方面的工作
[01:47/09:25]     所以说呢
[01:48/09:25]     它不涉及测试相关的内容
[01:50/09:25]     在公司里面你都使用那些已经有运维同学维护好的这个公共的进行仓库就可以了
[01:58/09:25]     我们不需要仓库特别容
[02:02/09:25]     特别详细的内容
[02:04/09:25]     我其里面只给大家讲一下如何在测试环境里面
[02:07/09:25]     你们实验的时候
[02:09/09:25]     这样去做
[02:10/09:25]     怎么去做怎么去搭建就可以了
[02:13/09:25]     你们大概的了解一下就行
[02:14/09:25]     以及我会通过这个实验呢
[02:16/09:25]     告诉大家如何向精营仓库里面push和push相关的镜像好
[02:22/09:25]     那我们先回到这个我们的这个内容上来
[02:25/09:25]     其实呢
[02:26/09:25]     我把这个镜像仓库的这个搭建步骤呢
[02:28/09:25]     一共就这么几步
[02:29/09:25]     我也都列在我们的PPT里面到仓
[02:38/09:25]     容器
[02:39/09:25]     为本也是个服务
[02:40/09:25]     也是容器启动的
[02:42/09:25]     所以载的这个官的镜是版本是
[02:52/09:25]     我们是要通过docker的命令把它给启动起来
[02:58/09:25]     启动起来
[02:59/09:25]     这里面尤其需要用岗位参数把文件挂载出来把文件挂载出来
[03:03/09:25]     这样的话
[03:04/09:25]     你的镜像的就是持久化了
[03:06/09:25]     不会因为你的镜不会因为你的容器被删除
[03:10/09:25]     导致于你已经保存的镜像都全都丢掉
[03:15/09:25]     其实这样你运行这样一个就已经搭建起来了
[03:18/09:25]     去这个一个busy box镜像
[03:22/09:25]     然后给他打T等等的
[03:23/09:25]     其实都是在在验证它已经搭建完毕了所以呢
[03:30/09:25]     我们在这里面我们先看一下怎么启动一个
[03:34/09:25]     这里面有一个image的镜像
[03:38/09:25]     一个脚本
[03:39/09:25]     大家可以看到脚本里面其实就是我才PPP
[03:47/09:25]     所以说我们直接把它运行起来就好了
[03:49/09:25]     Bash docker image
[04:02/09:25]     那怎么做呢
[04:03/09:25]     那我们一个box我们先
[04:21/09:25]     不知道大家有没有注意当你使用
[04:34/09:25]     大家会发现我并没有
[04:38/09:25]     我并没有什么呢
[04:40/09:25]     我并没有指定任何仓库
[04:47/09:25]     没有指定任何仓库
[04:53/09:25]     他像哪个
[04:56/09:25]     镜像仓库下载
[04:59/09:25]     下载这个镜像的呢
[05:03/09:25]     大家想一想
[05:08/09:25]     上库这么多私的非常案于我们输入MY的时候
[05:18/09:25]     我要来下下载my circleql这个镜像
[05:20/09:25]     其实这并不是它的全称
[05:23/09:25]     并不是它的全称
[05:27/09:25]     真正的一个镜像的全全径是什么呢
[05:31/09:25]     它是这样的
[05:35/09:25]     镜像仓库的地址
[05:38/09:25]     然后
[05:40/09:25]     冒号端口号
[05:41/09:25]     然后斜线
[05:45/09:25]     路径
[05:47/09:25]     镜像名镜像名称
[05:50/09:25]     然后再冒号
[05:56/09:25]     看号
[06:01/09:25]     才是一个镜的称
[06:04/09:25]     这样你通过这一个径
[06:07/09:25]     你才能定唯一定义一个镜
[06:12/09:25]     而当我们
[06:15/09:25]     的啊
[06:26/09:25]     它是有默认值的
[06:29/09:25]     你看
[06:39/09:25]     Library就是镜像仓库的信息
[06:44/09:25]     镜像仓库的信息
[06:53/09:25]     他默认的
[06:54/09:25]     如果你指定仓库的
[06:57/09:25]     那就
[07:09/09:25]     我不跟马你看
[08:03/09:25]     仓库里面
[08:12/09:25]     那怎么办呢
[08:13/09:25]     那就需要用do park命令
[08:17/09:25]     把BU s box
[08:26/09:25]     斜线
[08:27/09:25]     前面我们刚才搭建的私有的健身仓库的地址
[08:31/09:25]     然后端口号
[08:34/09:25]     后面跟着一个什么叫my busy或者叫busy box吧
[08:39/09:25]     叫busy box
[08:40/09:25]     然后给一个V1.0
[08:44/09:25]     回车
[08:46/09:25]     然后我们
[08:49/09:25]     直接push他
[08:52/09:25]     可以看到这是已经复试成功了
[08:55/09:25]     这就已经成功了
[09:01/09:25]     这个查看一下
[09:02/09:25]     因为他没有默认没有提供图形界面
[09:05/09:25]     你看到这就是我们刚才push了一个叫box的一个景象
[09:10/09:25]     通过这种形式
[09:11/09:25]     我们就把镜像到了我们的私有镜像仓库里面
[09:17/09:25]     这节课的内容



### 5、docker-compose 实战练习
[00:00/10:06]     我们来看一下docker compose的使用
[00:04/10:06]     什么是docker compose呢
[00:06/10:06]     大家可以理解为它是一种
[00:12/10:06]     可以把多个容器编排在一起的一种工具
[00:16/10:06]     因为我们现在的软件都是很复杂的
[00:18/10:06]     它不是由一个容器组成的
[00:20/10:06]     所以说有很多的情况下
[00:22/10:06]     它需要多个容器组合在一起
[00:25/10:06]     然后呢
[00:26/10:06]     如果我们在多个容器组成在一起的时候
[00:29/10:06]     只是用原始的刀ER的这样的一个解决方案的话呢
[00:33/10:06]     它可能会你在管理起来会比较麻烦
[00:36/10:06]     所以说doer comps呢
[00:37/10:06]     就提供了一种组织形式
[00:40/10:06]     一个压文件的一个组织形式
[00:43/10:06]     把多个
[00:45/10:06]     把多个需要维护的容器
[00:48/10:06]     用一个压文件
[00:49/10:06]     就是容器的一些配置
[00:50/10:06]     用这个M文件进行这个管理起来
[00:54/10:06]     大白话的一个样子
[01:07/10:06]     这个呢
[01:09/10:06]     是在我的PPT里面这个copy的一段
[01:13/10:06]     这个这个网上的一段
[01:17/10:06]     对他的一个稍微正式一点的说明吧
[01:20/10:06]     但是意思是一样的意思是一样的
[01:29/10:06]     User local b下面
[01:51/10:06]     可执行的权限就可以了
[01:52/10:06]     一旦你把这一步做完之后
[01:56/10:06]     把这一步做完之后
[01:57/10:06]     其实我们可以看一下
[01:58/10:06]     我们可以在这边就看到
[02:20/10:06]     然后主要是什么呢
[02:31/10:06]     主要是要看一下这个一
[02:38/10:06]     语法
[02:41/10:06]     它的一个语法
[02:42/10:06]     因为它是一个用yamo文件去组织管理的
[02:45/10:06]     它不再用命令行去启动容器了
[02:47/10:06]     而是把命令行里面需要配置的一些参数呢
[02:51/10:06]     全部记录到这个文件里面大家可以看一下这个在这个service这个自下就是代表着你都要动哪些service
[03:02/10:06]     你可以理解为这些门DB
[03:05/10:06]     Test link就是容器的名称
[03:09/10:06]     容器的名称
[03:15/10:06]     启动这个下是这个镜量是这些要设置的环境变量对下面一个容器
[03:26/10:06]     它link也是一样的
[03:28/10:06]     它的image值
[03:29/10:06]     它的环境变量
[03:30/10:06]     然后它的端口映射的规则
[03:34/10:06]     你可以看到端口映射的规则
[03:36/10:06]     然后他的这个
[03:43/10:06]     买DB先启动
[03:44/10:06]     然后再启动t link啊
[03:46/10:06]     这是depend on的这个这个字段的含义
[03:52/10:06]     那当前的这个文件呢
[03:54/10:06]     其实展示的就是如何使用do comp去启动test link啊
[03:59/10:06]     因为毕竟test link我们在之前讲过如何用命令行去去进行部署
[04:04/10:06]     这因为只不过因为它是需要两个容器的
[04:08/10:06]     所以说你要用两个命令行
[04:09/10:06]     那今天呢
[04:10/10:06]     我们来看一下用docker comp post如何去维护的
[04:13/10:06]     当我们
[04:14/10:06]     准备好这样的一个文件之后呢
[04:17/10:06]     其实我们可以用docker
[04:19/10:06]     我先把它给删掉
[04:23/10:06]     先把它删掉
[04:35/10:06]     看到还有T杠T的
[04:47/10:06]     支持
[04:49/10:06]     就是他会把两个日志都给打印出来当前现在呢
[04:54/10:06]     我们DB都已经启动起来了
[04:56/10:06]     当然了
[04:58/10:06]     我们现在还是在前台运行
[04:59/10:06]     我们有加
[05:02/10:06]     CTRLC停止了
[05:03/10:06]     停止了之后呢
[05:04/10:06]     那你就可以用RM这个命令把它删掉
[05:09/10:06]     杠
[05:14/10:06]     启动起来
[05:15/10:06]     你可以看到它不会再把这打印到前台了
[05:17/10:06]     这跟我们用do run那个命令杠D的那个参数是一个意思
[05:20/10:06]     我们在后台运行
[05:22/10:06]     在后台运行
[05:23/10:06]     然后如果我们希望看到一些信息
[05:26/10:06]     比如说我们
[05:32/10:06]     这边有有两个容器正在运行叫T
[05:36/10:06]     然后有两个容器正在运行
[05:39/10:06]     如果你用什么用top
[05:41/10:06]     你可以看到什么呢
[05:42/10:06]     可以当前
[05:45/10:06]     容器里面
[05:46/10:06]     Comp管理的容器里面
[05:50/10:06]     它运行的进程
[05:52/10:06]     所有的命其实都可以通过comp的帮助文档可以看得到的
[05:57/10:06]     这些命令可以当包括你想看日志
[06:05/10:06]     你也可以看到日志
[06:06/10:06]     只不过他会把这些你当前启动的这个do comp文件里面的这两个服务的所日志合并在一起给你看
[06:18/10:06]     这些东西大家都可以去尝试一下尝试一下
[06:22/10:06]     那当我们把这些已经启动起来之后
[06:26/10:06]     其实它的效果跟效果跟我们之前一样的
[06:30/10:06]     大家可以看到体重T的效果是一样的
[06:34/10:06]     肌肉已经启动起来了
[06:35/10:06]     就一这些容器的一具没有好的一个性能
[07:07/10:06]     又或者说更好的一个功能
[07:10/10:06]     就是它就是让用户去维护容器的时候方便一些
[07:17/10:06]     说个景成一理后
[07:26/10:06]     用一套命令呢
[07:27/10:06]     就控制它的创建
[07:30/10:06]     删除等等这一系列的一个东西
[07:34/10:06]     等等这一系列的东西
[07:35/10:06]     所以说
[07:37/10:06]     本质上上使用场景比较
[07:44/10:06]     比较少
[07:46/10:06]     虽然他也是号称容器编排的一个解决方案
[07:49/10:06]     但是他的能力实在是太弱了
[07:52/10:06]     就他就能干到
[07:54/10:06]     就能干一些我刚才展示的这些功能
[07:56/10:06]     所以说在很多一些非常非常小的一些团队
[07:59/10:06]     还有系统里面
[08:01/10:06]     你可以用
[08:02/10:06]     然后去做一些什么样的情试可以
[08:18/10:06]     都是用K8S的
[08:20/10:06]     或者说有一些个别的公司可能会用doer s spam
[08:23/10:06]     或者是说这种容器编排的一个容器机群的一个系统都是有好多台机器共组组合在一起的
[08:31/10:06]     比如说比如说你像我上一家公司
[08:33/10:06]     我们的系统可能是它的服务数量得有上百个
[08:40/10:06]     我现在这家公司的产品
[08:42/10:06]     我现在这个团队的产品
[08:44/10:06]     光容器数量得有大几百个
[08:47/10:06]     容器的数量都要大大几百个
[08:50/10:06]     甚至上千个服务好几百个
[08:55/10:06]     然后每个服务它有好几个容器嘛
[08:57/10:06]     对所以
[08:59/10:06]     一更的系统以
[09:12/10:06]     时现都可以比较用因
[09:30/10:06]     K去管理你的这个容器
[09:42/10:06]     其实也蛮方便的
[09:43/10:06]     也算蛮方便的
[09:46/10:06]     毕竟你一条命令就可以了
[09:47/10:06]     一条命令就可以把这个在一个到comps文件里面的这个所有的服务全都启动起来
[09:55/10:06]     或者都删除掉
[09:58/10:06]     OK
[09:59/10:06]     那我们今天就讲到这儿吧



## 70、docker 容器技术-直播训练营



### 1、【直播实战】docker 镜像构建实战
[00:05/03:41:00]     [以下字幕均由机器生成]OK
[00:06/03:41:00]     能听到我声音画面也清楚
[00:07/03:41:00]     对吧
[00:09/03:41:00]     那我们就要开始今天开始今天的课程了
[00:13/03:41:00]     今天呢
[00:14/03:41:00]     那个由我给大家来一起就是实践一下我们的docker的容器的一些内容吧
[00:22/03:41:00]     这个相信大家之前也已经看过录播课了
[00:26/03:41:00]     然后在讲真正的就是实际的内容之前呢
[00:29/03:41:00]     我先跟大家先澄清一些事情
[00:32/03:41:00]     首先呢
[00:33/03:41:00]     就是我现在呢
[00:35/03:41:00]     因为我们刀课内容其实挺多的
[00:37/03:41:00]     所以说我假设大家都已经看完录播课了
[00:40/03:41:00]     所以说一些特别基础的东西呢
[00:43/03:41:00]     我可能只是大家复习一下就拉倒了
[00:45/03:41:00]     不会再特别详细的讲解了
[00:47/03:41:00]     那是这这这这是第一个事情
[00:50/03:41:00]     然后第二事情是什么呢
[00:51/03:41:00]     第二事情是这个我们在讲课的时候呢
[00:54/03:41:00]     我有一个习惯是每隔一段时间我都会到讨论区里面去看大家的留言
[01:00/03:41:00]     所以说如果在讲课的过程中的时候
[01:03/03:41:00]     如果大家有任何的问题都不用担心
[01:05/03:41:00]     你只需要
[01:06/03:41:00]     把自己的语言组织好
[01:07/03:41:00]     发到讨论区里面就行了
[01:09/03:41:00]     我基本上我我有一个条件反射
[01:11/03:41:00]     每隔几分钟我都会看一眼
[01:13/03:41:00]     所以说大家不用担心
[01:14/03:41:00]     对于这种情况
[01:16/03:41:00]     然后再一个事情是什么呢
[01:18/03:41:00]     我们今天这个这个直播课呢
[01:20/03:41:00]     主要是讲解实战的内容
[01:22/03:41:00]     今天会留比较多的时间给大家去实战
[01:26/03:41:00]     我今天给大给大家留了布置了一些任务
[01:30/03:41:00]     所以说呢
[01:31/03:41:00]     那个我也是假设大家都已经把相关的环境搭建好了对吧
[01:37/03:41:00]     那个所以说这个如果有同学还没有搭好环境
[01:41/03:41:00]     尽快去联系老师
[01:43/03:41:00]     或者你们自己解决一下
[01:44/03:41:00]     赶紧把环境搭建好
[01:45/03:41:00]     因为我们今天有很多的时间是在是在实践的
[01:50/03:41:00]     对吧
[01:51/03:41:00]     然后这是这三个事情
[01:52/03:41:00]     那如果这个大家对于这三个事情没有那个疑问的话
[01:56/03:41:00]     那我们就要开始今天的课程了好吧
[01:59/03:41:00]     OK
[02:00/03:41:00]     那么
[02:03/03:41:00]     首先呢
[02:04/03:41:00]     那个我先给大家第一第一件第一件事情
[02:08/03:41:00]     给大家这个复习一下先给大家复习一下
[02:12/03:41:00]     复习一下什么呢
[02:13/03:41:00]     复习一下我们这些常见的命令常见的命令在这呢
[02:18/03:41:00]     我还头一次用这个PPT讲
[02:20/03:41:00]     有点不太习惯do常用的命令
[02:25/03:41:00]     因为在录播里面
[02:26/03:41:00]     可能大家就是说只是单纯学一下这些命令的一些参数的意义
[02:33/03:41:00]     但是呢
[02:34/03:41:00]     如果说我们结合一些实战的场景来看一下这些命令的话
[02:38/03:41:00]     可能大家会理解的更深一点
[02:41/03:41:00]     我当然会列得更深一点
[02:42/03:41:00]     首先我先挨个介绍一下
[02:44/03:41:00]     基本上那些边我不介绍了
[02:46/03:41:00]     我就是介绍一些常用的常用的首先呢
[02:51/03:41:00]     其实我们在去运行一个容器的时候
[02:56/03:41:00]     最常用的就是do run这个命令对吧
[03:00/03:41:00]     然后为了能够
[03:02/03:41:00]     好管理
[03:03/03:41:00]     一般用杠
[03:11/03:41:00]     然后什么呢
[03:12/03:41:00]     然后杠D后台运行
[03:16/03:41:00]     在后台运行
[03:17/03:41:00]     因为如果我们不加杠G这个参数的话呢
[03:19/03:41:00]     它会随着我们当前的shell接口把这打出来
[03:22/03:41:00]     如果我们当前号断掉了
[03:23/03:41:00]     比如说我们按CTRLC啊
[03:25/03:41:00]     那么整个容器就会停止运行
[03:27/03:41:00]     这个是我们不希望见到的
[03:28/03:41:00]     所以说一般还是要加杠D这个参数的加杠D这个参数的
[03:33/03:41:00]     然后再然后一般还会加什么呢
[03:35/03:41:00]     加这个杠P端口映射
[03:38/03:41:00]     端口映射
[03:39/03:41:00]     因为我们的容器网络它是一个虚拟网络
[03:42/03:41:00]     我们是没有办法跟容器进行进行网络交互的
[03:45/03:41:00]     所以说我们要把当前我们的服务器作为一个跳板那我们要把比如说我们把当前的5004端口映射到容器的八零端口上NG应该是报了八零端口上对吧
[03:59/03:41:00]     然后后面再跟着我们的NG的这个镜像名称
[04:06/03:41:00]     这是我们启动一个容器最简单的一个方式
[04:08/03:41:00]     我们启动之后
[04:09/03:41:00]     理论上
[04:10/03:41:00]     理论上我这边要是访问5004
[04:14/03:41:00]     回车你看这边就会有一个welcome towelcome to in
[04:23/03:41:00]     这个大家都都在录播课里
[04:25/03:41:00]     都已经这个已经这个
[04:29/03:41:00]     数据过了应该是对吧
[04:31/03:41:00]     这我多问一句
[04:32/03:41:00]     大家有没看过录播课的吗
[04:34/03:41:00]     到现在还
[04:36/03:41:00]     如果你这如果有挺多同学都没看过录播课的话
[04:40/03:41:00]     那我就照顾一下
[04:41/03:41:00]     我还是稍微讲一些这些内容
[04:43/03:41:00]     那如果这个大家都看过了
[04:45/03:41:00]     那我就一笔带过了
[04:46/03:41:00]     简单给大家复习一下
[04:47/03:41:00]     一笔带过了好吧
[04:48/03:41:00]     所以说我在这里问一下大家有没看过录播课的
[04:55/03:41:00]     没有好没有看过录
[04:58/03:41:00]     大家都是看过录没看完是吧
[05:00/03:41:00]     你基本命令都看完了
[05:02/03:41:00]     如果就是说你没看完呢
[05:04/03:41:00]     待会实战的时候
[05:05/03:41:00]     实战的时候呢
[05:06/03:41:00]     我会这些那些命令
[05:07/03:41:00]     我都会给大家复习一遍好吧
[05:10/03:41:00]     基本命令能够会的就行好
[05:15/03:41:00]     那这是我们启动一个容器的最常用的使用方式
[05:20/03:41:00]     启动容器还有一些其他的参数
[05:24/03:41:00]     岗位就岗位用来做什么呢
[05:26/03:41:00]     岗位是用来做这个文件挂载的通常用于实现数据的持有化
[05:35/03:41:00]     因为我们都知道
[05:36/03:41:00]     一旦我们把容器删除之后
[05:38/03:41:00]     那么我们容器当中保存的任何数据都会也一定会被删除
[05:42/03:41:00]     所以说它是有数据丢失风险的
[05:44/03:41:00]     所以为了解决这个问题呢
[05:45/03:41:00]     我们是需要把容器中的一些数据保存到我们当前的主机上的
[05:53/03:41:00]     所以说我们采用的是数据的这种方式
[05:55/03:41:00]     其实你可以理解为数据卷就是一种文件的挂载的一种方式
[05:58/03:41:00]     我们把宿主机的某个目录
[06:01/03:41:00]     挂到这个容器的某个目录下
[06:03/03:41:00]     这样容器往这个目录下面去
[06:07/03:41:00]     保存的任何数据其实都是保存在宿主机的这个目录下的
[06:11/03:41:00]     即便这个容器被删除
[06:12/03:41:00]     这些数据也不会消失
[06:13/03:41:00]     所以说这是杠V这个参数的作用
[06:16/03:41:00]     那还有一个是什么呢
[06:18/03:41:00]     还有一个比较常用的是什么呢
[06:19/03:41:00]     杠e
[06:20/03:41:00]     指定环境变量这个
[06:27/03:41:00]     大家在一行命令系列里面
[06:29/03:41:00]     录播课里应该有一行命令系列
[06:31/03:41:00]     大家都已经感受过了
[06:33/03:41:00]     比如说这是一行命令启动in
[06:42/03:41:00]     这块标题我可能写错了
[06:43/03:41:00]     这是启动MYSQL了
[06:44/03:41:00]     还是刚才
[06:45/03:41:00]     是不是我刚才我改PPT的时候给改错了
[06:48/03:41:00]     复制错地了
[06:49/03:41:00]     这是启动MYSQL
[06:50/03:41:00]     大家可以看到杠是用来保存数据的
[06:53/03:41:00]     然后杠易是用来指定环境变量的
[06:56/03:41:00]     这里我再跟大家强调一下
[06:57/03:41:00]     杠易就是说环境变量在容器领域里面是一个很重要的一件事情
[07:02/03:41:00]     它通常是用来传参的
[07:03/03:41:00]     就跟我们在编写代码的时候编写一个函数
[07:07/03:41:00]     我们需要给这个函数定义一些行参
[07:09/03:41:00]     定义一些型材要供用户去调用去指定的那环境变量是也就是其实就是干这个作用的就比如说像我们刚刚才我们现在要做的这个启动这个MYSQL的这个这个指令一样
[07:23/03:41:00]     启动MYSQL的时候
[07:24/03:41:00]     MYSQL里边一定会有入用户和它对应的密码
[07:27/03:41:00]     那在开发这个镜像的时候
[07:30/03:41:00]     就是开发这个镜像的人
[07:32/03:41:00]     他是不可能知道
[07:34/03:41:00]     他是不可能去指定这个密码的
[07:36/03:41:00]     因为这是用户应该用户动态决定的一个行为
[07:39/03:41:00]     用户在启动容器的时候
[07:41/03:41:00]     他应该决定他自己应该用什么样的密码
[07:43/03:41:00]     所以说开发镜像的人往往会约定一些环境变量
[07:49/03:41:00]     约定一些环境变量
[07:50/03:41:00]     就是说我这个密码
[07:52/03:41:00]     假如说我在这里面指定的环境变量是root的密码
[07:54/03:41:00]     这个密码我固定读这个环境变量去读取这个值
[07:58/03:41:00]     然后把这个值作为我们用户的密码
[08:02/03:41:00]     所以说当用户去启动容器的时候
[08:06/03:41:00]     用杠e这个参数
[08:08/03:41:00]     用e这个参数去指定这样的环境变量
[08:11/03:41:00]     那么MYSQL就会读取这个黄金变量
[08:13/03:41:00]     并把这个黄金变量值作为我们root用户的密码
[08:17/03:41:00]     作为我们root用户的密码
[08:18/03:41:00]     这个大家需要知道
[08:22/03:41:00]     杠易是起到传参的一个作用传参的一个作用之后
[08:26/03:41:00]     我们自己去制作镜像的时候
[08:28/03:41:00]     不管你是做什么样的一个镜像
[08:30/03:41:00]     不管是你做了自动化测试的一个镜像
[08:32/03:41:00]     还是说你部署一些测试服务镜像都会大量的用到这个这个环境变量用来传
[08:39/03:41:00]     环境变量去用来传菜
[08:40/03:41:00]     当然它跟do file里面环境变量呢
[08:43/03:41:00]     有一点点的差别
[08:44/03:41:00]     Do file有环境变量一它是在这个制作镜像的时候
[08:48/03:41:00]     它就已经确定了不需要用户里面不需要用户这个去指定
[08:52/03:41:00]     所以说你可以在部分的这个环境变量
[08:55/03:41:00]     你就可以通过do里面直接写的
[08:57/03:41:00]     比如说你是一个Java的镜像
[08:59/03:41:00]     那其实Java你要配置一个Java的环境
[09:01/03:41:00]     需要配置它相应的环境变量嘛
[09:03/03:41:00]     那这个不需要这个用户去指定了
[09:05/03:41:00]     这个不需要用户去指令了
[09:08/03:41:00]     好
[09:09/03:41:00]     这是关于环境变量相关的东西
[09:13/03:41:00]     在一些什么呢
[09:14/03:41:00]     在一些比如说如果你想要去限制这个容器的运行的一些资源
[09:22/03:41:00]     比如说你用杠M可以限制这个容器最多能使用的内存的上限
[09:28/03:41:00]     比如说我指定五百五百一十二兆
[09:31/03:41:00]     还可以设什么呢
[09:32/03:41:00]     杠CP
[09:34/03:41:00]     指定你最多能用的CP的
[09:36/03:41:00]     比如说两个
[09:38/03:41:00]     这都是可以的
[09:41/03:41:00]     那如果你看过录播的话
[09:43/03:41:00]     这个是通过group这个技术
[09:46/03:41:00]     技术是做的这种源的隔离
[09:48/03:41:00]     我们在这个录播里讲过的隔离主要依赖两个机制
[09:53/03:41:00]     第一个是name
[09:54/03:41:00]     Diction space用来做进程通信之间的隔离可见性的隔离
[10:00/03:41:00]     S就是用来做这个资源的隔离资源的隔离
[10:05/03:41:00]     这个录播课里都有
[10:06/03:41:00]     我就不详了不详了
[10:08/03:41:00]     那么我们在启动一个容器的时候
[10:11/03:41:00]     最常用的这些参数就是这些了
[10:15/03:41:00]     就是这些了好吧
[10:20/03:41:00]     那当我们启动容器之后呢
[10:22/03:41:00]     就会用docker PS命令
[10:29/03:41:00]     去查看
[10:32/03:41:00]     我们当前启动的容器
[10:34/03:41:00]     这些都是我之前已经启动好的一些容器
[10:37/03:41:00]     当然这里面有很多KS
[10:38/03:41:00]     因为我在这里面搭建了一个KS机群
[10:41/03:41:00]     这些这些容器都是KS启动
[10:43/03:41:00]     我刚才手动启动的就是这个in
[10:47/03:41:00]     Mind
[10:49/03:41:00]     这里面大家需要知道是什么呢
[10:51/03:41:00]     大家需要知道这个你们去
[10:55/03:41:00]     用一些命令去管理容器的时候
[10:58/03:41:00]     或者查看容器信息的时候
[11:00/03:41:00]     你可以直接使用它的名称
[11:02/03:41:00]     也可以需要使用它的ID
[11:05/03:41:00]     都是可以的
[11:08/03:41:00]     好
[11:09/03:41:00]     当然我们这里面还有一些参数
[11:12/03:41:00]     Dops比如说杠a
[11:14/03:41:00]     它可以干什么呢
[11:15/03:41:00]     它可以把非硬行状态的
[11:18/03:41:00]     比如说这个这些状态的非运行状态的容器也都列出来
[11:23/03:41:00]     因为我们默认只是列出运行状态的
[11:28/03:41:00]     如果你再加一个杠
[11:32/03:41:00]     这个参数一般很少用
[11:34/03:41:00]     但是它比较比较那什么
[11:38/03:41:00]     这个有在有些场景里面比较有用
[11:46/03:41:00]     那但是这个命令确实太慢了
[11:48/03:41:00]     就是它会让你多出一个什么
[11:49/03:41:00]     它会让你多出这么一列
[11:51/03:41:00]     叫什么叫磁盘
[11:57/03:41:00]     这个容器所占的磁盘空间
[11:59/03:41:00]     我们在测试的时候经常会遇到一个预习什么情况呢
[12:05/03:41:00]     比如说某个容器它打日打的太狠了
[12:08/03:41:00]     把资本空间都占满了
[12:09/03:41:00]     那我想知道是哪个容器它最占资空间
[12:13/03:41:00]     我好把这个容器清理掉
[12:14/03:41:00]     那你可以通过加一个杠S这个命令去看一下
[12:19/03:41:00]     去看一下
[12:20/03:41:00]     命有一虚拟
[12:30/03:41:00]     镜像占的空间
[12:31/03:41:00]     前面那个是什么呢
[12:33/03:41:00]     前面是容器启动之后
[12:35/03:41:00]     在在动态的向容器里面保存那些数据所占有的空间
[12:41/03:41:00]     OK
[12:42/03:41:00]     讲到这里大家都没有什么问题吧
[12:45/03:41:00]     有些同学问容器的目录在主机的哪里
[12:48/03:41:00]     怎么查
[12:50/03:41:00]     就是你挂载的目录对吧
[12:51/03:41:00]     这个是查不了的
[12:55/03:41:00]     这个你是查不了
[12:56/03:41:00]     你只能看他的启动命令
[12:57/03:41:00]     去查
[12:59/03:41:00]     你只能不是看它的那个什么
[13:01/03:41:00]     就要看它的那个容器的启动的时候那方面去查
[13:04/03:41:00]     如果是在K8S里你可以查
[13:06/03:41:00]     Kpect这个在故障注入那个那个录播课里边应该讲过这个inspect命令
[13:21/03:41:00]     可以看一下是不是有它的一个
[13:24/03:41:00]     挂载
[13:28/03:41:00]     看看有没有一个叫mount的一个
[13:32/03:41:00]     Month真有
[13:33/03:41:00]     你可能在这里面能找得到
[13:35/03:41:00]     可能啊
[13:36/03:41:00]     你可在这里面可能找得到
[13:38/03:41:00]     你在这个month里边能找到他都挂了哪些东西
[13:41/03:41:00]     那还真有
[13:42/03:41:00]     就inspe大家还记得吗
[13:47/03:41:00]     Inspect
[13:52/03:41:00]     然后不太懂怎么挂载
[13:57/03:41:00]     一行命令系统的挂载
[13:58/03:41:00]     为啥这样挂载
[14:02/03:41:00]     我想怎么给你解释解释
[14:04/03:41:00]     嗯
[14:07/03:41:00]     我给你换一下吧
[14:09/03:41:00]     我打开一个PPT
[14:13/03:41:00]     这还是老的PPT呢
[14:15/03:41:00]     我随便起一页
[14:17/03:41:00]     我给你
[14:18/03:41:00]     我给你们换一下
[14:21/03:41:00]     首先啊
[14:23/03:41:00]     大家明白一件事情
[14:24/03:41:00]     就是说大家如果看过录播课的话
[14:26/03:41:00]     我录播课里边应该有一节是专门讲镜像的原理的
[14:31/03:41:00]     就是那个as
[14:33/03:41:00]     就是联合文件系统
[14:36/03:41:00]     大家还记得吧
[14:40/03:41:00]     容器层是可读可写的
[14:43/03:41:00]     然后那个镜像层是只读的
[14:45/03:41:00]     对吧
[14:46/03:41:00]     所以说
[14:48/03:41:00]     所以说你在容器里面做了任何的更改
[14:53/03:41:00]     比如说你保存了一个什么什么东西
[14:57/03:41:00]     你创建了一个文件
[14:58/03:41:00]     保存了什么什么东西
[14:59/03:41:00]     它是在容器层里面的
[15:01/03:41:00]     但是它是没有办法持久化的
[15:03/03:41:00]     因为什么
[15:04/03:41:00]     镜像层是只读的
[15:10/03:41:00]     它是只读的
[15:14/03:41:00]     所以说你在容器层里面
[15:16/03:41:00]     你在容器里面改了某一个文件
[15:19/03:41:00]     它是不可能直接更改镜像
[15:21/03:41:00]     这个大家都明白吧
[15:22/03:41:00]     镜像是不可能被更改的
[15:23/03:41:00]     对吧
[15:27/03:41:00]     这这这个大家应该能理解
[15:29/03:41:00]     所以说当你的容器被删除之后
[15:33/03:41:00]     你的这个修改的文件必然是不能够什么呢
[15:37/03:41:00]     是能够被保存下来的
[15:40/03:41:00]     所以说你要做一件什么事情
[15:43/03:41:00]     你要做一件什么事情呢
[15:45/03:41:00]     你要把这个目录
[15:48/03:41:00]     假如说这是一个目录
[15:49/03:41:00]     这个目录挂脑袋宿主记的某个目录下
[15:56/03:41:00]     做一个挂载的一个动作
[16:01/03:41:00]     这样说实际上是什么呢
[16:03/03:41:00]     这样实际上就是说你像容器的这个目录下
[16:07/03:41:00]     写的
[16:09/03:41:00]     保存的所有的数据
[16:10/03:41:00]     其实保存在的是四五级的这个目录下了
[16:13/03:41:00]     它跟这个容器中没有什么太大关系了
[16:15/03:41:00]     对吧
[16:17/03:41:00]     这个容器就无法决定这个目录的生死大
[16:22/03:41:00]     这样的话你才能够把数据给持久化下来
[16:26/03:41:00]     你才能够把数据持久化来
[16:27/03:41:00]     但可能有些同学可能这个Linux基础不是特别好
[16:30/03:41:00]     他可能不知道挂载是个什么概念那大家就是装安装硬盘的时候挂载过吗
[16:37/03:41:00]     关安安挂载过磁盘吗
[16:39/03:41:00]     就比如说你你往这个机器上去这个
[16:45/03:41:00]     添加了一块硬盘
[16:46/03:41:00]     然后你要运行一个命令
[16:47/03:41:00]     你要运行一个mount
[16:48/03:41:00]     比如说用这个mount命令
[16:51/03:41:00]     你要把这块磁盘
[16:52/03:41:00]     比如说具体命令我忘了就但是就大家可以给大家写个伪代码嘛
[16:57/03:41:00]     比如说那个asdsda
[17:03/03:41:00]     Sda这块磁盘
[17:04/03:41:00]     然后你要挂在哪呢
[17:06/03:41:00]     比如说你要挂载在home Frank下面的
[17:10/03:41:00]     比如说某一个叫做叫做test的一个目录下
[17:14/03:41:00]     这样的话
[17:15/03:41:00]     你在这个目录下
[17:17/03:41:00]     你往这个目录下保存的任何的数据
[17:20/03:41:00]     其实是保存在这块磁盘上的
[17:25/03:41:00]     这个大家就是这个学过Li基础的
[17:29/03:41:00]     应该知道这个命令
[17:31/03:41:00]     那这个也是类似
[17:33/03:41:00]     也是类似的
[17:35/03:41:00]     我们是把我们是把
[17:38/03:41:00]     主机和容器之间也做了这样一个文件挂载
[17:42/03:41:00]     这样的话
[17:43/03:41:00]     你往容器里面保存的任何数据其实是
[17:47/03:41:00]     保存到了宿主机上的
[17:49/03:41:00]     这个大家能不能否
[17:52/03:41:00]     那没人否
[17:53/03:41:00]     然后手机尾号2192同学问的是运行之后的容器可以修改挂载目录吗
[18:00/03:41:00]     可以
[18:02/03:41:00]     你这个容器已经运行之后了
[18:04/03:41:00]     你就可以修改载目录
[18:15/03:41:00]     还有其他问题吗
[18:18/03:41:00]     针对文件挂载这块
[18:19/03:41:00]     大家还有什么其他的问题吗
[18:26/03:41:00]     好
[18:28/03:41:00]     我接着往下讲
[18:33/03:41:00]     那么能够
[18:36/03:41:00]     我们现在是能够启动容器
[18:38/03:41:00]     也能够查询容器
[18:40/03:41:00]     我们也可以删除容器
[18:41/03:41:00]     一般来说呢
[18:42/03:41:00]     它有几种命令
[18:43/03:41:00]     先stop
[18:44/03:41:00]     然后呢在RM
[18:45/03:41:00]     但一般没人会没人这么用
[18:48/03:41:00]     我们一般都直接RM杠F
[18:50/03:41:00]     强制删除
[18:51/03:41:00]     比如说强制删除MY
[18:56/03:41:00]     那他就被删除了
[19:02/03:41:00]     这是我们单个的
[19:06/03:41:00]     我们单个的启动什么呢
[19:08/03:41:00]     我们启动一个单个容器所需要的
[19:12/03:41:00]     所需要的这个这个这个知识点吧
[19:17/03:41:00]     当然我们可以用某一个东西叫什么
[19:20/03:41:00]     叫compose
[19:25/03:41:00]     叫docker compose
[19:30/03:41:00]     Compose这个大家看过吧
[19:37/03:41:00]     就是录播里应该也看过
[19:38/03:41:00]     就是什么呢
[19:39/03:41:00]     就是说当我们的一个系统
[19:44/03:41:00]     其实它有可能是有很多个容器组成的
[19:48/03:41:00]     对吧
[19:50/03:41:00]     就像我们起一个link一样
[19:51/03:41:00]     那我得先起一个
[19:52/03:41:00]     然后再起一个link
[19:54/03:41:00]     两个器组成
[19:58/03:41:00]     那在我们真正的产品里面可能是更多的
[20:01/03:41:00]     它会有更多的这个容器组成一个系统出来
[20:04/03:41:00]     尤其是微服系统所以呢
[20:07/03:41:00]     如果是这种情况的话
[20:09/03:41:00]     那我还一行一行命令的去写的话
[20:12/03:41:00]     那是一个比较麻烦的一件事
[20:16/03:41:00]     所以说呢
[20:17/03:41:00]     Do出了一个方案
[20:18/03:41:00]     一个它是最原始版本的容器编排
[20:22/03:41:00]     方案
[20:23/03:41:00]     现在用的人不是很多了
[20:25/03:41:00]     因为只有小项目才用这个
[20:27/03:41:00]     很小很小的项目才用这个
[20:31/03:41:00]     就是大项目肯定是用容器集群的
[20:34/03:41:00]     肯定是用KS这种容器变排机群但是DOS呢
[20:38/03:41:00]     现在也其实也是比较受一些小非常小的项目的喜爱
[20:44/03:41:00]     非常小的项目喜爱
[20:45/03:41:00]     也受一些小的一些测试
[20:48/03:41:00]     运维同学的一些喜爱
[20:50/03:41:00]     因为在单个机器里面用端口comp去组织多个容器也是一个比较优雅的一个事情吧
[20:58/03:41:00]     所以说它基本上就是你可以理解为它提供了这样的一个雅某文件
[21:05/03:41:00]     提供了这样一个文件
[21:06/03:41:00]     你可以理解为它是把命令行里面所有的参数全都写到这个文件里面了
[21:13/03:41:00]     比如说我们要启动哪些服务
[21:15/03:41:00]     就是service下面
[21:16/03:41:00]     然后写容器名称叫MYDB镜像环境变量然后下面我再起一个容器link镜像环境变量端口映射
[21:29/03:41:00]     端口映射
[21:30/03:41:00]     然后然后依赖于这个DB
[21:33/03:41:00]     对吧
[21:35/03:41:00]     那我们根据这个东西就可以
[21:41/03:41:00]     通过docker compose
[21:44/03:41:00]     这一个命令
[21:47/03:41:00]     这一个命令我们可以干一件什么事情呢
[21:50/03:41:00]     我们可以比如说up
[21:52/03:41:00]     我就可以把两个
[21:57/03:41:00]     两个
[21:58/03:41:00]     溶剂一块启动起来
[22:01/03:41:00]     大家可以看到
[22:02/03:41:00]     你从这本志你以看到这是DB是提一个一的命
[22:08/03:41:00]     这个统一的命令让文件里面所有的容器
[22:14/03:41:00]     所以说你使用起来会更方便了
[22:17/03:41:00]     就是它没有提供什么更强大的功能
[22:19/03:41:00]     它只是让do coms是让你使用的更方便
[22:23/03:41:00]     只使用的更方便
[22:24/03:41:00]     当我们CTRLC之后
[22:25/03:41:00]     你赶紧给到开始了
[22:26/03:41:00]     然后我们可以用down把它们都删掉
[22:32/03:41:00]     然后我们用up的时成杠D
[22:34/03:41:00]     让它在后台运行
[22:35/03:41:00]     然后docker compose logs杠F去看日志
[22:41/03:41:00]     这两个的日志
[22:43/03:41:00]     这两个日志都是可以的
[22:48/03:41:00]     都是可以的
[22:51/03:41:00]     好
[22:52/03:41:00]     然后我们再那我们用do compose的时候
[22:56/03:41:00]     你完全你也可以看一下它的
[22:58/03:41:00]     日志啊
[22:59/03:41:00]     不是他的那个命令
[23:01/03:41:00]     你可以看到他的这些命运
[23:05/03:41:00]     也没有多少
[23:06/03:41:00]     常用的就那么几个
[23:10/03:41:00]     所以说其实它本身也是一个比较好理解的一件事情
[23:16/03:41:00]     如果说你比如说如果说最常用的up命令
[23:21/03:41:00]     这呢
[23:22/03:41:00]     Up
[23:24/03:41:00]     Up命令就是他把这些所有的容器启动起来
[23:27/03:41:00]     Down命令全都删除
[23:31/03:41:00]     还有stop命令能把它停止
[23:34/03:41:00]     Star命令先把它给
[23:36/03:41:00]     就是把停止的容器来启动起来
[23:41/03:41:00]     Run命令
[23:42/03:41:00]     然后让他跑一个命令
[23:43/03:41:00]     在容器里跑一个命令
[23:46/03:41:00]     那常用的就那么几个
[23:48/03:41:00]     常了这么几个
[23:50/03:41:00]     然后接下来呢
[23:51/03:41:00]     再给大家讲一下几个不是很常用的命令吧
[23:55/03:41:00]     不是很常用命令嘛
[23:56/03:41:00]     就是我可能在录播课里边也没有给大家讲的
[23:59/03:41:00]     比如说docker
[24:03/03:41:00]     应否命令
[24:06/03:41:00]     查看当前的cker的一些信息
[24:13/03:41:00]     通常我用这个命令来干啥呢
[24:15/03:41:00]     是用来看的那什么
[24:16/03:41:00]     用来看它的一个是什么
[24:21/03:41:00]     用来看它的driver
[24:22/03:41:00]     就是比如说它是用的哪种文件系统的驱动
[24:27/03:41:00]     用的哪种文件系统的驱动
[24:29/03:41:00]     用的哪种的CS驱动因为可能我们搭建K8机群的时候
[24:34/03:41:00]     对这些驱动是有一些要求的
[24:36/03:41:00]     然后当然也可以看它运行了多少个容器
[24:39/03:41:00]     你看这里边有62个容器
[24:40/03:41:00]     其中有55个容器是运行状态
[24:43/03:41:00]     有七个容器是关闭状台
[24:47/03:41:00]     然后现当前一共有69个镜像
[24:49/03:41:00]     然后当前docker的版本是二零点一零
[24:52/03:41:00]     代表的是什么呢
[24:53/03:41:00]     代表的是二零年的十暂12号公布出来的
[24:57/03:41:00]     这是的版本号的规则
[24:59/03:41:00]     Do号的规则
[25:00/03:41:00]     然后它的c group driver是什么呢
[25:03/03:41:00]     是c groups
[25:04/03:41:00]     还有另外一个driver是system
[25:07/03:41:00]     不过这个这个大家可以暂时可以不用
[25:09/03:41:00]     不用管它到底是一个什么意思
[25:12/03:41:00]     到底什么意思
[25:13/03:41:00]     这些呢
[25:14/03:41:00]     就是主要是查看它的这个
[25:16/03:41:00]     查看他的这些基本的信息用的
[25:20/03:41:00]     还有一个是什么呢
[25:21/03:41:00]     还有一个是
[25:23/03:41:00]     Do PS
[25:24/03:41:00]     我看找一个容器
[25:28/03:41:00]     Top
[25:43/03:41:00]     容器里面用到的这个进程的ID和相关的信息
[25:50/03:41:00]     这个不太常用
[25:53/03:41:00]     因为这属于监控类的
[25:54/03:41:00]     监控类的很少用的命令去监控
[25:58/03:41:00]     它很少
[25:59/03:41:00]     还有一个命令是什么呢
[26:00/03:41:00]     还有一个命令是能看这个容器的启下来的这个它的这个使用的CPU和内存什么的这都很少用这都很少用
[26:08/03:41:00]     因为真正到企业级里面
[26:11/03:41:00]     你肯定是有对应的系统来看的
[26:12/03:41:00]     没基本上没人会用刀命令去看
[26:16/03:41:00]     所以说我们在录播课里边也没给大家讲
[26:18/03:41:00]     因为这些命令都很不常用
[26:20/03:41:00]     一年到头能用个几次
[26:22/03:41:00]     就是像我这样天天跟容器打交道的
[26:24/03:41:00]     我一年到头也就能用个几次就不错了
[26:28/03:41:00]     所以就没有给大家讲
[26:29/03:41:00]     大家需要的时候现去查询就可以了
[26:32/03:41:00]     好吧
[26:33/03:41:00]     然后再看看讨论区
[26:34/03:41:00]     大家有没有那个
[26:36/03:41:00]     问题运行之后的容器可以修改了
[26:40/03:41:00]     这个刚才回答过了
[26:41/03:41:00]     就是有的运行的双端口是两个端口都可以访问吗
[26:47/03:41:00]     就看你这个端口号是什么
[26:49/03:41:00]     比如说
[26:55/03:41:00]     监控就报了两个端口
[26:56/03:41:00]     一个是8080是外部服务
[26:59/03:41:00]     你访问外部服务
[27:00/03:41:00]     还有一个什么是51000个端口
[27:03/03:41:00]     5万那个端口
[27:04/03:41:00]     那个端口干嘛呢
[27:05/03:41:00]     是它跟slave
[27:06/03:41:00]     就是Jack是可以配slave机器呢
[27:08/03:41:00]     就是重点它跟slave那个通信用的
[27:12/03:41:00]     那个端口你是访问不了的
[27:14/03:41:00]     只有你启动一个16机器的时候
[27:16/03:41:00]     然后通过这个端口跟J通信才可以用
[27:22/03:41:00]     所以说你看你起你想运行的这个服务
[27:25/03:41:00]     你想做多少个端口映射都可以
[27:26/03:41:00]     但是你要看这个端口本身是干嘛的
[27:29/03:41:00]     才能决定你是不是要访问他
[27:31/03:41:00]     好吧
[27:32/03:41:00]     然后国纳是个性能监控的系统吧
[27:36/03:41:00]     错国它不是性能监控系统
[27:39/03:41:00]     光是可视化系统
[27:41/03:41:00]     它可视化
[27:42/03:41:00]     仪表盘系统它是光可视化的
[27:44/03:41:00]     它不管监控
[27:45/03:41:00]     只不过什么呢
[27:46/03:41:00]     真正管监控的
[27:47/03:41:00]     比如说它是普罗米修斯
[27:49/03:41:00]     普罗米修斯才是真正的监控系统
[27:52/03:41:00]     是什么呢
[27:56/03:41:00]     只是把普罗米修斯中的数据做成各种各样可视化的仪表盘的这么一个东西而已
[28:02/03:41:00]     一会儿呢
[28:03/03:41:00]     我会给大家展示一下怎么去用docker去搭建普里修斯和古拉这一套东西
[28:07/03:41:00]     你也不用着急
[28:10/03:41:00]     这是我给大家复复习了一下我们常用的一些命令
[28:14/03:41:00]     到了这儿大家有什么问题吗
[28:28/03:41:00]     没有问题
[28:29/03:41:00]     那我们
[28:32/03:41:00]     给大家留一个课堂作业
[28:35/03:41:00]     留一个课堂作业
[28:36/03:41:00]     因为我根据我经验
[28:37/03:41:00]     肯定有很多同学没有好好的去这个看录播课的
[28:44/03:41:00]     可能有很多同学没有好看的
[28:46/03:41:00]     也没有跟着一个一个敲命令去启动这些东西
[28:51/03:41:00]     我觉得是肯定的
[28:52/03:41:00]     肯定有些东西是这样
[28:53/03:41:00]     所以说我所以说什么呢
[28:55/03:41:00]     所以说
[28:57/03:41:00]     我给大家留个课作业
[28:58/03:41:00]     给大家15分钟时间
[29:00/03:41:00]     15分钟到20分钟时间那
[29:02/03:41:00]     你们现在就把我刚才讲到的这些命令
[29:06/03:41:00]     你们自己手敲一遍
[29:07/03:41:00]     这是第一个
[29:08/03:41:00]     第一个
[29:09/03:41:00]     你自己手敲一遍
[29:10/03:41:00]     自己启动N
[29:12/03:41:00]     启动MY
[29:13/03:41:00]     启动这个link
[29:15/03:41:00]     你们启动一下最好还能什么呢
[29:18/03:41:00]     最好是启动一下
[29:22/03:41:00]     这个PPT你们都有对吧
[29:24/03:41:00]     这里边的命令应该不用我那什么
[29:27/03:41:00]     应该不用我那个再给大家发了
[29:29/03:41:00]     这里都有
[29:30/03:41:00]     你们现在就什么呢
[29:31/03:41:00]     现在就把这东西启动一遍
[29:33/03:41:00]     好吧
[29:35/03:41:00]     给大家15分钟到20分钟时间
[29:37/03:41:00]     大家练习一下
[29:38/03:41:00]     然后这些基础东西你们复习完之后
[29:43/03:41:00]     基础基础东西复习完之后
[29:45/03:41:00]     那么这个
[29:47/03:41:00]     我就会给大家带来一些新的东西
[29:52/03:41:00]     给大家用刀去搭建普罗米修斯那一套东西
[29:55/03:41:00]     好吧
[29:56/03:41:00]     那些不太会写
[29:57/03:41:00]     那我都在PPT里边都可能我是不是PPT里面给大家弄过
[30:04/03:41:00]     连接的就是
[30:06/03:41:00]     这样的大块compose
[30:11/03:41:00]     你照着这个弄吧
[30:12/03:41:00]     你照着这个弄就可以了
[30:14/03:41:00]     当然这个因为这个展示格式的问题
[30:19/03:41:00]     这个大家修改一下这个格式
[30:21/03:41:00]     因为它PPT这个有点bug
[30:23/03:41:00]     它这个PPT软件的bug
[30:25/03:41:00]     所以说你看它展示的有点问题
[30:27/03:41:00]     那大家根据格式改一下就可以了
[30:29/03:41:00]     你照着这个东西你自己改自己启动就可以了
[30:31/03:41:00]     好吧
[30:34/03:41:00]     就do compose这段
[30:38/03:41:00]     大家开始做吧
[30:45/03:41:00]     有任何问题都在讨论区里留言
[31:38/03:41:00]     哈哈
[31:39/03:41:00]     同学说没有提供PPT
[31:41/03:41:00]     老师可以提供一个模板吗
[31:46/03:41:00]     当时我PPT应该都给朱治老师发过了
[31:51/03:41:00]     没有更新吗
[31:56/03:41:00]     一次最多发送
[32:01/03:41:00]     你这样吧
[32:02/03:41:00]     你跟朱老师能要个PPT吗
[32:04/03:41:00]     我应该都发给他们了
[32:05/03:41:00]     都发给朱老师了
[32:09/03:41:00]     或者我把这个放在这你抄
[32:12/03:41:00]     我把画面放在这儿你抄
[42:30/03:41:00]     大家有任何问题记得在讨论区里面留言
[43:25/03:41:00]     老命接后一会儿自己就挂了
[43:30/03:41:00]     你看一下日志呢
[43:31/03:41:00]     用命令为
[45:52/03:41:00]     启动N容器后
[45:53/03:41:00]     外网怎么访问NG
[45:54/03:41:00]     就看你端口映射嘛
[45:55/03:41:00]     对吧
[45:56/03:41:00]     我们刚才讲过这个
[45:58/03:41:00]     当你做完端口映射之后
[46:01/03:41:00]     你需要把这个你端口映射四五机的那个端口
[46:05/03:41:00]     因为我们用docker杠P的时候
[46:07/03:41:00]     Docker run的时候
[46:08/03:41:00]     Docker run然后杠P嘛
[46:12/03:41:00]     主机的端口
[46:13/03:41:00]     然后冒号跟上容器的端口
[46:17/03:41:00]     就是说你访问主机的8080
[46:20/03:41:00]     它就会帮你转发到容器的八零端口上
[46:22/03:41:00]     所以说你在外网用主机的IP加上这个端口号就可以了
[46:27/03:41:00]     能明白吗
[46:32/03:41:00]     郑博燕同学
[47:06/03:41:00]     问不了
[47:06/03:41:00]     你要看一下你的容器是不是的正在启动中
[47:11/03:41:00]     你看一下日志是不是已经报错了
[47:13/03:41:00]     然后你要看一下你的网络
[47:15/03:41:00]     就是如果你像我一样
[47:16/03:41:00]     你像我一样是在阿里云上的
[47:18/03:41:00]     一般会有什么安全组
[47:19/03:41:00]     你要在安全组里把这个对应的端打开
[47:21/03:41:00]     你才能访
[47:23/03:41:00]     你像我现在必须做端口行车的时候
[47:26/03:41:00]     我就不能用8080
[47:27/03:41:00]     因为8080不在那个我现在用的这个云上面的那个安全组里面
[47:31/03:41:00]     所以说我才只能用545450045003这样的
[50:56/03:41:00]     大家怎么样
[50:57/03:41:00]     有成功的了吗
[51:04/03:41:00]     就这套东西
[51:06/03:41:00]     大家有有成功的了吗
[51:42/03:41:00]     没有成功的
[51:45/03:41:00]     一个都没有吗
[51:59/03:41:00]     那再给大家点时间吧
[52:20/03:41:00]     不能发截图应该可以吧
[52:24/03:41:00]     我好像记得以前有同学发过好像是
[58:27/03:41:00]     现在是练习时间练习时间
[58:53/03:41:00]     这样吧
[58:54/03:41:00]     再给大家最后五分钟
[58:55/03:41:00]     因为这个我们要开始讲下面的内容
[59:03/03:41:00]     最后五分钟
[59:04/03:41:00]     大家抓紧时间
[01:06:55/03:41:00]     我们回来吧
[01:06:58/03:41:00]     不等不等了
[01:06:59/03:41:00]     我们不能等了
[01:07:00/03:41:00]     已经给大家差不多半个多小时的时间了
[01:07:02/03:41:00]     那个我接下来讲一个场景
[01:07:05/03:41:00]     我接着再讲一个场景
[01:07:06/03:41:00]     然后在这个场景里面
[01:07:08/03:41:00]     然后大家再实践一下如何用刀块去启动这些服务好吧
[01:07:11/03:41:00]     接场景是什么呢
[01:07:13/03:41:00]     D场景是录播课里没有的
[01:07:16/03:41:00]     是录播里没有的
[01:07:17/03:41:00]     是一个当然当然用的命令都是一样的
[01:07:19/03:41:00]     到时候录播课里那些命令
[01:07:20/03:41:00]     只不说我们现在启动另外一种服务这也是我们在测试当中
[01:07:25/03:41:00]     尤其在性能测试当中比较常用的用户
[01:07:27/03:41:00]     就是监控系统
[01:07:30/03:41:00]     我先给大家介绍一下我们现在要搭建的这个监控监控的这个这个系统的这么一个内容吧
[01:07:38/03:41:00]     先介绍一下我们监控系统名字叫什么呢
[01:07:41/03:41:00]     叫做普罗米修斯
[01:07:43/03:41:00]     叫普罗米修斯
[01:07:45/03:41:00]     它是谷歌开源出来的一个专门就是本意上
[01:07:52/03:41:00]     最擅长的是在这个K8S进行部署
[01:07:55/03:41:00]     并且这个监控K8S里面的这些所有容器
[01:07:59/03:41:00]     还有节点相关状态的
[01:08:01/03:41:00]     那目前普罗米修斯应该算是最流行的一个监控软件了
[01:08:05/03:41:00]     同时它也是KY的监控组件的标准
[01:08:09/03:41:00]     K
[01:08:13/03:41:00]     那本身普米斯它分它的本身的架构是这样的
[01:08:18/03:41:00]     他有一个普罗米修斯的主夫
[01:08:21/03:41:00]     这个主夫呢
[01:08:24/03:41:00]     它
[01:08:26/03:41:00]     并不负责监控
[01:08:28/03:41:00]     他负责什么呢
[01:08:29/03:41:00]     他负责提供用户的查询和
[01:08:34/03:41:00]     监控数据的保存
[01:08:37/03:41:00]     数据存储
[01:08:40/03:41:00]     就它本身就是一个什么呢
[01:08:43/03:41:00]     就是一个实序数据库
[01:08:44/03:41:00]     普米斯本是一个据责
[01:08:48/03:41:00]     控是控
[01:08:55/03:41:00]     是各个的ter
[01:08:58/03:41:00]     比如说什么呢
[01:08:59/03:41:00]     比如说MY
[01:09:01/03:41:00]     如果你这是监控
[01:09:02/03:41:00]     如果监控监控
[01:09:09/03:41:00]     卡啊
[01:09:14/03:41:00]     你可以为是导出控据
[01:09:19/03:41:00]     导者就是这些实际负责监控并收集这些监控的数据
[01:09:24/03:41:00]     然后他把它导出来供这些普米斯
[01:09:27/03:41:00]     的主服进行抓取
[01:09:31/03:41:00]     所以说普罗米修斯的主妇会定时的
[01:09:36/03:41:00]     去进行抓取
[01:09:38/03:41:00]     这个在配置文件里有有进行配置的
[01:09:41/03:41:00]     有进行配置的周老师
[01:09:43/03:41:00]     你要不要帮我开一个
[01:09:44/03:41:00]     那什么
[01:09:45/03:41:00]     帮我开一个课程点
[01:09:46/03:41:00]     朱老师
[01:09:47/03:41:00]     你还在吗
[01:09:49/03:41:00]     我因为这些东西没在那个PPT里面
[01:09:52/03:41:00]     我更新到课程里
[01:09:53/03:41:00]     能帮我你能帮我看一下
[01:09:55/03:41:00]     你帮我看一下好吧
[01:09:58/03:41:00]     这是普罗米修斯的主
[01:10:01/03:41:00]     主呢
[01:10:02/03:41:00]     他我们刚才说的真正负责监控的是这些
[01:10:06/03:41:00]     然后主务呢
[01:10:07/03:41:00]     会默认是一分钟当然你用户可以配置默认是一分钟
[01:10:12/03:41:00]     每一分钟去抓取一次当前的监控数据
[01:10:17/03:41:00]     然后保存到它自己的存储存储设备里面去自己存储设里
[01:10:24/03:41:00]     然后用户用户是
[01:10:27/03:41:00]     并不跟这些进行通
[01:10:29/03:41:00]     这些进行通信
[01:10:32/03:41:00]     他主要是跟谁呢
[01:10:34/03:41:00]     跟普罗米修斯进行通信
[01:10:35/03:41:00]     普罗米修斯提供了一种查询语言
[01:10:40/03:41:00]     叫Pro ql
[01:10:41/03:41:00]     通过这些查询
[01:10:43/03:41:00]     这个查询叫什么
[01:10:44/03:41:00]     叫Pro q r啊
[01:10:46/03:41:00]     一个类circle的查询语言
[01:10:49/03:41:00]     用户就可以通过查询
[01:10:52/03:41:00]     通过这个向这个普里米修斯主服务发送查询请求
[01:10:58/03:41:00]     来去获取这些监控数据
[01:11:01/03:41:00]     所以说总结来说
[01:11:03/03:41:00]     Exp负责监控普罗米修斯的主负责存储
[01:11:06/03:41:00]     把监控数据进行存储那它的用户就是比如说可以是
[01:11:13/03:41:00]     也可以是用户自己
[01:11:15/03:41:00]     可以用户自己
[01:11:16/03:41:00]     古拉纳通过读取普罗米修斯的主夫
[01:11:18/03:41:00]     然后里面的数据
[01:11:20/03:41:00]     然后去展示它的仪表盘
[01:11:22/03:41:00]     展示的表盘那么
[01:11:24/03:41:00]     接下来我们就打这套东西
[01:11:26/03:41:00]     用docker去打这些东西
[01:11:30/03:41:00]     好吧
[01:11:31/03:41:00]     首先我们先来看一下
[01:11:34/03:41:00]     我们先到哪里去找这个
[01:11:41/03:41:00]     它的镜像呢
[01:11:42/03:41:00]     我们可以在这里面
[01:11:51/03:41:00]     你看这里边有很多关于普米修斯相关的东西
[01:11:55/03:41:00]     我们官方就想怎么打标记呢
[01:12:00/03:41:00]     我看一下我用的镜像是哪一个
[01:12:02/03:41:00]     大家稍等
[01:12:22/03:41:00]     大家稍等一下
[01:12:27/03:41:00]     PM普罗米修斯
[01:12:29/03:41:00]     这是它的官方镜像
[01:12:32/03:41:00]     搜一下
[01:12:34/03:41:00]     在这儿呢
[01:12:36/03:41:00]     这些镜这些镜像你都可以到这个叫做PM的这个下面
[01:12:42/03:41:00]     的这个下面
[01:12:44/03:41:00]     比如说这里可到这
[01:12:48/03:41:00]     I
[01:12:56/03:41:00]     就就是这个监控慢的下面还有很多种像DB的
[01:13:07/03:41:00]     还有巴拉巴拉巴拉一堆东西
[01:13:09/03:41:00]     还有他自己的本身的主
[01:13:10/03:41:00]     大家可以到这里面去去去下载下载相关的镜像
[01:13:16/03:41:00]     当然启动是简单的
[01:13:21/03:41:00]     主要的是么
[01:13:22/03:41:00]     主要是配置它的配置文件家可以看
[01:13:26/03:41:00]     这是普罗米修斯的配置文件
[01:13:32/03:41:00]     普罗米修斯的配置文件
[01:13:34/03:41:00]     你需要配置它都要去那个
[01:13:39/03:41:00]     到哪些里面去查询这个监控数据对吧
[01:13:44/03:41:00]     所以说呢
[01:13:46/03:41:00]     这里面主要就要看这个SCS是抓取置面个大家global是置一些全局的参数
[01:13:57/03:41:00]     比如抓取的间
[01:13:59/03:41:00]     我这里配置了每个15秒抓一次
[01:14:03/03:41:00]     我们刚才曾经在这边介绍过
[01:14:05/03:41:00]     就是说它默认是每隔一分钟去
[01:14:07/03:41:00]     抓一次数据的去抓一次数据的
[01:14:10/03:41:00]     每隔一分钟抓一次数据的
[01:14:11/03:41:00]     那这里面可以配置成每隔15秒
[01:14:14/03:41:00]     因为我前一天太慢了
[01:14:16/03:41:00]     一分钟
[01:14:17/03:41:00]     这里大家需要注意的是ter它始终都是反映的当前时刻
[01:14:24/03:41:00]     它的性能参数
[01:14:25/03:41:00]     比如说这里面的no
[01:14:26/03:41:00]     它有一个
[01:14:27/03:41:00]     这里面有一个指标
[01:14:28/03:41:00]     比如说叫CPU load
[01:14:29/03:41:00]     那么就是普罗米修斯的主服务
[01:14:32/03:41:00]     每隔一分钟来抓的时
[01:14:45/03:41:00]     因为这值不值
[01:14:55/03:41:00]     它就反映当前的值
[01:14:57/03:41:00]     这个大家需要记住
[01:14:59/03:41:00]     所以说如果你把这个抓取时间设置的过长
[01:15:02/03:41:00]     比如说你设置成了30分钟
[01:15:04/03:41:00]     那问题就大了
[01:15:05/03:41:00]     因为30分钟好多时间你都抓不到了
[01:15:09/03:41:00]     比如说你其中这三分钟里边有五分钟有一个CPU使用率的一个峰值
[01:15:14/03:41:00]     那你就找不到了
[01:15:16/03:41:00]     所以说如果你的时间太长
[01:15:17/03:41:00]     那好多都是漏掉了
[01:15:32/03:41:00]     这个scru conflict里面
[01:15:33/03:41:00]     然后就置了你具体要哪些数据
[01:15:37/03:41:00]     比如说我们现在要示什么呢
[01:15:38/03:41:00]     我们现在要演示这个no
[01:15:40/03:41:00]     就是监控我们当前教学服务器
[01:15:43/03:41:00]     监控我们当前教学服务器
[01:15:47/03:41:00]     所以说在这配置
[01:15:49/03:41:00]     配置这个xporter IP和地址
[01:15:51/03:41:00]     IP地址和端口号
[01:15:52/03:41:00]     为什么呢
[01:15:53/03:41:00]     因为我们说这个它是标准的架构
[01:15:56/03:41:00]     要主动抓取的
[01:15:58/03:41:00]     普罗米修斯要每隔一分钟去到这些去抓
[01:16:00/03:41:00]     所以说你需要配置什么呢
[01:16:02/03:41:00]     就要到普罗米修斯主里面去配置一下你的这些对应的
[01:16:15/03:41:00]     我们看一下它的启动脚本
[01:16:20/03:41:00]     在这儿呢
[01:16:21/03:41:00]     大家不知道能能看见吗
[01:16:24/03:41:00]     它这种方式比较简单
[01:16:26/03:41:00]     杠杠我放大一点
[01:16:28/03:41:00]     放大一点
[01:16:29/03:41:00]     Do run杠杠name指定它的名称
[01:16:34/03:41:00]     指定它的名称杠D后台运行
[01:16:37/03:41:00]     然后杠P指定它的端口映射
[01:16:40/03:41:00]     因为我们的四主机
[01:16:41/03:41:00]     就是我们是在云上的嘛
[01:16:42/03:41:00]     安全组没开906端口
[01:16:44/03:41:00]     所以说我只能用把四主机的5004端口映射到容器的9090端口上
[01:16:49/03:41:00]     因为普鲁米修斯默认使用的是900端口
[01:16:52/03:41:00]     然后这个操作是什么呢
[01:16:55/03:41:00]     这个操作是把我们的配置文件
[01:16:58/03:41:00]     刚才我们做的这个编写的普罗米修斯的配置文件映射到什么呢
[01:17:02/03:41:00]     挂载到容器的这个路径下面去
[01:17:06/03:41:00]     过到容器的这个录制文件
[01:17:07/03:41:00]     这样的话
[01:17:09/03:41:00]     容器启动的时候才能读取到我们的给它这个配置文件
[01:17:14/03:41:00]     而不是它默认的配置文件
[01:17:15/03:41:00]     这里面大家要注意这个杠V的用法杠的用法就文件挂载的
[01:17:19/03:41:00]     刚才这有同学曾经问过这个问题
[01:17:22/03:41:00]     在杠V里面你是可以用这种形式去运行一个什么呢
[01:17:25/03:41:00]     运行一个shell命令呢
[01:17:28/03:41:00]     比如说PD当前目录
[01:17:30/03:41:00]     这样的话我就用shell命令拼成了这个普米修斯配置文件的地址了径了就个大家这个写法大家可以注意一下
[01:17:39/03:41:00]     可以注意一下
[01:17:40/03:41:00]     因为我们之前都说过
[01:17:41/03:41:00]     有很多参数是通过环境变量的来去进行配置的
[01:17:45/03:41:00]     对吧
[01:17:46/03:41:00]     但是如果环境量太多也很麻烦
[01:17:48/03:41:00]     所以说你最好提供一个配置文件
[01:17:51/03:41:00]     那我们也是可以通过这种配置文件的这种形式文件挂载的形式
[01:17:55/03:41:00]     把配置文件我们事先定义好的配置文件挂载到容器里面去
[01:17:59/03:41:00]     好吧
[01:18:02/03:41:00]     后面这个后面这个杠
[01:18:04/03:41:00]     这我们先不用讲
[01:18:05/03:41:00]     因为这个这是我备课的时候就多实验了一把
[01:18:08/03:41:00]     就是这个配置的一个告警
[01:18:10/03:41:00]     因为监控能监控它也能告警嘛
[01:18:12/03:41:00]     那我们今天先不涉及告警内容今天先不涉及告警内容
[01:18:15/03:41:00]     说后面这个你可以先不用管可以先不用管
[01:18:19/03:41:00]     好吧
[01:18:20/03:41:00]     然后跟着普罗米修斯的镜像
[01:18:24/03:41:00]     那我们把它启动一下start好
[01:18:30/03:41:00]     启动起来
[01:18:32/03:41:00]     当我们启动了之后
[01:18:33/03:41:00]     我刚才映射了端口号是多少来着
[01:18:38/03:41:00]     5004
[01:18:45/03:41:00]     这个就是我们的普罗米修斯的图形界面了
[01:18:51/03:41:00]     图形镜变了
[01:18:52/03:41:00]     当然现在你什么也查不了
[01:18:53/03:41:00]     因为啊
[01:18:54/03:41:00]     现在你还可以查一些port的东西
[01:18:56/03:41:00]     因为我把给启动了
[01:18:58/03:41:00]     所以说在这边你用CP
[01:19:00/03:41:00]     比如说你要
[01:19:04/03:41:00]     我看看no X连接上了没有
[01:19:07/03:41:00]     那连接上了
[01:19:09/03:41:00]     那我就
[01:19:11/03:41:00]     C
[01:19:19/03:41:00]     LOAD15
[01:19:20/03:41:00]     最近15分钟之内
[01:19:21/03:41:00]     15分钟之内的CPU load
[01:19:23/03:41:00]     我们查询一下
[01:19:24/03:41:00]     这这是当前的值
[01:19:27/03:41:00]     如果你想看一个图表
[01:19:30/03:41:00]     你可以点右边的这个
[01:19:33/03:41:00]     因为我们刚启动它可以看到这它的时间还数据很少
[01:19:37/03:41:00]     我们假如说查最近一分钟呢
[01:19:39/03:41:00]     你可以看到这个数据
[01:19:40/03:41:00]     这个曲线图就出来了
[01:19:43/03:41:00]     曲线度就出来了
[01:19:47/03:41:00]     斯的
[01:19:57/03:41:00]     它用docker启动反而会比较麻烦一点
[01:20:01/03:41:00]     所以就没用docker启
[01:20:02/03:41:00]     我直接在这边用二制文件去去启动它就可以了
[01:20:06/03:41:00]     那这个脚本你可以放在就是这个命就是这个
[01:20:09/03:41:00]     你要到哪去下载呢
[01:20:10/03:41:00]     你可以到普罗米修斯的官网上去
[01:20:15/03:41:00]     在这边它的官网
[01:20:18/03:41:00]     他的官网这边呢
[01:20:24/03:41:00]     有个download的
[01:20:26/03:41:00]     Download下面可以看到它有no
[01:20:29/03:41:00]     它有这个a这个MD
[01:20:35/03:41:00]     我看错了
[01:20:36/03:41:00]     这是Mac的
[01:20:38/03:41:00]     这个是Linux的Windows现在是不支持
[01:20:41/03:41:00]     如果现在有同学是用Windows去搭建了刀环境的话
[01:20:47/03:41:00]     你想不是你想你想那个你想要去监控Windows的话
[01:20:51/03:41:00]     那你现在现在是做不到的
[01:20:53/03:41:00]     你是要监控Linux或者是ma
[01:20:57/03:41:00]     就算你是用Windows搭建的docker
[01:20:58/03:41:00]     其实也是在Windows上起了一个虚拟机搭建的docker嘛
[01:21:02/03:41:00]     所以说你们都是可以去实验的
[01:21:04/03:41:00]     都是可以去实验的
[01:21:05/03:41:00]     这只是你你需要找一个Linux系统
[01:21:08/03:41:00]     不管是虚拟机也好
[01:21:09/03:41:00]     还是物理机也好
[01:21:10/03:41:00]     你需要找一个好吧
[01:21:12/03:41:00]     你可以到这里面去查询
[01:21:15/03:41:00]     去下载
[01:21:16/03:41:00]     启动之后就是它启动脚本也就比较简单
[01:21:20/03:41:00]     这个port你可以看到
[01:21:23/03:41:00]     然后指定一个端口号
[01:21:26/03:41:00]     默认它是用9010吧
[01:21:28/03:41:00]     默认是
[01:21:29/03:41:00]     我记得好像是9010
[01:21:31/03:41:00]     默认是9010这个端口
[01:21:32/03:41:00]     但是你也可以通过这个东西
[01:21:33/03:41:00]     你去自己启动自己启动
[01:21:36/03:41:00]     那启动完了之后
[01:21:39/03:41:00]     我们的效果就可以在这里面去看到查询的数据
[01:21:43/03:41:00]     但是这个这个仪表盘很挫
[01:21:44/03:41:00]     对吧
[01:21:45/03:41:00]     对不对所以说呢
[01:21:48/03:41:00]     我们为了能那个提供更好的监控体验
[01:21:51/03:41:00]     我们一定要是有一个更好的可视化的一个系统的普雷米修斯它主要是负责这个数据的这个存储监控数据的存储
[01:22:02/03:41:00]     但是他不擅长可视化
[01:22:04/03:41:00]     所以说可视化的任务呢
[01:22:05/03:41:00]     交给了gra纳普罗米修斯与gra纳社区进行了合作进行了合作
[01:22:10/03:41:00]     所以说我们可以在瓜卡纳里面添加一个普罗米修斯的数据语言
[01:22:15/03:41:00]     去连接到我们自己搭建的这个普里米修斯里面去
[01:22:19/03:41:00]     然后就就可以制作出非常好看的仪表盘出来
[01:22:22/03:41:00]     就我们给大家演示给大家演示一下
[01:22:24/03:41:00]     演示一下
[01:22:25/03:41:00]     那我们在这边就要去启动一个gra纳
[01:22:29/03:41:00]     其中一个gra纳的方式比较简单
[01:22:33/03:41:00]     大家可以看到就就是下载一个gra纳的一个容器就镜像就行了
[01:22:37/03:41:00]     直接把它启动起来就可
[01:22:39/03:41:00]     然后我们把它
[01:22:40/03:41:00]     启动起来
[01:22:42/03:41:00]     启动起来之后
[01:22:43/03:41:00]     我端口映射的应该是50075007
[01:23:01/03:41:00]     好
[01:23:02/03:41:00]     然后默认的用户密码都是in
[01:23:08/03:41:00]     看你重置密码skip掉
[01:23:10/03:41:00]     我先不重置
[01:23:12/03:41:00]     这个启动起来
[01:23:14/03:41:00]     你需要在上面制作自己仪表
[01:23:15/03:41:00]     制作根据普罗米修斯去制作自己仪表盘那
[01:23:19/03:41:00]     你先要让塔去连接到普米修斯上
[01:23:24/03:41:00]     那怎么做呢
[01:23:25/03:41:00]     大家看这个左边的这个齿轮
[01:23:27/03:41:00]     齿轮这有一个data
[01:23:29/03:41:00]     我们点进去添加一个data source
[01:23:32/03:41:00]     然后这里面添加data的类型
[01:23:33/03:41:00]     它有很多种
[01:23:35/03:41:00]     首当其冲的就是普里米修斯
[01:23:37/03:41:00]     它最流行
[01:23:38/03:41:00]     然后电
[01:23:41/03:41:00]     然后这里面你要配置什么呢
[01:23:42/03:41:00]     配置普罗米修斯的IP地址和端口号
[01:23:46/03:41:00]     那我需要先获取一下它的IP地址
[01:23:52/03:41:00]     最好不要域名
[01:23:53/03:41:00]     因为我记得以前在这边用域名好像会出问题
[01:23:58/03:41:00]     所以说保险起见
[01:23:59/03:41:00]     我还是用HTTP
[01:24:02/03:41:00]     然后5004吧
[01:24:05/03:41:00]     我的端口对5004
[01:24:09/03:41:00]     然后配置了IP地址和端口号之后
[01:24:12/03:41:00]     这边有HTTP
[01:24:13/03:41:00]     然后IP端口号之后
[01:24:16/03:41:00]     然后点c test测试一下
[01:24:19/03:41:00]     OK
[01:24:20/03:41:00]     那么这个我们跟普罗米修斯的数据源就已经打通了
[01:24:24/03:41:00]     接下来我们就可以去制作自己的仪表盘
[01:24:26/03:41:00]     当然制作仪表盘是非常麻烦
[01:24:28/03:41:00]     它非常的繁琐
[01:24:30/03:41:00]     你还要去学习Pro Pro q r
[01:24:33/03:41:00]     去定制化各种各样的东西
[01:24:34/03:41:00]     那这里面我给大家介绍一个比较取巧的一个方法
[01:24:38/03:41:00]     就是在gra的这个仪表盘里面
[01:24:41/03:41:00]     就gra社区的官网社区里面
[01:24:43/03:41:00]     然后我们这个它
[01:24:47/03:41:00]     提供了
[01:24:50/03:41:00]     他提供了
[01:24:51/03:41:00]     就是很多人
[01:24:52/03:41:00]     还有很多人就是提供自己的模板
[01:24:54/03:41:00]     Gra卡的模板上来可以供我们使用
[01:24:57/03:41:00]     我们在这个搜索里框里面
[01:24:58/03:41:00]     我们只要输入这个网址
[01:25:00/03:41:00]     然后这边有一个报的报的这个网址
[01:25:03/03:41:00]     我们到了之后呢
[01:25:05/03:41:00]     这边用面选普斯
[01:25:07/03:41:00]     然后在这边去搜一下
[01:25:09/03:41:00]     比如说搜node
[01:25:11/03:41:00]     这边你可以看到这边就有一个很多其他人已经做好的这个noter的这个监控的仪表盘
[01:25:19/03:41:00]     我们随便找一个点进去
[01:25:21/03:41:00]     点那个最多的这个
[01:25:24/03:41:00]     Star最多的这个然后
[01:25:27/03:41:00]     这里面有个copy ID
[01:25:30/03:41:00]     你copy一下或者是download的Jason都可以copy一下
[01:25:34/03:41:00]     回到我们这里面来
[01:25:36/03:41:00]     那然后我们点击这个小加号
[01:25:40/03:41:00]     这里面有个import导入
[01:25:42/03:41:00]     然后在这个框里面
[01:25:44/03:41:00]     在这个输入框里面把我们刚才copy的ID
[01:25:47/03:41:00]     点一下完之后呢
[01:25:49/03:41:00]     它就导进来了
[01:25:51/03:41:00]     你选一个数据源
[01:25:52/03:41:00]     从哪拿拉数据
[01:25:53/03:41:00]     然后import
[01:25:55/03:41:00]     OK
[01:25:57/03:41:00]     这样的话
[01:25:58/03:41:00]     我们当前的一个监控
[01:26:01/03:41:00]     就起来了
[01:26:06/03:41:00]     大家能看到吗
[01:26:09/03:41:00]     可以看到这里面有很多就是这这个老外
[01:26:12/03:41:00]     应该是老外做的
[01:26:13/03:41:00]     他做的还是比较
[01:26:17/03:41:00]     全的
[01:26:19/03:41:00]     还是比较全的
[01:26:20/03:41:00]     当前的状态
[01:26:21/03:41:00]     当前的CPU使用率
[01:26:23/03:41:00]     它的load CPU load五分钟的CP15分钟的CPU load
[01:26:28/03:41:00]     内存的使用
[01:26:32/03:41:00]     交换内存的使用
[01:26:34/03:41:00]     然后这个FS的磁盘空间使用
[01:26:39/03:41:00]     等等等等这些东西下面还有这个内存的详细的波动图
[01:26:44/03:41:00]     我要把时间缩短一点
[01:26:46/03:41:00]     这些图都出来了
[01:26:49/03:41:00]     所以说其实之前讲课的时候
[01:26:51/03:41:00]     因为我们课程改革过嘛
[01:26:53/03:41:00]     之前讲课的时候P一般一般都会有一个噱头
[01:26:57/03:41:00]     就是一个标题
[01:26:59/03:41:00]     五分钟之内搭建一个监控系统
[01:27:01/03:41:00]     怎么就是么
[01:27:06/03:41:00]     就是这么打的
[01:27:08/03:41:00]     叫普米修斯还是非常好用的一个东西
[01:27:10/03:41:00]     所以说我也想借着刀ER的这门课程呢
[01:27:12/03:41:00]     给大家介跟大家介绍一个普米修斯
[01:27:14/03:41:00]     这是基本上就是这个
[01:27:17/03:41:00]     这个性能测试必学的
[01:27:19/03:41:00]     做性能测试同学必学的
[01:27:23/03:41:00]     其实有些时候
[01:27:25/03:41:00]     这个不仅仅是性能测试会用
[01:27:26/03:41:00]     只你做混沌工程你也需要用
[01:27:28/03:41:00]     做稳定性相关的测试你也要用
[01:27:33/03:41:00]     OK
[01:27:34/03:41:00]     大家有不明白的吗
[01:27:40/03:41:00]     主可以分开部署
[01:27:41/03:41:00]     当然可以分部了
[01:27:42/03:41:00]     不在一台机器上是完全正常的
[01:27:54/03:41:00]     同学们老师
[01:27:56/03:41:00]     这个普罗米修斯和如何关联在一起配置文件
[01:28:01/03:41:00]     之前不是给大家看了普罗米修斯的这个配置文件了吗
[01:28:04/03:41:00]     就这了
[01:28:08/03:41:00]     在这里你配置了node的IP地址和端口号了
[01:28:18/03:41:00]     普斯
[01:28:23/03:41:00]     都准确
[01:28:28/03:41:00]     一般没有人用docker的
[01:28:30/03:41:00]     就是用普罗米修斯的
[01:28:31/03:41:00]     因为刀ER能采集的数据非常的有限
[01:28:34/03:41:00]     就那么一两个指标
[01:28:37/03:41:00]     所以一般没人用
[01:28:41/03:41:00]     好吧
[01:28:42/03:41:00]     然后我把刚才这段内容写到课程题里面
[01:28:47/03:41:00]     嗯
[01:28:50/03:41:00]     编辑在哪
[01:28:53/03:41:00]     我我没权限编辑是吗
[01:28:58/03:41:00]     这个老师我是没权限编辑是吗
[01:29:04/03:41:00]     我好像没找到编辑这个按钮
[01:29:11/03:41:00]     那朱老师你帮我看看
[01:29:16/03:41:00]     我们等周老师帮我看看
[01:29:18/03:41:00]     然后这里边给大家答疑一下
[01:29:20/03:41:00]     就大家还有什么问题讲到这儿
[01:29:22/03:41:00]     大家还有什么问题吗
[01:29:43/03:41:00]     就普罗米修斯这一套东西
[01:29:51/03:41:00]     你是都了解的话
[01:29:53/03:41:00]     那么其实
[01:29:57/03:41:00]     让大家去自己尝试一下了
[01:30:01/03:41:00]     自己尝试一下了两个作业
[01:30:04/03:41:00]     第一个作业是什么呢
[01:30:05/03:41:00]     如果郝锦辉同学如果需要搭建性能监控系统
[01:30:10/03:41:00]     正常是在虚拟方便点嘛
[01:30:13/03:41:00]     都差不多
[01:30:17/03:41:00]     你虚拟机上
[01:30:18/03:41:00]     物理机上
[01:30:19/03:41:00]     容器里都行
[01:30:20/03:41:00]     都差不多
[01:30:21/03:41:00]     没什么太大区别
[01:30:22/03:41:00]     然后服务器要怎么配置
[01:30:26/03:41:00]     什么叫被监控的服务器
[01:30:29/03:41:00]     怎么配置配置
[01:30:32/03:41:00]     跟他没关系
[01:30:35/03:41:00]     我没明白你这个问题问的是啥
[01:30:45/03:41:00]     朱老师你把新的链接发到那个讨论区里
[01:30:49/03:41:00]     朱老师你把新链接发到讨论区里
[01:30:54/03:41:00]     就是你给我个链接
[01:30:55/03:41:00]     我我自己创建一个
[01:30:56/03:41:00]     我在哪创建
[01:30:58/03:41:00]     你给我个链接
[01:31:00/03:41:00]     我在哪创建
[01:31:02/03:41:00]     因为你们这个每个系列每个班的子应该在不同的地方吧
[01:31:12/03:41:00]     好
[01:31:15/03:41:00]     我给大家记录一下
[01:31:22/03:41:00]     然后我在这边新建话题
[01:31:24/03:41:00]     Docker实战
[01:31:29/03:41:00]     0925今天是25号吧
[01:31:33/03:41:00]     先随便写点
[01:31:38/03:41:00]     然后还一下
[01:31:43/03:41:00]     他怎么是这个
[01:31:46/03:41:00]     形式
[01:31:47/03:41:00]     普罗米修斯的
[01:31:54/03:41:00]     施展
[01:31:56/03:41:00]     然后普罗米修斯的配置文件
[01:32:06/03:41:00]     这个配置文件
[01:32:11/03:41:00]     这点就够用了
[01:32:14/03:41:00]     那个可以不要
[01:32:20/03:41:00]     普罗米修斯
[01:32:28/03:41:00]     普罗米普罗米修斯的启动米
[01:33:03/03:41:00]     然后gra启动命令
[01:33:06/03:41:00]     这也给你列一下吧
[01:33:23/03:41:00]     然后no exporter的启动命令
[01:33:40/03:41:00]     第二
[01:33:41/03:41:00]     Noportter启动好
[01:33:49/03:41:00]     保存编辑
[01:33:50/03:41:00]     然后把这个发到我们的讨论区里
[01:33:55/03:41:00]     前面画了一个图
[01:33:56/03:41:00]     可以贴一下吗
[01:33:57/03:41:00]     就是这个
[01:34:00/03:41:00]     我这咋截图
[01:34:03/03:41:00]     咱们这个有咱们这个有截图功能
[01:34:12/03:41:00]     没截图吗这个
[01:34:14/03:41:00]     操作
[01:34:18/03:41:00]     这么挫呢
[01:34:24/03:41:00]     课后的时候
[01:34:25/03:41:00]     课后的时候我把这个东西截个图
[01:34:28/03:41:00]     然后那个更新到课程里
[01:34:30/03:41:00]     好吧
[01:34:31/03:41:00]     因为那个我现在没开我我没开微信
[01:34:33/03:41:00]     没开QQ的
[01:34:34/03:41:00]     没有没有接触功能
[01:34:36/03:41:00]     咱们的这个东西好像没有
[01:34:38/03:41:00]     截图的这么个能力
[01:34:41/03:41:00]     咱们这个软件里好吧
[01:34:45/03:41:00]     那这样给他就我把该该那什么的该发的东西都发完了
[01:34:49/03:41:00]     我们留两个作业
[01:34:50/03:41:00]     课堂作业现在大家做第一个是
[01:34:54/03:41:00]     搭建
[01:34:56/03:41:00]     普罗米修斯病
[01:35:01/03:41:00]     监控Linux服务器
[01:35:05/03:41:00]     这第一个作业就是刚才我演示的这一套东西
[01:35:08/03:41:00]     你要配置好盘好吧
[01:35:09/03:41:00]     第二是什么呢
[01:35:10/03:41:00]     第二是搭建MYL服务
[01:35:14/03:41:00]     并使用my circle exportter
[01:35:20/03:41:00]     My circle dter
[01:35:25/03:41:00]     My SQ DX expter
[01:35:27/03:41:00]     进行监控
[01:35:30/03:41:00]     并配置好的仪表盘
[01:35:39/03:41:00]     这第二个作业
[01:35:40/03:41:00]     第二个作业我我希望大家能自己去
[01:35:43/03:41:00]     寻找他的
[01:35:46/03:41:00]     它的这个这个这个这个镜像
[01:35:49/03:41:00]     然后它的这个使用方式
[01:35:52/03:41:00]     大家可以到do里面
[01:35:56/03:41:00]     这里面可以那个我们刚才看到的那个
[01:36:01/03:41:00]     的
[01:36:03/03:41:00]     X
[01:36:05/03:41:00]     Hotter
[01:36:11/03:41:00]     在这儿
[01:36:12/03:41:00]     大家可以到里面去找
[01:36:14/03:41:00]     大家可以到这里面去找
[01:36:16/03:41:00]     你们自己
[01:36:17/03:41:00]     我们在这个之前的录播课里教大家怎么去启动MY了
[01:36:21/03:41:00]     然后你们自己到这里面去看一下MY的怎么动
[01:36:27/03:41:00]     然后怎么配置到普罗米修斯
[01:36:32/03:41:00]     大家开始练习吧
[01:36:33/03:41:00]     有任何问题发到这个我们的讨论区里好吧
[01:38:29/03:41:00]     运行一个上命令嘛
[01:38:30/03:41:00]     就是获取
[01:38:31/03:41:00]     就我刚才不是讲过吗
[01:38:33/03:41:00]     获取当前径下PWD命令嘛
[01:38:36/03:41:00]     PWD不就是获取当前径
[01:38:38/03:41:00]     你不愿意不愿意用
[01:38:40/03:41:00]     我不喜欢用我这个方式
[01:38:42/03:41:00]     你直接指定这个
[01:38:44/03:41:00]     你直接指定这个什么也行
[01:38:46/03:41:00]     指定绝对径也可以
[01:41:19/03:41:00]     大家何问题都在论里留言
[01:41:23/03:41:00]     因为冷触个普斯这个
[01:41:32/03:41:00]     你们可能会会比较懵比较懵
[01:41:38/03:41:00]     如果你们搭建这个的话
[01:41:43/03:41:00]     你们就用我的
[01:41:46/03:41:00]     好吧
[01:41:57/03:41:00]     大家抓紧时间
[01:41:59/03:41:00]     因为我们直播时间有限
[01:42:00/03:41:00]     大家一定要抓紧时间
[01:42:08/03:41:00]     他们发
[01:57:09/03:41:00]     普罗米修斯和操作不会
[01:57:11/03:41:00]     我再给操作一下
[01:57:12/03:41:00]     我再给大家操作一下
[01:57:15/03:41:00]     大家回来一下
[01:57:16/03:41:00]     我给大家操作一下
[01:57:18/03:41:00]     第一步就是我假设你现在普罗米修斯和上就是都已经搭建好了
[01:57:25/03:41:00]     第一步你需要到普罗米修斯
[01:57:27/03:41:00]     我需要到阿纳里面
[01:57:29/03:41:00]     这个小齿轮
[01:57:30/03:41:00]     大家看到这小齿轮了吗
[01:57:31/03:41:00]     齿轮这边有一个data点进去
[01:57:36/03:41:00]     点进去
[01:57:37/03:41:00]     这里面有一个data
[01:57:40/03:41:00]     你要添加一个
[01:57:42/03:41:00]     然后添加数据源的数据源类型
[01:57:44/03:41:00]     你选择普罗米修斯选择普罗米修斯
[01:57:47/03:41:00]     然后在这个URL里面写上普罗米修斯的
[01:57:51/03:41:00]     IP地址和端口号
[01:57:53/03:41:00]     HTTP
[01:57:55/03:41:00]     这IP地址是
[01:58:01/03:41:00]     IP地址是这个
[01:58:02/03:41:00]     然后端口号
[01:58:04/03:41:00]     端口号是你端口映射出来的5004
[01:58:06/03:41:00]     在我这边是5004
[01:58:09/03:41:00]     一是
[01:58:25/03:41:00]     这个网址
[01:58:29/03:41:00]     这个地址
[01:58:35/03:41:00]     这个地址进来
[01:58:39/03:41:00]     你在这边可以搜到相应的模板
[01:58:44/03:41:00]     你在这边有个data
[01:58:45/03:41:00]     你可以选择普米修斯
[01:58:47/03:41:00]     这样能缩缩小一下搜索范围
[01:58:51/03:41:00]     选择普林斯后
[01:58:53/03:41:00]     No no
[01:58:57/03:41:00]     你点进来这边就有他的ID
[01:59:00/03:41:00]     你把ID复制下来
[01:59:01/03:41:00]     复制来之后
[01:59:02/03:41:00]     到这一个m import导导I
[01:59:13/03:41:00]     漏了进来之后这就起名了
[01:59:16/03:41:00]     因为我刚才导入过一次嘛
[01:59:21/03:41:00]     这边让你选你用哪个
[01:59:24/03:41:00]     圆你用哪个
[01:59:25/03:41:00]     你就选你刚才创建那个
[01:59:27/03:41:00]     然后点import就好了
[01:59:32/03:41:00]     能明白否
[01:59:34/03:41:00]     郑博燕同学
[01:59:36/03:41:00]     你听明白了吗
[01:59:43/03:41:00]     Hello
[01:59:44/03:41:00]     你还在吗
[01:59:51/03:41:00]     听明白了
[01:59:52/03:41:00]     操
[01:59:56/03:41:00]     给我个响应
[01:59:57/03:41:00]     你们是记住还是没记住
[01:59:59/03:41:00]     登录的用户名密码都是ad
[02:60:04/03:41:00]     都是ain ainin
[02:61:04/03:41:00]     是还有哪块不清楚的同学及时说
[02:61:07/03:41:00]     就像这个这个郑博燕同学一样
[02:61:10/03:41:00]     你哪不清楚直接说
[02:61:12/03:41:00]     然后我好给你再演示一下
[02:61:15/03:41:00]     进入的时候账号密码明明注册了
[02:61:18/03:41:00]     账号密码你不需要注册的
[02:61:22/03:41:00]     就是你启动好grand之后
[02:61:25/03:41:00]     它默认就是a
[02:61:26/03:41:00]     你不需要注册的
[02:61:27/03:41:00]     你再试试
[02:62:04/03:41:00]     可以的行可以了就可以
[02:62:08/03:41:00]     大家接着继续这段
[02:62:10/03:41:00]     因为这段可能稍微复杂一点
[02:62:11/03:41:00]     我给大家多点时间
[02:62:15/03:41:00]     有任何问题直接问大家这个直播课直接直播课也不多
[02:62:20/03:41:00]     大家有问题可以跟我交流的时候
[02:62:22/03:41:00]     尽量直接就问
[02:62:23/03:41:00]     要不然下课之后你们想要再找我就不是很容易了
[02:63:31/03:41:00]     Gra test个
[02:63:42/03:41:00]     READING500
[02:63:43/03:41:00]     那这个就是接普罗米修斯出了
[02:63:45/03:41:00]     你看一下你的普罗米修斯是不是真的启启动起来了
[02:63:48/03:41:00]     你问一下普罗米修斯的图形界面
[02:63:50/03:41:00]     你看看好吧
[02:63:51/03:41:00]     郑博同学
[02:63:52/03:41:00]     然后哈哈
[02:63:53/03:41:00]     同学问老师
[02:63:55/03:41:00]     复制了no的ID以后在哪复制
[02:63:59/03:41:00]     刚才您的有点忘了在这里
[02:64:01/03:41:00]     这里边左上角这有个小加号吗
[02:64:03/03:41:00]     小加号左上角你看我屏幕有个小加号
[02:64:06/03:41:00]     你要创造仪表盘
[02:64:07/03:41:00]     这里面有个import.import import这边就有一个import
[02:64:14/03:41:00]     Gra拿点com
[02:64:16/03:41:00]     然后你把这ID这然后就可以了
[02:64:19/03:41:00]     你再试试
[02:65:49/03:41:00]     可以你再试试
[02:65:51/03:41:00]     做完忘了
[02:65:54/03:41:00]     第二作业是你们方
[02:66:05/03:41:00]     给启动起来监控一下MY
[02:66:07/03:41:00]     同样在社区里面
[02:66:09/03:41:00]     你也找一下那个MY的这个模板
[02:66:58/03:41:00]     你下载一个
[02:67:04/03:41:00]     能看到我
[02:67:08/03:41:00]     下载一个
[02:67:09/03:41:00]     然后里面就是一个二进制文件
[02:67:11/03:41:00]     然后启动起来就行了
[02:67:13/03:41:00]     你启动启动命令呢
[02:67:14/03:41:00]     其实就在这儿
[02:67:15/03:41:00]     我们刚才列过就这么一条命令
[02:67:17/03:41:00]     你启动起来就行
[02:74:21/03:41:00]     快点回来
[02:77:48/03:41:00]     仪表盘上没有监控数据
[02:77:50/03:41:00]     都是状态
[02:77:51/03:41:00]     那你要看一下你是不是启动起来
[02:77:53/03:41:00]     博同学我给你看一下
[02:77:56/03:41:00]     你看我屏幕
[02:78:07/03:41:00]     你点这个S
[02:78:08/03:41:00]     你能看到这些执状如状起来
[02:78:16/03:41:00]     你看一下
[02:78:17/03:41:00]     很有可能你的配置不对
[02:78:18/03:41:00]     或者说你的exportter没有启动起来
[02:78:21/03:41:00]     你看一下
[02:79:35/03:41:00]     所以说你再看一下你那块为什么没有启动起来
[02:85:23/03:41:00]     有了5005端口防火墙没打开
[02:85:27/03:41:00]     那就对了嘛
[02:85:28/03:41:00]     然后你看接下来你试一下下一个
[02:85:35/03:41:00]     大家试一下下一个
[02:85:39/03:41:00]     其他同学怎么样了
[02:85:49/03:41:00]     买的对
[02:85:50/03:41:00]     他S配好后在干啥
[02:85:53/03:41:00]     在上最终目标是在上
[02:85:56/03:41:00]     你要配置仪表盘的
[02:86:53/03:41:00]     不是giub下载
[02:86:55/03:41:00]     你是在gra社区上下载
[02:86:57/03:41:00]     你百度搜索一下应该就出来了
[02:93:53/03:41:00]     我给大家操作一下你们的练习
[02:93:56/03:41:00]     我给大家操作一下
[02:93:57/03:41:00]     大家回来一下吧
[02:93:58/03:41:00]     大家来一下给大家操作一下这个怎么启动买这个
[02:94:03/03:41:00]     好吧
[02:94:04/03:41:00]     首先稍等一下
[02:94:08/03:41:00]     我喝口水
[02:94:21/03:41:00]     首先呢
[02:94:23/03:41:00]     我们要启动一个买circle的服务
[02:94:26/03:41:00]     对吧
[02:94:27/03:41:00]     我们启动一个买circle的服务
[02:94:29/03:41:00]     那怎么启动呢
[02:94:31/03:41:00]     我们之前讲过了
[02:94:32/03:41:00]     我们这也有一个点SH的一个
[02:94:36/03:41:00]     脚本我们启动一下就好
[02:94:41/03:41:00]     Be my思考SH
[02:94:46/03:41:00]     MY
[02:94:55/03:41:00]     启动这里需要注意是什么
[02:94:58/03:41:00]     大家要看一下我的MYL的脚本里面
[02:95:01/03:41:00]     我的用户的密码是这个
[02:95:05/03:41:00]     然后我端口映射出来的端口是这个50008
[02:95:09/03:41:00]     因为这是需要你在启动买的时候需要配置的参数所以说我们再看一下MYS是怎么启动的
[02:95:20/03:41:00]     它也是一个镜像
[02:95:23/03:41:00]     它也是镜像
[02:95:24/03:41:00]     你可以看到这里面我把它映射成5009
[02:95:28/03:41:00]     待会我去在普罗米修斯里面配置的时候
[02:95:30/03:41:00]     配置的就是五
[02:95:36/03:41:00]     想去监控MY
[02:95:43/03:41:00]     你得告诉他MYQL信息吧
[02:95:45/03:41:00]     IP地址
[02:95:46/03:41:00]     用户名
[02:95:47/03:41:00]     密码这些东西
[02:95:48/03:41:00]     然后才能去发送MY的一些QL语句
[02:95:51/03:41:00]     去查询一些性能指标对不对
[02:95:53/03:41:00]     所以说这里面
[02:95:57/03:41:00]     是一个字符串
[02:95:59/03:41:00]     这个字串是什么呢
[02:96:00/03:41:00]     首先root就密码
[02:96:03/03:41:00]     然后冒号
[02:96:04/03:41:00]     后面跟的是什么呢
[02:96:06/03:41:00]     就用户后面跟密码
[02:96:09/03:41:00]     首先你密码
[02:96:10/03:41:00]     然后符号面跟是什么
[02:96:15/03:41:00]     端口号和IP地址一个括号
[02:96:17/03:41:00]     里边跟着IP地址和端口号
[02:96:20/03:41:00]     再然后跟着是什么呢
[02:96:21/03:41:00]     再然后跟着是一个斜线
[02:96:23/03:41:00]     跟着你要监控哪个数据库
[02:96:24/03:41:00]     就是你要监控哪个库
[02:96:27/03:41:00]     因为它有好多个库嘛
[02:96:28/03:41:00]     好多个库嘛
[02:96:30/03:41:00]     监控哪个库
[02:96:31/03:41:00]     然后面是什么
[02:96:32/03:41:00]     后面跟的是MY的
[02:96:35/03:41:00]     然后我们启起来
[02:96:39/03:41:00]     把它形起来
[02:96:41/03:41:00]     把它起来之后呢
[02:96:42/03:41:00]     你还要注意什么
[02:96:43/03:41:00]     你还要注意你在这边要配置一个买circle的一个本
[02:96:50/03:41:00]     来配置一下MYL的一个配置
[02:96:54/03:41:00]     也是IP加等号
[02:96:56/03:41:00]     大家刚才刚才应注意到了
[02:96:58/03:41:00]     我这边是5009
[02:97:00/03:41:00]     我刚才映射的是5009
[02:97:02/03:41:00]     好吧
[02:97:04/03:41:00]     这些东西都准备好之后
[02:97:06/03:41:00]     我也都启动起来之后
[02:97:07/03:41:00]     然后我就可以到这边刷新一下
[02:97:10/03:41:00]     你看my circlel这边
[02:97:11/03:41:00]     My circlel这边就它也是的康状来的呢
[02:97:26/03:41:00]     就是你在这个置文件里边你了多少
[02:97:28/03:41:00]     这个配了多少个
[02:97:31/03:41:00]     就会在这边显示多少个
[02:97:33/03:41:00]     然后如果它能连接的上
[02:97:35/03:41:00]     它就是up状态
[02:97:36/03:41:00]     如果连接不上
[02:97:38/03:41:00]     它就是down状态
[02:97:39/03:41:00]     这个大家需要注意一下
[02:97:41/03:41:00]     那么
[02:97:43/03:41:00]     MY已经启动起来了
[02:97:45/03:41:00]     也已经跟我们的普罗米修斯接上了
[02:97:49/03:41:00]     接来我们配置的仪表盘
[02:97:51/03:41:00]     根据我们才讲的
[02:97:54/03:41:00]     我们需要到国阿哈达社区里面
[02:97:56/03:41:00]     国阿哈达社区里面去搜一下
[02:98:00/03:41:00]     选择普罗米修斯类型的模板
[02:98:02/03:41:00]     然后so my circle
[02:98:05/03:41:00]     然后这里边有个my circle
[02:98:07/03:41:00]     那我们也就选它了
[02:98:10/03:41:00]     然后点击copy ID to clipboard啊
[02:98:15/03:41:00]     然后回到我们
[02:98:17/03:41:00]     仪表盘里面
[02:98:18/03:41:00]     然后在这边点import import这边我复制进来点load
[02:98:23/03:41:00]     漏了下来之后呢
[02:98:24/03:41:00]     选择我们的一个
[02:98:28/03:41:00]     配置选择我们的普罗米修斯的数据源点import
[02:98:34/03:41:00]     现在是no datadata
[02:98:36/03:41:00]     因为刚启动起来
[02:98:38/03:41:00]     慢慢就有对了
[02:98:39/03:41:00]     你看慢慢就有数据出来了
[02:98:41/03:41:00]     我把它换成五分
[02:98:42/03:41:00]     因为我刚才默认显示12小时
[02:98:43/03:41:00]     12小时你会发现啥也没有
[02:98:46/03:41:00]     啥也没有
[02:98:47/03:41:00]     因为我们刚启动的
[02:98:49/03:41:00]     刚启动的没什么数据
[02:98:50/03:41:00]     你要选择最近五分钟
[02:98:51/03:41:00]     然后它就有数据了
[02:98:54/03:41:00]     他慢慢就有数据了
[02:98:56/03:41:00]     OK
[02:98:57/03:41:00]     大家看看到了吗
[02:98:58/03:41:00]     大家刚才那个流程大家看懂了吗
[02:99:00/03:41:00]     如何监控买
[02:99:04/03:41:00]     大家看懂了吗
[02:99:07/03:41:00]     懂了吗
[02:99:08/03:41:00]     继续
[02:99:09/03:41:00]     因为我怕我不给你们演示一遍
[02:99:11/03:41:00]     你们自己憋憋不出来
[02:99:12/03:41:00]     继续
[02:103:31/03:41:00]     我看一下
[02:103:31/03:41:00]     然后老师启动MY的待会命令发一下
[02:103:37/03:41:00]     这个忘给你们发了是吧
[02:103:43/03:41:00]     Myporter
[02:103:45/03:41:00]     在这
[02:103:50/03:41:00]     稍等一下稍等一下稍等一下稍等一下
[02:103:54/03:41:00]     这
[02:104:00/03:41:00]     然后
[02:104:03/03:41:00]     编辑帖子
[02:104:05/03:41:00]     My circle
[02:104:11/03:41:00]     Exporter
[02:104:20/03:41:00]     也在课程体验里吧
[02:104:21/03:41:00]     大家自己去拿这位同学搭建好了哈lix监控
[02:104:27/03:41:00]     OK
[02:104:28/03:41:00]     好的
[02:104:30/03:41:00]     然后给大家推荐一个
[02:104:31/03:41:00]     那什么给大家推荐一个上有一个教普罗米修斯的一本书
[02:104:36/03:41:00]     就是有一个人自己总也不是说吧
[02:104:38/03:41:00]     自己总结了一个文档
[02:104:49/03:41:00]     我当初是这个文档的
[02:104:52/03:41:00]     普罗米修斯操作指南
[02:104:54/03:41:00]     中文的是一个中国人写的
[02:104:56/03:41:00]     这挺好的
[02:104:58/03:41:00]     安装
[02:105:05/03:41:00]     你们可以自己去看一下
[02:105:08/03:41:00]     如果你要自己要定制化一些东西的时候
[02:105:10/03:41:00]     会学会这些还是挺好的
[02:105:13/03:41:00]     然后等等等等这些东西
[02:105:15/03:41:00]     这个推荐给你们看
[02:105:17/03:41:00]     推荐给你们看
[02:105:18/03:41:00]     我写课程里面这个地址
[02:105:21/03:41:00]     嗯
[02:105:24/03:41:00]     其实你出去面试的时候
[02:105:26/03:41:00]     你普罗米修斯很熟的话
[02:105:28/03:41:00]     其实是个加分项
[02:105:31/03:41:00]     是个加分项
[02:105:40/03:41:00]     好
[02:105:43/03:41:00]     大家继续吧
[02:119:41/03:41:00]     MYSQL已经up状态了
[02:119:43/03:41:00]     还是没有显示数据
[02:119:49/03:41:00]     你这么排查一下
[02:119:52/03:41:00]     首先你把这个时间调整一下
[02:119:56/03:41:00]     调整一下调整五分钟
[02:119:58/03:41:00]     最近五分钟
[03:120:00/03:41:00]     然后再一个是你看一下你的你的这个
[03:120:07/03:41:00]     Data数据源
[03:120:10/03:41:00]     你这边测试一下
[03:120:11/03:41:00]     测试一下看看是不是联通状态
[03:120:14/03:41:00]     然后再查一下你去搜的这个MY是普罗米修斯作为
[03:120:24/03:41:00]     你这边都一般都会有data会告诉你是普罗米修斯
[03:120:37/03:41:00]     你看一下
[03:120:38/03:41:00]     显示是我这边应该也有data的东西吧
[03:120:50/03:41:00]     你看我这边也有一个的一个东西
[03:120:56/03:41:00]     是属于正常的
[03:120:57/03:41:00]     因为这个可能MYSQL
[03:120:58/03:41:00]     我我这个用默认配置启动的
[03:121:00/03:41:00]     并没有配置这个东西
[03:121:02/03:41:00]     所以说它可能是no data
[03:121:04/03:41:00]     又或者说一开始他是no data没有数据的
[03:121:07/03:41:00]     但是可能你让他跑一会
[03:121:10/03:41:00]     他就他就有了
[03:121:11/03:41:00]     但但是理论上应该是大部分都是有数据的
[03:121:15/03:41:00]     如果你大部分是没数据的
[03:121:16/03:41:00]     那是有问题的
[03:121:17/03:41:00]     可能是你对应的L的版本
[03:121:20/03:41:00]     有问题或者是怎么样的
[03:121:36/03:41:00]     有多少同学已经成功了
[03:121:37/03:41:00]     我看一下有多少同学成功了
[03:121:39/03:41:00]     成功就打个一
[03:121:40/03:41:00]     我看一下大家成功率是怎么样
[03:121:56/03:41:00]     没有人成功
[03:121:57/03:41:00]     刚才不是有启来了
[03:122:31/03:41:00]     那这样再给你们点时间吧
[03:122:33/03:41:00]     那个后面内容我等会再讲
[03:122:35/03:41:00]     再给你点时间
[03:122:36/03:41:00]     你们抓紧时间接着实战
[03:126:46/03:41:00]     如何查看自己安装的MYSQL镜像的版本
[03:126:51/03:41:00]     看版本号
[03:126:53/03:41:00]     Do images命令
[03:126:55/03:41:00]     然后grape my
[03:126:59/03:41:00]     你看一下你的镜像版本号多少在这吗
[03:127:02/03:41:00]     我用的是5.5的这个版本
[03:127:06/03:41:00]     这很容易看的
[03:131:43/03:41:00]     这样吧
[03:131:44/03:41:00]     因为我还有最后一点内容没有讲完
[03:131:47/03:41:00]     因为我我们离下课时间越来越近了
[03:131:49/03:41:00]     那个我们不等不等不等大家继续间了
[03:131:52/03:41:00]     大家有空的话
[03:131:54/03:41:00]     我们回去自己练习一下
[03:131:57/03:41:00]     然后我们上下节课的时候呢
[03:131:59/03:41:00]     如果遇到任何问题呢
[03:132:00/03:41:00]     下节课时候可以跟我聊
[03:132:02/03:41:00]     再跟我问好吧
[03:132:03/03:41:00]     然后我们还有最后一块内容
[03:132:05/03:41:00]     最后一块内容其实我们在录播课中有涉及到
[03:132:10/03:41:00]     但是我想现在在这边给大家再一遍
[03:132:15/03:41:00]     再穿一遍
[03:132:16/03:41:00]     因为录录播课里边应该讲的不是很细来
[03:132:21/03:41:00]     在录播课里面
[03:132:25/03:41:00]     我给大家讲过名生空间对吧
[03:132:27/03:41:00]     大家都看过民生空间那那那那那两节课对不对
[03:132:32/03:41:00]     民生空间和故障注入那那几节课都看过对吧
[03:132:35/03:41:00]     有没有没看过的
[03:132:46/03:41:00]     那我不管看没看过了
[03:132:47/03:41:00]     我就先简单给大家复习一下
[03:132:49/03:41:00]     什么是link的民生空间
[03:132:51/03:41:00]     在link的民空间
[03:132:53/03:41:00]     它是主要是用来做进程间隔离的
[03:132:56/03:41:00]     这个我在讲录播课的时候讲过
[03:132:57/03:41:00]     你可以把进程看成是对讲机
[03:133:00/03:41:00]     小时候我们玩过的对讲机
[03:133:03/03:41:00]     那玩对讲机的时候我们都知道
[03:133:05/03:41:00]     要把两个对讲机调调整到同一个频道上
[03:133:08/03:41:00]     这两对讲机才能够通话
[03:133:09/03:41:00]     对吧
[03:133:10/03:41:00]     所以说民声空间也是这样
[03:133:12/03:41:00]     我们可以把
[03:133:13/03:41:00]     进程想象成对讲机
[03:133:16/03:41:00]     然后把名称空间想象成频道
[03:133:20/03:41:00]     两个进程之间
[03:133:21/03:41:00]     不论他想做网络上的还是进程间的这种交互
[03:133:26/03:41:00]     那他都得要在同一个频道里面
[03:133:28/03:41:00]     也就是说在同一个namespace里面
[03:133:31/03:41:00]     这就是Li的名生空间
[03:133:34/03:41:00]     Docker呢
[03:133:36/03:41:00]     之所以说我们进入到一个容器里面
[03:133:39/03:41:00]     我们看不到其他的容器的东西
[03:133:41/03:41:00]     看不到其他容器的进程
[03:133:43/03:41:00]     看不到其他容器的网络设备
[03:133:45/03:41:00]     这个容器之间是互相隔离的
[03:133:48/03:41:00]     就是因为什么呢
[03:133:49/03:41:00]     就因为在启动这些容器的时候
[03:133:51/03:41:00]     其实干了一件什么事呢
[03:133:54/03:41:00]     它就是启动了一个进程
[03:133:55/03:41:00]     然后针对这个进程创建了独立的名空间而已
[03:133:59/03:41:00]     穿这独立名称空间而已
[03:134:00/03:41:00]     所以说我们在宿主机上
[03:134:02/03:41:00]     你看不到这些进这些容器里面里面的一些网络设备什么的
[03:134:06/03:41:00]     我们在容器也看不到其他的容器的网络设备就是因为我们是分配在不同的名声空间里的然后
[03:134:18/03:41:00]     然后我们假设启动了两个容器
[03:134:22/03:41:00]     一个是a容器
[03:134:23/03:41:00]     一个是B容器
[03:134:24/03:41:00]     那他们两个网络是隔离了
[03:134:28/03:41:00]     因为他们有不同的网络民生空间
[03:134:30/03:41:00]     A容器有自己的网络民生空间
[03:134:31/03:41:00]     B容器也有自己的网络民生空间
[03:134:34/03:41:00]     他们是互相隔离了
[03:134:35/03:41:00]     但是呢
[03:134:38/03:41:00]     他们也要通信对他他隔既要既有隔离需求
[03:134:41/03:41:00]     它也有通信需求
[03:134:42/03:41:00]     对吧
[03:134:44/03:41:00]     互相看不见
[03:134:45/03:41:00]     但是他我们仍然希望能通过IP等方式去进行通信
[03:134:48/03:41:00]     对不对
[03:134:49/03:41:00]     所以说为了穿透这个网络民生空间的限制
[03:134:55/03:41:00]     Linux Linux还提供了一种网络设备叫虚拟网卡
[03:135:02/03:41:00]     叫虚拟网卡
[03:135:03/03:41:00]     虚拟网卡的特点是什么呢
[03:135:04/03:41:00]     它是成对出现
[03:135:07/03:41:00]     它是成对出现的
[03:135:08/03:41:00]     一出现就是一对
[03:135:09/03:41:00]     并且它有一个特性是什么
[03:135:11/03:41:00]     第一个特性是你像任何一块网卡
[03:135:18/03:41:00]     像任何一块网卡发送一段网络报文
[03:135:20/03:41:00]     它都会无条件的转发到另外一块网卡上
[03:135:24/03:41:00]     这是它的第一特性
[03:135:25/03:41:00]     第二特性是什么呢
[03:135:26/03:41:00]     第二特性是这种
[03:135:28/03:41:00]     网络传输就它和它的这个成对数的另一个进行通信的时候
[03:135:33/03:41:00]     是可以穿透网络名称空间的
[03:135:37/03:41:00]     所以说
[03:135:38/03:41:00]     我们把这一对网卡中的一个
[03:135:40/03:41:00]     一块放到a容器里面
[03:135:42/03:41:00]     另一块放到B容器里面
[03:135:45/03:41:00]     那他们就能进行网络通信了a容器的进程只需要往这块网卡里面发送网络报文
[03:135:52/03:41:00]     它就会无条件的转发到另外一块网卡上
[03:135:54/03:41:00]     并且可以穿透网络民生空间所以说假如说我们要有一个C容器怎么办
[03:136:02/03:41:00]     C容器
[03:136:03/03:41:00]     如果说B容器想要跟C容器
[03:136:05/03:41:00]     那我们就再创建一块一对网卡
[03:136:09/03:41:00]     让他们通信
[03:136:10/03:41:00]     那a容器要跟C容器通信呢
[03:136:12/03:41:00]     也一样要创建一对
[03:136:14/03:41:00]     因为他们是成对出现的
[03:136:16/03:41:00]     必须是一对一对的这个样子进行通信
[03:136:18/03:41:00]     那这个样子的通信方式肯定不是非常好的
[03:136:22/03:41:00]     因为我们的容器越多
[03:136:23/03:41:00]     我们网卡就越多
[03:136:24/03:41:00]     我们要创建的网卡就呈现一种爆炸的形态进行增长
[03:136:30/03:41:00]     所以说为了解决这个问题
[03:136:33/03:41:00]     为了解决这个问题
[03:136:34/03:41:00]     大家注意听
[03:136:35/03:41:00]     这个很关键的部分内容
[03:136:38/03:41:00]     这是涉及到docker的一个原理
[03:136:44/03:41:00]     为了解决这个问题
[03:136:46/03:41:00]     Linux啊
[03:136:48/03:41:00]     Docker利用了Linux的一个特性
[03:136:51/03:41:00]     叫网桥
[03:136:54/03:41:00]     那这回我们把一对网卡
[03:136:58/03:41:00]     分别放到网上了
[03:137:01/03:41:00]     一块放到容器里
[03:137:02/03:41:00]     一块放到网
[03:137:04/03:41:00]     那通过这种形式
[03:137:07/03:41:00]     我们就可以组建一个内部的局域网络了
[03:137:11/03:41:00]     虚拟的局域网络
[03:137:17/03:41:00]     对吧
[03:137:18/03:41:00]     这就是docker自己组建
[03:137:20/03:41:00]     通过一个网桥组建了自己的o类网络
[03:137:23/03:41:00]     它是一个虚拟的局域网络
[03:137:27/03:41:00]     虚拟的局域网络
[03:137:28/03:41:00]     它的IP地址就是docker启动时会自动的给容器分配一个IP地址
[03:137:34/03:41:00]     但它这个IP地址是虚拟的
[03:137:36/03:41:00]     它是不进入由表的
[03:137:38/03:41:00]     所以说我们在外界是没有办法跟容器进行网络通信的
[03:137:42/03:41:00]     如果要跟容器进行通信的话
[03:137:44/03:41:00]     那就需要做端口映射
[03:137:46/03:41:00]     我们刚才都知道了
[03:137:47/03:41:00]     需要做端口映射
[03:137:51/03:41:00]     那端口映射干了一件什么事呢
[03:137:54/03:41:00]     实际上就是拿四主机当跳板
[03:137:58/03:41:00]     我们呢把网络请求发送到四五机的这块网卡上
[03:138:04/03:41:00]     ET0发送到四五机的这块网卡上
[03:138:08/03:41:00]     然后四主机
[03:138:09/03:41:00]     再转发到DOCKER0上
[03:138:11/03:41:00]     这样的话就可以容器网络进行通信
[03:138:14/03:41:00]     所以说你安装docker的时候
[03:138:17/03:41:00]     文档里都会要求你检查什么呢
[03:138:22/03:41:00]     For这个参数
[03:138:29/03:41:00]     因为什么呢
[03:138:30/03:41:00]     因为按照正常的网络流转
[03:138:32/03:41:00]     一个网络报文发送到一台机机器上
[03:138:34/03:41:00]     这台机器会把这个网络报文拆开
[03:138:36/03:41:00]     拿到它的目的IP地址
[03:138:38/03:41:00]     发现目的IP地址如果不是自己的IP地址
[03:138:42/03:41:00]     它就会直接丢弃掉
[03:138:45/03:41:00]     它不会转发
[03:138:46/03:41:00]     它会直接丢弃掉
[03:138:48/03:41:00]     只有他开启了IPV4FORWARD和IPV6FORWARD之后
[03:138:53/03:41:00]     他才能够把对他他自己有了一个路由的一个一个能力
[03:138:57/03:41:00]     然后他才会把对应的网络报文往其他的网络进行转发所以说大家安装do号的时候一定要注意什么
[03:139:06/03:41:00]     检查这个这个内核参数是否设置对了
[03:139:12/03:41:00]     所以说在这样的一个情况下
[03:139:14/03:41:00]     我们用docker run的时候
[03:139:17/03:41:00]     然后杠P
[03:139:18/03:41:00]     比如说8080到8080
[03:139:20/03:41:00]     就是说把宿主机的8080端口映射到容器的8080端口
[03:139:26/03:41:00]     一个网络报文发下来
[03:139:28/03:41:00]     发现命中了这条规则
[03:139:29/03:41:00]     就是八零发送到了四五局的8080端口上了
[03:139:33/03:41:00]     然后他才会转发给谁呢
[03:139:35/03:41:00]     转发给容器网络
[03:139:37/03:41:00]     至于这个背后的原理是什么呢
[03:139:39/03:41:00]     背后的原理是IP tables
[03:139:41/03:41:00]     我们任何运行任何一个docker run命令
[03:139:43/03:41:00]     一旦加了杠P这个参数
[03:139:46/03:41:00]     指定了端口运输规则
[03:139:48/03:41:00]     它的背后都会加加上若干条IP tables的IP tables的指令
[03:139:56/03:41:00]     那什么是IP tables呢
[03:139:58/03:41:00]     大家可以把它理解为它是一个可以操控内核网络的一个命令
[03:140:08/03:41:00]     一个命令
[03:140:09/03:41:00]     听过的同学应该应该都知道IPS5
[03:140:14/03:41:00]     五条链
[03:140:15/03:41:00]     四张表分别负责不同的功能
[03:140:18/03:41:00]     存储不同的功能
[03:140:19/03:41:00]     然后呢
[03:140:20/03:41:00]     五条链呢
[03:140:21/03:41:00]     代表着网络请求的五个钩子
[03:140:24/03:41:00]     就是五个五个生网络
[03:140:26/03:41:00]     一个一个网络报文在这台机器上流转的一个生命周期的五个阶段
[03:140:32/03:41:00]     就是4.5链中的五链
[03:140:33/03:41:00]     那这个五链分别代表什么呢
[03:140:37/03:41:00]     我看看我还有没有这个图了
[03:140:50/03:41:00]     代表什么呢
[03:140:54/03:41:00]     它是哪五条链呢
[03:140:56/03:41:00]     分别是
[03:141:00/03:41:00]     Input
[03:141:07/03:41:00]     Input代表输入
[03:141:08/03:41:00]     Output output代表输出
[03:141:16/03:41:00]     还有一个什么呢
[03:141:18/03:41:00]     代表由
[03:141:21/03:41:00]     就是说网络报文到达一些机器
[03:141:23/03:41:00]     一定有一个由前的
[03:141:25/03:41:00]     然后还有由前
[03:141:26/03:41:00]     所以最后有一个
[03:141:28/03:41:00]     Post
[03:141:32/03:41:00]     Root
[03:141:34/03:41:00]     然后还有一个什么呢
[03:141:35/03:41:00]     还有一个forward
[03:141:37/03:41:00]     转发
[03:141:40/03:41:00]     我们刚才说
[03:141:43/03:41:00]     到45G这边就会转发嘛
[03:141:45/03:41:00]     转发到容器网络里
[03:141:46/03:41:00]     所以说它要走这条链
[03:141:48/03:41:00]     它代表什么
[03:141:50/03:41:00]     这四表五料中的五料
[03:141:51/03:41:00]     代表了一个网络报文在这台机器上的生命周期的五个阶段一个网络报文首先进来之后
[03:141:58/03:41:00]     先会进入pre链路由前这个链
[03:142:02/03:41:00]     如果这个网络报文拆开之后
[03:142:07/03:41:00]     发现目标IP地址是自己
[03:142:08/03:41:00]     那它就会流入到input链里边
[03:142:10/03:41:00]     通过输入流
[03:142:11/03:41:00]     然后进入进程
[03:142:12/03:41:00]     进程处理完之后
[03:142:13/03:41:00]     假设说他要回复网络请求
[03:142:15/03:41:00]     就会走到output链
[03:142:16/03:41:00]     就是输出流
[03:142:17/03:41:00]     然后呢
[03:142:18/03:41:00]     再走post入
[03:142:19/03:41:00]     就是由后
[03:142:20/03:41:00]     那如果他发现这个机器发现这不是发送给自己的网络包文
[03:142:26/03:41:00]     那就根据那个IPV4的那个参数
[03:142:29/03:41:00]     如果那个配置的那个参数就会转到这条链上
[03:142:33/03:41:00]     如果没配置那个参数就直接丢掉
[03:142:35/03:41:00]     这个就做
[03:142:36/03:41:00]     而IP tables命令就可以操控这网络报文
[03:142:40/03:41:00]     在这五个生命周期阶段里面去篡改他的网络请求篡改的网络请求
[03:142:48/03:41:00]     比如说一般来说
[03:142:49/03:41:00]     它可能在pollution这个链上制定一条规则
[03:142:52/03:41:00]     什么规则呢
[03:142:53/03:41:00]     凡是
[03:142:58/03:41:00]     凡是发送到本机的
[03:143:00/03:41:00]     就是自主机的8080端口的网络请求
[03:143:03/03:41:00]     都把它包拆开
[03:143:05/03:41:00]     篡改它的目击地址
[03:143:07/03:41:00]     篡改成什么的地址
[03:143:08/03:41:00]     篡改成容器的IP地址
[03:143:10/03:41:00]     和端口号
[03:143:16/03:41:00]     篡改成容器IP值和端口号
[03:143:19/03:41:00]     那这个样子
[03:143:24/03:41:00]     这个报文我们向容器网络发送
[03:143:26/03:41:00]     这个报文其实我们是往那个45G的8080多号发的
[03:143:29/03:41:00]     这样的话呢
[03:143:30/03:41:00]     它就它就会被通过服务的这条链转发到了容器网络上
[03:143:37/03:41:00]     这就是它的一个背后的一个原理
[03:143:39/03:41:00]     这也是为什么我们一定要用端口映射去做网络请求的原因网络请求的原因
[03:143:46/03:41:00]     而通过这个机制
[03:143:48/03:41:00]     同学我们知道
[03:143:50/03:41:00]     其他的我们这个刀ER有三种网络模式
[03:143:55/03:41:00]     录播克里都有
[03:143:56/03:41:00]     这个就是桥接模式的原理
[03:144:02/03:41:00]     大家看过那个录播课了吧
[03:144:07/03:41:00]     都看过吧
[03:144:09/03:41:00]     网络模式的
[03:144:10/03:41:00]     那那那三种网络模式是怎么回事
[03:144:12/03:41:00]     这个就是模式
[03:144:15/03:41:00]     这个就是调节模式
[03:144:17/03:41:00]     然后这个IPS我希望大家也去这个好的去好的了解一下
[03:144:24/03:41:00]     对于我们也重要的对于我们理解器网络以后
[03:144:28/03:41:00]     我们要去这个去看这个K8S的时候
[03:144:31/03:41:00]     然后K8S里面有做好多东西也是通过IPS去做的
[03:144:37/03:41:00]     然后之所以跟你讲这个之后讲这个原理
[03:144:41/03:41:00]     讲这个原理是要引申出什么的
[03:144:43/03:41:00]     引出我们网络民生空间
[03:144:45/03:41:00]     你可以看到调节模式是通过这种形式在隔离的情况下还能进行通信的
[03:144:50/03:41:00]     那后网络模式呢
[03:144:51/03:41:00]     我们都知道
[03:144:52/03:41:00]     就是其实就是启动一个容器
[03:144:54/03:41:00]     让它的网络空间民生空间使用四主机的网络民生空间
[03:145:00/03:41:00]     Content模式是什么呢
[03:145:01/03:41:00]     启动一个容器之后
[03:145:03/03:41:00]     使用另外一个容器的网络名称空间
[03:145:07/03:41:00]     另外一个容器的网络名称空间
[03:145:13/03:41:00]     由此我们可以知道
[03:145:14/03:41:00]     其实在当中就是在容器里面有很多的技术是
[03:145:20/03:41:00]     民生空间有关系的
[03:145:22/03:41:00]     我们后面有很多的开发
[03:145:23/03:41:00]     很多的测试工具
[03:145:25/03:41:00]     都是跟网络民生有关系的
[03:145:27/03:41:00]     我们要不停的切换农空间
[03:145:30/03:41:00]     不停的打破它的隔离边界
[03:145:31/03:41:00]     因为
[03:145:32/03:41:00]     Docker这种形式有一个特点
[03:145:34/03:41:00]     它跟虚拟机不一样
[03:145:35/03:41:00]     虚拟机是虚拟化了自己独立的内核
[03:145:37/03:41:00]     所以说它的隔离是硬隔离
[03:145:39/03:41:00]     你玩不出太大的花样来
[03:145:41/03:41:00]     而docker这名间隔式为因名间
[03:145:49/03:41:00]     也不是说可以随时切换嘛
[03:145:51/03:41:00]     就是说民生空间这个东西你是可以
[03:145:55/03:41:00]     通根据用户自己的意愿
[03:145:57/03:41:00]     工资可以意愿可以切换到不同的名称空间里的
[03:146:00/03:41:00]     比如说模式里面
[03:146:04/03:41:00]     Content模式里面我们可以启动一个容器
[03:146:07/03:41:00]     然后使用另外一个容器的网络名称空间
[03:146:10/03:41:00]     然后让这两个容器之间互相配合
[03:146:12/03:41:00]     虽然他们隶属两个容器
[03:146:13/03:41:00]     但他们网络是相通的
[03:146:15/03:41:00]     都是可以通过localhost互相访问的
[03:146:18/03:41:00]     所以说contain模式里
[03:146:19/03:41:00]     它它非常好用的一点是什么
[03:146:22/03:41:00]     假设说假设说你有111套系统
[03:146:26/03:41:00]     它是有五个容器
[03:146:27/03:41:00]     或者说个容器组一起
[03:146:30/03:41:00]     然后这里面有一个问题是什么呢
[03:146:32/03:41:00]     就是配置管理
[03:146:33/03:41:00]     比如说你的前端要找到要要访问数据库不是前端要访问服务端
[03:146:39/03:41:00]     服务端要访问数据库
[03:146:41/03:41:00]     那前端怎么知道服务端的IP地址和端口号呢
[03:146:45/03:41:00]     他不知道对不对
[03:146:46/03:41:00]     因为我们启动的时候
[03:146:48/03:41:00]     启动容器的时候
[03:146:49/03:41:00]     它是随机的IP地址
[03:146:52/03:41:00]     他是随机来配
[03:146:53/03:41:00]     所以说你要做端口映射
[03:146:57/03:41:00]     你要做端口映射
[03:146:59/03:41:00]     通过端口映射
[03:147:00/03:41:00]     因为主机的IP是不会变的
[03:147:01/03:41:00]     你通过端口映射的形式去做配种配置管理
[03:147:04/03:41:00]     但是一旦你的服务多了
[03:147:06/03:41:00]     你的端口映射列表就会非常的长
[03:147:08/03:41:00]     非常长
[03:147:09/03:41:00]     它不利不利于你管理
[03:147:12/03:41:00]     所以说你完全可以什么呢
[03:147:13/03:41:00]     你完全可以把这些容器都用content模式串联起来
[03:147:17/03:41:00]     然后他们都是可以用互相用local的互相访问
[03:147:21/03:41:00]     这样省去了你配置管理的这么一个过程
[03:147:25/03:41:00]     同样你也一样的
[03:147:27/03:41:00]     假如说你一个服务是用doer启动的
[03:147:31/03:41:00]     然后你想要给他配置一个
[03:147:35/03:41:00]     配置一个
[03:147:36/03:41:00]     那你也可以启动一个的容器
[03:147:38/03:41:00]     然后用模式挂在目标容器的网络里面去也是可以的
[03:147:43/03:41:00]     也是可以的
[03:147:44/03:41:00]     甚至于说什么呢
[03:147:46/03:41:00]     我们有一个最常见
[03:147:48/03:41:00]     就利用民生空间最常用的一个场景是什么
[03:147:50/03:41:00]     做故障注入做故障注入为什么呢
[03:147:55/03:41:00]     就是说
[03:147:57/03:41:00]     欧罗布克里面也讲过
[03:147:58/03:41:00]     你也讲过
[03:148:00/03:41:00]     如果说我们做混沌工程的这种测试类型
[03:148:02/03:41:00]     就是说通过注入一些故障演练
[03:148:06/03:41:00]     然后去看一下我们系统系统的高可用
[03:148:08/03:41:00]     高可用架构是否能够兼容这些错误
[03:148:11/03:41:00]     那你就要向容器里注入故障
[03:148:13/03:41:00]     但是一般来说
[03:148:14/03:41:00]     假设你要注意一个网络故障
[03:148:15/03:41:00]     你是注入不进去的
[03:148:16/03:41:00]     为什么
[03:148:17/03:41:00]     可能有些同学会说
[03:148:18/03:41:00]     我到这个容器里面
[03:148:20/03:41:00]     然后去运行一些命令不就可以了吗
[03:148:23/03:41:00]     因为你没有权限
[03:148:25/03:41:00]     因为docker是没有虚拟化内核的
[03:148:27/03:41:00]     它是这个使用四主机的内核
[03:148:31/03:41:00]     它很危险
[03:148:32/03:41:00]     因为它一在一个容器里边
[03:148:33/03:41:00]     你可以把整个操作系统搞挂
[03:148:35/03:41:00]     也是可以的
[03:148:37/03:41:00]     所以说块在启动的时候默认是不给你开权限的
[03:148:40/03:41:00]     比如说你要到一个容器里面
[03:148:42/03:41:00]     你要运行IP tables命令运行告诉miion
[03:148:49/03:41:00]     因为这些东西都是可以直接改内核网络的
[03:148:51/03:41:00]     这些命令它都不会让你用
[03:148:54/03:41:00]     没有这个权限
[03:148:56/03:41:00]     所以说这个时候我们要怎么做呢
[03:148:58/03:41:00]     我们要怎么做呢
[03:148:59/03:41:00]     我录播课里应该也有讲过
[03:149:01/03:41:00]     怎么做呢
[03:149:02/03:41:00]     我给大家串一下
[03:149:04/03:41:00]     你要获取到
[03:149:10/03:41:00]     你要获取到当前容器的PID
[03:149:15/03:41:00]     比如说我们拿gra举例吧
[03:149:17/03:41:00]     就找这个
[03:149:18/03:41:00]     通过docker inspect命令
[03:149:23/03:41:00]     其实我们说过容器是个什么东西
[03:149:26/03:41:00]     其实docker启动容器
[03:149:28/03:41:00]     它就是启动一个进程
[03:149:29/03:41:00]     只是就为这个进程分配了不同的名声空间而已
[03:149:33/03:41:00]     所以说你才感觉他们是互相隔离的
[03:149:36/03:41:00]     你才感觉他们是互相隔离的
[03:149:37/03:41:00]     但其实它就是一个进程
[03:149:39/03:41:00]     所以说你用inspect这条命令是可以查到它的PID的
[03:149:49/03:41:00]     整错了PID
[03:149:52/03:41:00]     这这是它的PID
[03:149:53/03:41:00]     这是这个容器的PID
[03:149:55/03:41:00]     你知道容器的PID之后呢
[03:149:57/03:41:00]     你就可以
[03:149:58/03:41:00]     其实你可以到Pro下面去
[03:150:02/03:41:00]     这个目录就Pro
[03:150:04/03:41:00]     然后进程ID
[03:150:06/03:41:00]     然后这个
[03:150:08/03:41:00]     N缩ID
[03:150:15/03:41:00]     当然其实你他没啥用
[03:150:17/03:41:00]     我们真正要去做的一件事是什么
[03:150:21/03:41:00]     是通过NS这个命令
[03:150:24/03:41:00]     这个是可以切换民生空间的
[03:150:28/03:41:00]     大家可以切换民生空间
[03:150:30/03:41:00]     虽然我现在在宿主机上
[03:150:31/03:41:00]     但是我可以不进入容器的前提下
[03:150:35/03:41:00]     我就把民网络、民生空间切换到容器的
[03:150:38/03:41:00]     你可以看到这种名声空间分了很多种
[03:150:41/03:41:00]     民生空间分成很多种
[03:150:42/03:41:00]     那我们现在就在宿主机上
[03:150:45/03:41:00]     一切的民生空间都是用宿主机的
[03:150:47/03:41:00]     但是单独网络我们切换成容器的网络民生空间好吧
[03:150:53/03:41:00]     所以说杠T代表目标
[03:150:56/03:41:00]     你的进程ID就是这个进程ID
[03:150:58/03:41:00]     然后切换到哪个民生空间里呢
[03:151:00/03:41:00]     杠N
[03:151:01/03:41:00]     杠N是network的缩写
[03:151:02/03:41:00]     代表我要切换到目标容器的
[03:151:05/03:41:00]     网络命令空间里面
[03:151:06/03:41:00]     然后回车
[03:151:07/03:41:00]     回车你就会看到用iff命令
[03:151:11/03:41:00]     你发现你只能看到这两个网络设备了
[03:151:15/03:41:00]     因为我们我们现在的网络已经在容器里面了
[03:151:18/03:41:00]     你要是退出来用exit
[03:151:19/03:41:00]     退出来你再用fcon figure
[03:151:22/03:41:00]     你可以看到能看到很多网络设备
[03:151:24/03:41:00]     因为现在的网络密空间又毁在四五机上了
[03:151:28/03:41:00]     你可以看到DOER0这个网桥
[03:151:30/03:41:00]     我们刚才讲过
[03:151:32/03:41:00]     DOER0网桥是桥接模式使用的
[03:151:34/03:41:00]     而我们用刚才那命令
[03:151:36/03:41:00]     一旦切换到容器的网络名称空间里
[03:151:39/03:41:00]     你就会看见
[03:151:40/03:41:00]     你就看不到那些设备了
[03:151:43/03:41:00]     因为你现在在容器里边
[03:151:44/03:41:00]     但是你用doer PS命令
[03:151:46/03:41:00]     你用X命
[03:151:48/03:41:00]     或者说你用L命
[03:151:50/03:41:00]     Frank
[03:151:51/03:41:00]     你所有的这些目录进程
[03:151:53/03:41:00]     你看到的都是的
[03:151:59/03:41:00]     这就是民生空间的一个灵活性
[03:152:03/03:41:00]     所以根据这个情况呢
[03:152:04/03:41:00]     根据这个情况呢
[03:152:05/03:41:00]     我就可以往
[03:152:06/03:41:00]     虽然我人在宿主机上
[03:152:08/03:41:00]     但是我的网络已经切换到容器里了以前在容器里我没有权限执行的命令
[03:152:13/03:41:00]     我现在我现在是可以执行的
[03:152:17/03:41:00]     因为我只是网络切换了
[03:152:18/03:41:00]     我其他的东西没有切换
[03:152:19/03:41:00]     我现在用户还是这个用户
[03:152:20/03:41:00]     我还是有这个权限对吧
[03:152:22/03:41:00]     所以我就在这里面可以运行一个IP tables命令
[03:152:27/03:41:00]     假如说我模拟一个断网的故障I
[03:152:29/03:41:00]     Tables
[03:152:32/03:41:00]     IP tables里面杠a添加一个命令
[03:152:35/03:41:00]     添加一个什么
[03:152:36/03:41:00]     添加一个指令
[03:152:37/03:41:00]     添加一条规则
[03:152:38/03:41:00]     添加一个什么规则呢
[03:152:42/03:41:00]     比如说output output
[03:152:46/03:41:00]     我在output链上
[03:152:48/03:41:00]     添加一条规则
[03:152:51/03:41:00]     什么呢
[03:152:52/03:41:00]     杠J指定动作
[03:152:53/03:41:00]     Drop丢掉
[03:152:56/03:41:00]     丢包
[03:152:57/03:41:00]     我在链上加一个丢包故障
[03:152:59/03:41:00]     然后回车
[03:153:01/03:41:00]     我拼错了是吗
[03:153:04/03:41:00]     IP tables
[03:153:09/03:41:00]     然后到这边我再一刷新
[03:153:13/03:41:00]     大家可以看到刷不出来了
[03:153:18/03:41:00]     全是飞请飞请飞请请刷不出来了
[03:153:21/03:41:00]     因为我都已经模拟包这个故障
[03:153:25/03:41:00]     都是loading状态
[03:153:29/03:41:00]     大家能明白否
[03:153:31/03:41:00]     刚才着重的给大家讲了一下IP tables命令的原理
[03:153:35/03:41:00]     也是为故障注入准备的
[03:153:39/03:41:00]     也是为了故障注入准备的IP命令可以操作你的内核网络
[03:153:45/03:41:00]     你可以选择丢包
[03:153:46/03:41:00]     选择转发等等等等相关的东西
[03:153:48/03:41:00]     就是在容器领域里面
[03:153:49/03:41:00]     这是我们经常使用的一个命令
[03:153:52/03:41:00]     一个工具
[03:153:54/03:41:00]     我们之后假如说要做server
[03:153:56/03:41:00]     要做故障注入工具等等等等这些东西
[03:154:00/03:41:00]     都是使用S来去实现的
[03:154:02/03:41:00]     包括你要自己写一个由器
[03:154:04/03:41:00]     自己写一个Pro
[03:154:05/03:41:00]     一个由服务
[03:154:06/03:41:00]     都是很多时候都是需要利用到IP tables命令
[03:154:10/03:41:00]     大家能明白否
[03:154:16/03:41:00]     OK
[03:154:17/03:41:00]     今天最后的内容就是这个了
[03:154:19/03:41:00]     我要给大家再着重强调一下这个东西
[03:154:21/03:41:00]     因为什么呢
[03:154:22/03:41:00]     因为这个
[03:154:24/03:41:00]     这个东西就是我刚才给他讲到了这个民生空间
[03:154:27/03:41:00]     包括故障注入的整个这一套原理
[03:154:29/03:41:00]     真的是非常重要
[03:154:33/03:41:00]     非常重要的一个东西
[03:154:34/03:41:00]     我在面试的时候甚至非常喜欢问这些问题
[03:154:38/03:41:00]     因为因为他是一个怎么说它是一个分水岭
[03:154:41/03:41:00]     它是一个分水岭
[03:154:42/03:41:00]     当你能够比较详细的完善的说出这一套机制的时候
[03:154:46/03:41:00]     我认为你就不是一个入门级的小白了
[03:154:48/03:41:00]     你就不是只会打几个命令行
[03:154:49/03:41:00]     起几个通过刀客启动几个服务的这么一个初学者了
[03:154:55/03:41:00]     我认为你已经理解了容器到底是个什么东西
[03:154:58/03:41:00]     你已经可以根据容器的原理去开发自己的测试工具测设计自己的测试用例
[03:155:03/03:41:00]     假如说我给你一个跟容器相关的一个产品
[03:155:08/03:41:00]     那你是可以去进行测试的
[03:155:10/03:41:00]     你可以设计相关的测试用例
[03:155:12/03:41:00]     这这个东西你在网络上
[03:155:14/03:41:00]     在其他的课程里边
[03:155:15/03:41:00]     其实也很难能找得到
[03:155:17/03:41:00]     有人能给你讲讲解这些东西
[03:155:19/03:41:00]     那这个东西有什么问题吗
[03:155:21/03:41:00]     讲到这里
[03:155:24/03:41:00]     大家有什么问题吗
[03:155:56/03:41:00]     老师有一个问题
[03:156:00/03:41:00]     为啥note X exporter的启动命令没有用docker my d exportter启动命令
[03:156:07/03:41:00]     因为什么呢
[03:156:18/03:41:00]     因为是所有监控系统的原理是什么呢
[03:156:21/03:41:00]     原理都是需要
[03:156:22/03:41:00]     就是它监控是要读取那个当前操作系统的Pro
[03:156:27/03:41:00]     还有S这些目录下的这些
[03:156:32/03:41:00]     这些目录下的这些文件来去监控的
[03:156:35/03:41:00]     所以说如果你要用docker去启动的话
[03:156:38/03:41:00]     是可以就是挂载目录
[03:156:42/03:41:00]     你得挂了一大堆目录
[03:156:43/03:41:00]     然后我就懒嘛
[03:156:45/03:41:00]     我我就懒嘛
[03:156:46/03:41:00]     我就不想这么搞嘛
[03:156:47/03:41:00]     所以说就是一个命令行
[03:156:50/03:41:00]     我就启动起来了
[03:156:52/03:41:00]     你可以回去尝试一下
[03:156:53/03:41:00]     用那个do启动
[03:157:02/03:41:00]     是哪个位置进行的故障注入
[03:157:03/03:41:00]     进入到容器内
[03:157:06/03:41:00]     我刚才没有进入中心内部
[03:157:07/03:41:00]     我就是切换了一下网络名称空间嘛
[03:157:11/03:41:00]     你进入到容器内部去注入故障
[03:157:13/03:41:00]     你就注入进去了
[03:157:14/03:41:00]     因为你没有权限
[03:157:17/03:41:00]     我刚才说过
[03:157:18/03:41:00]     容器启动的时候默认是不给你权限的
[03:157:21/03:41:00]     不给你操控网络的权限的
[03:157:24/03:41:00]     你不能在容器内部注入网络故障
[03:157:29/03:41:00]     你只能是在容器外部注入
[03:157:32/03:41:00]     对切换网络名称空间就是你登录到主机里面
[03:157:36/03:41:00]     登录到宿主机里面
[03:157:37/03:41:00]     通过我刚才的一套流程
[03:157:41/03:41:00]     切换一下网络民生空间
[03:157:42/03:41:00]     切换到容器呢
[03:157:43/03:41:00]     然后你就可以在宿主机上针对容器进行故障输入
[03:158:22/03:41:00]     还有什么其他问题吗大家
[03:158:24/03:41:00]     因为如果没有其他问题的话
[03:158:26/03:41:00]     那我们今天的课程就要到这儿了
[03:158:29/03:41:00]     我尽量的就是把我认为容器相关比较重要的内容
[03:158:37/03:41:00]     在今天给大家这给大家练习了一下
[03:158:40/03:41:00]     其实本来我计划着这个故障注入这一块
[03:158:43/03:41:00]     也这个给大家一段时间练习的
[03:158:48/03:41:00]     我让大家自己故障注入一下
[03:158:50/03:41:00]     这个实在是没时间了
[03:158:52/03:41:00]     今今天可能大家这个给大家练习的时间多了一点
[03:158:55/03:41:00]     所以说我们没有时间在这个案例上也给让大家去练习一下
[03:158:59/03:41:00]     不过没有关系
[03:159:00/03:41:00]     因为我们下次不还有一节课
[03:159:02/03:41:00]     这个大家可以这个回去自己实践一下
[03:159:06/03:41:00]     然后到了下节课的时候
[03:159:07/03:41:00]     如果有问题你再问我
[03:159:09/03:41:00]     好吧
[03:159:12/03:41:00]     那如果没有其他的问题的话
[03:159:14/03:41:00]     我们今天课程就到这了好吧
[03:159:17/03:41:00]     大家拜拜
[03:159:18/03:41:00]     我点下课了
[03:159:19/03:41:00]     结束直播了
[03:159:25/03:41:00]     大家拜拜



## 71、docker 容器技术-IV



### 1、Docker 容器隔离 namespace
[00:00/09:59]     [以下字幕均由机器生成]那从这节课开始呢
[00:01/09:59]     我们进入一个学习我们doer底层原理的这么一个内容进面来
[00:08/09:59]     这部分内容也是比较重要的
[00:10/09:59]     因为什么呢
[00:12/09:59]     因为其实如果大家想在doer就想在容器这个这个方向走得更远的话
[00:17/09:59]     其实是要懂得容器底层的一些原理
[00:20/09:59]     这样的话呢
[00:21/09:59]     你才能够去在K8S中
[00:23/09:59]     就是这样的一个容器集群中去做其他的事情
[00:27/09:59]     包括它的网络策略
[00:30/09:59]     它的镜像策略
[00:31/09:59]     因为doer
[00:34/09:59]     它是一门非常灵活的一个解决方案
[00:37/09:59]     就是我们说虚拟化方案之间都是互相隔离的嘛
[00:41/09:59]     就容器容器之间是隔离的嘛
[00:43/09:59]     那其实可以据你的需要打破隔离的
[00:47/09:59]     打破隔离之后呢
[00:48/09:59]     你就可以让两个容器配合的更加的方便
[00:52/09:59]     更加的方便所以说呢
[00:54/09:59]     就是说在KS当中呢
[00:56/09:59]     其实它的很多的一些玩法
[00:59/09:59]     一些策略
[01:00/09:59]     其实使用的都是刀cker底层的原理的
[01:03/09:59]     当然这部分比较复杂比较复杂
[01:06/09:59]     这个涉及到的docker的这个内容呢
[01:12/09:59]     也比较的深也比较的深
[01:15/09:59]     我在这里呢
[01:16/09:59]     尽量的用一些大白话给大家解释一下
[01:20/09:59]     用尽量大白话给大家解释一下
[01:23/09:59]     好
[01:24/09:59]     我们开始学习第一部分的内容
[01:26/09:59]     第一个就是
[01:36/09:59]     是的
[01:42/09:59]     所以说容器的隔离
[01:49/09:59]     就跟虚拟机是完全不一样的
[01:55/09:59]     因为一个程
[02:04/09:59]     实际上呢
[02:05/09:59]     这本身就是在Linux中用来隔离进程的一个手段
[02:11/09:59]     我我们两个人拿一个两个屋子里面互话
[02:35/09:59]     我一句一句玩讲一个要是么
[02:40/09:59]     要求是说两个对就两之话
[02:43/09:59]     他们要一个频段上面去上都会一频
[02:50/09:59]     调频道一频道二频道三频道四频道你调去调频道
[02:55/09:59]     你把这个调了相同的频道上
[02:58/09:59]     这两个互相之间才能互相通话的
[03:02/09:59]     大家可以把
[03:08/09:59]     而是那个
[03:23/09:59]     不管它进行的是网络通还是进程间通用的那个PA通
[03:28/09:59]     进程之间可以用用管去通的
[03:30/09:59]     对吧
[03:31/09:59]     不管他用哪种方向去通信呢
[03:33/09:59]     他们都要保证在同一个频道上
[03:40/09:59]     所以在创建程
[03:43/09:59]     Linux创建进程的时候实际上
[03:48/09:59]     实际上是可以为程指频是的这个
[04:10/09:59]     为了让两个进行隔离
[04:12/09:59]     每你每启动一个容器的时候
[04:14/09:59]     就会默认为这个容器分配不同的频道
[04:18/09:59]     但是我说频道也是有有有类型的
[04:21/09:59]     就是name也是有类型的
[04:22/09:59]     它有什么呢
[04:23/09:59]     它有这个进程的名称空间
[04:26/09:59]     网络的名称空间
[04:28/09:59]     用户的名称空间
[04:29/09:59]     Mount挂载的名称空间
[04:31/09:59]     应该有六七空间
[04:36/09:59]     T
[04:37/09:59]     估计应该有
[04:38/09:59]     我没说六七种名生空间
[04:39/09:59]     他们分别用来隔离不同的东西
[04:41/09:59]     你像进程名人空间是用来隔离进程间通信的网络
[04:46/09:59]     名人间是用来隔离两个进程之间的网络的
[04:51/09:59]     用户空间是用来隔离用的
[04:55/09:59]     是用来隔离用户的
[04:58/09:59]     这也是为什么我们在登录器里面看不到其他也看不到的程和
[05:05/09:59]     是因本是处在不间
[05:09/09:59]     本身是处在不同的名称空间里的
[05:12/09:59]     这个大家要明白
[05:14/09:59]     这个大家要明白OK
[05:18/09:59]     OK
[05:21/09:59]     那么
[05:23/09:59]     我们以一前络络
[05:51/09:59]     他们为什么能达到这一点呢
[05:52/09:59]     其实就是因为你启动容器的时候
[05:56/09:59]     通过选择网络模式
[05:57/09:59]     其实就是在选择网络名称空间而已
[06:01/09:59]     当你使用网络模式的时候
[06:03/09:59]     其实
[06:04/09:59]     启动这个容器的时候
[06:06/09:59]     它设置的是为这个容器设置容器里面的进程
[06:11/09:59]     设置的是这个手机的网络名称空间
[06:15/09:59]     四手机的网络
[06:16/09:59]     而你用网络模式的时候
[06:18/09:59]     其实就是说你启动容器的时候
[06:19/09:59]     使用另外一个容器的网络空间
[06:25/09:59]     这个我也是
[06:26/09:59]     为什么我之前说容器在容器其实它是可以
[06:30/09:59]     它是一个很灵活的一个解决方案
[06:32/09:59]     它是可以在启动的时候打破隔离边界的
[06:37/09:59]     它是可以打破隔离边界的去玩
[06:39/09:59]     去完成各种各样的一个操作
[06:43/09:59]     完成一个各种各样的操作
[06:45/09:59]     那我们其实可以随意的
[06:49/09:59]     我们其实可以随意的到任一个进程里面
[06:53/09:59]     大家知不知道是什么是一个虚拟文件系统映了当前系统带
[07:03/09:59]     带数字的这些文件夹
[07:05/09:59]     这些文件夹是什么
[07:07/09:59]     这些文件夹就是进程
[07:09/09:59]     这里面保存的都是一个进程的信息
[07:13/09:59]     我们进入到某一个进程信息的文件夹里边
[07:15/09:59]     你到里边有一个NS这个目录
[07:18/09:59]     到NS字幕下LR一下
[07:21/09:59]     LS一下
[07:22/09:59]     你可以看到当前系统里面
[07:26/09:59]     当前系统里面这个进程的所有名称空间的信息
[07:30/09:59]     你看Ipc管通信的这个是它的名称空间的ID是
[07:43/09:59]     然后网络名称
[07:44/09:59]     空间PID进程名称
[07:46/09:59]     User是那什么
[07:48/09:59]     User是这个用户名称
[07:50/09:59]     空间us是什么来着
[07:52/09:59]     我有点忘了是不是管时间的好像是
[07:54/09:59]     管时间的好像是
[07:57/09:59]     每一个进程它都会有对应的名称空间一
[08:02/09:59]     所以说一个容器
[08:11/09:59]     就是我们启动一个容器
[08:13/09:59]     其实就是启动一个进程
[08:15/09:59]     只不过这个进程它分配了特殊的名称空间而已
[08:20/09:59]     这个就是名其实说白了
[08:22/09:59]     如果说我们不纠结它更加深入的原理
[08:26/09:59]     其实它就是这个
[08:34/09:59]     有什么用呢
[08:36/09:59]     最直接的最直接的使用场景
[08:41/09:59]     入入是是民间
[08:56/09:59]     你理解了名称空间的这个概念之后
[08:59/09:59]     那后续里面你其实你
[09:03/09:59]     开发很多测试工具
[09:04/09:59]     又或是说这个
[09:07/09:59]     又或者说是排查一些故障什么的呢
[09:10/09:59]     都是很方便
[09:12/09:59]     当当然这个故障注入的这个步骤
[09:16/09:59]     还有怎么样呢
[09:17/09:59]     我们不在这节课上讲
[09:18/09:59]     我们这课只讲名称空间
[09:19/09:59]     我们会在后续的课程里给大家再讲这个名称空间的这个使用的一些场景
[09:27/09:59]     因为我们先这两节先讲什么
[09:30/09:59]     先讲它的隔离机制
[09:32/09:59]     刀的隔离机制
[09:33/09:59]     它的第一个隔离机制就是这个名称空间
[09:37/09:59]     用来隔离通信的
[09:38/09:59]     那么下一个小节呢
[09:39/09:59]     我们接下来讲如docker如何用来如何隔离什么呢
[09:42/09:59]     如何如何隔离资源
[09:44/09:59]     就是隔离CPU和内存这些东西
[09:46/09:59]     是吧
[09:47/09:59]     那这一小节我们先讲到这里



### 2、Docker 资源限制 cgroups
[00:00/09:48]     [以下字幕均由机器生成]其实我们还需要另外一种隔离
[00:02/09:48]     除了通信维度的隔离之外
[00:03/09:48]     我们还需要一些资源的隔离
[00:05/09:48]     那这个以前大家用虚拟机的时候
[00:07/09:48]     应该也也有这种场景
[00:09/09:48]     我们启动虚拟机的时候
[00:10/09:48]     要为这个虚拟机分配一些资源
[00:12/09:48]     那这个虚拟机是不能使用超过这些资源的
[00:16/09:48]     它是不能超过这些资源的
[00:21/09:48]     我们启动这么多的虚拟机
[00:23/09:48]     不能让一台虚拟机就占用所有服务的这个资源
[00:26/09:48]     对吧
[00:27/09:48]     所以说我们要启动虚拟机的时候
[00:29/09:48]     为这些虚拟机去分配不同的资源去限制
[00:33/09:48]     那在容器中也是一样
[00:43/09:48]     用的是CS
[00:44/09:48]     CIS是什么呢
[00:46/09:48]     Cirus是Linux用来限制进程的资源的一个手段
[00:53/09:48]     我们在启动进程的时候呢
[00:56/09:48]     包括但不限于像CPU
[01:08/09:48]     内存这些东西
[01:09/09:48]     当然
[01:11/09:48]     我们在容器里面
[01:12/09:48]     最主要限制也是CPU和内存
[01:15/09:48]     其实理论上它也是可以限制一些网络IO
[01:17/09:48]     或者磁盘IO
[01:18/09:48]     但是基本上在业界没有人会去用
[01:21/09:48]     没有人在这个使用容器的这么一个领域里面去限制这些东西
[01:26/09:48]     我们一般也就只是限制这个CPU和内存
[01:30/09:48]     那具体它要怎么限制呢
[01:32/09:48]     其实从刀的命令来说
[01:33/09:48]     它是很
[01:35/09:48]     它是很那什么的
[01:37/09:48]     它是很很容易的
[01:39/09:48]     它是很容易的
[01:40/09:48]     比如说我演示一遍
[01:41/09:48]     我先把之前的那个我备课的时候这个NG删掉
[01:49/09:48]     我们还是用run的时候
[01:51/09:48]     刚刚那
[01:54/09:48]     叫NG
[01:55/09:48]     然后杠D
[01:56/09:48]     后台运行
[01:57/09:48]     然后杠M
[01:59/09:48]     限制一下内存512兆
[02:03/09:48]     杠C
[02:05/09:48]     我们限制一下
[02:07/09:48]     限制一下CPU
[02:08/09:48]     比如说两个核
[02:11/09:48]     然后
[02:13/09:48]     我们启动之后
[02:15/09:48]     的是docker run使用run的时候的两个参数而已
[02:31/09:48]     两个参数
[02:35/09:48]     那么因为当它底层原理是什么样子呢
[02:38/09:48]     我们看一下我们当前的文件夹
[02:41/09:48]     在CFSCS下面
[02:54/09:48]     每一个都是它的一个系统
[02:55/09:48]     你像CPU这边它是主要限制
[02:59/09:48]     主要限制CPU的
[03:00/09:48]     这边主要限制内存的
[03:01/09:48]     而当我们进入到一个子系统里面的时候
[03:07/09:48]     我可以看
[03:10/09:48]     这里面有很多的文件
[03:12/09:48]     这些都是用来限制
[03:16/09:48]     用来限制进程资源所要需要的用到的文件
[03:22/09:48]     所要遇到的文件你可以看到这里面还有一个什么呢
[03:24/09:48]     还有个docker和QPOS啊
[03:28/09:48]     一个是给docker用的
[03:29/09:48]     一个是给KS用的
[03:31/09:48]     那我们进入docker这里
[03:32/09:48]     进入do这边
[03:33/09:48]     你可以看到这边还有一个文件夹是什么呢
[03:36/09:48]     20C什么什么巴拉巴拉巴拉这个文件夹
[03:38/09:48]     这里就是我们刚才启动的那个容器
[03:41/09:48]     不信你看一下
[03:42/09:48]     我们找一下日志
[03:44/09:48]     我们在启动的时候打它的容器ID
[03:46/09:48]     你看20C2B
[03:48/09:48]     这边20C2B17
[03:51/09:48]     我放大点
[03:53/09:48]     大家能看到吧
[03:54/09:48]     当我们启动一个容器的时候
[03:58/09:48]     我们启动一个容器的时候
[04:05/09:48]     实际上是什么呢
[04:06/09:48]     都会在SSSS下面去创建一个文件夹
[04:11/09:48]     然后我们进入到这个文件夹里面去
[04:14/09:48]     你以到们
[04:23/09:48]     它的进程的ID
[04:42/09:48]     剩下的这些文件具体限制
[04:52/09:48]     我们限制
[04:53/09:48]     这些进程
[04:55/09:48]     最多只能使用这些内存
[04:58/09:48]     我们刚才设置512兆嘛
[05:00/09:48]     512兆那可能用翻译成就是把它换成就是这个数值了
[05:06/09:48]     CPU也是一样的CPU也是一样的
[05:09/09:48]     我们回到
[05:12/09:48]     这是我们回到CPU
[05:18/09:48]     你看这边也是一样的
[05:19/09:48]     这边有个docker
[05:20/09:48]     我们进入到docker doer
[05:22/09:48]     这边也有一个220C2P7
[05:26/09:48]     我们进去这里面现在进看就是CPU了
[05:29/09:48]     线的就是CPU了
[05:30/09:48]     我们进入对应的文件里面
[05:32/09:48]     就是可以看得到
[05:33/09:48]     可以看到它的CPU的相关的一些数值
[05:38/09:48]     CPU线管的一些数值
[05:43/09:48]     那这个就是它的底层的与原理
[05:47/09:48]     底层的原理
[05:49/09:48]     事实上呢
[05:51/09:48]     就是当初
[05:55/09:48]     就是我们以后如果有兴有兴趣接触K8S的时候
[06:00/09:48]     KS的资源计算
[06:01/09:48]     资源计
[06:02/09:48]     因为它也是使用的
[06:03/09:48]     然后它的资源限制也是K
[06:13/09:48]     它不是用命
[06:14/09:48]     在很多同学喜欢用命去算资源
[06:18/09:48]     我当前可用的内存是多少
[06:21/09:48]     可用内存是多少是多少
[06:22/09:48]     你看这边是9.5个G
[06:23/09:48]     但实际上在K里边不是这么算的
[06:26/09:48]     是通过一个通过
[06:31/09:48]     就我还在这块还写个脚本
[06:34/09:48]     我看一下能不能运行
[06:58/09:48]     你看
[07:03/09:48]     最后啊
[07:04/09:48]     最后算出的M
[07:10/09:48]     这6914
[07:13/09:48]     是6914
[07:14/09:48]     然后我们再看看
[07:15/09:48]     F是9.5
[07:17/09:48]     算的是七个
[07:20/09:48]     个G的是九.g的是点G
[07:26/09:48]     计算式K
[07:30/09:48]     因为他们取的东西不一样
[07:34/09:48]     KS是使用C进行资源计算
[07:38/09:48]     去进行资源计算的
[07:40/09:48]     而他的这个脚本是在这里
[07:45/09:48]     他你可以这个脚本是什么呢
[07:47/09:48]     他可以看到就是说
[07:50/09:48]     它是使用了这个
[07:53/09:48]     文件
[07:57/09:48]     这个文件
[08:00/09:48]     就是下有个
[08:06/09:48]     取这个文件
[08:07/09:48]     在这个文件里面取了一个值
[08:10/09:48]     去了一个值
[08:11/09:48]     然后进行计算的
[08:12/09:48]     就它跟我们free命令计算的方式是不一样的
[08:17/09:48]     完全不一样
[08:19/09:48]     所以我讲这个东西是较有用的是什么
[08:22/09:48]     如果后面我们在K里面去做像一测试
[08:26/09:48]     比如说我们做内载测试时候觉
[08:33/09:48]     我当前的我当前的这个我用看的看到了当前的剩余内存
[08:39/09:48]     跟我K8S判断的不一样
[08:41/09:48]     导致于行为不一样
[08:42/09:48]     比如说去除策略就是死活触发不了
[08:45/09:48]     K8S去除策略就是死活触发不了为什么
[08:49/09:48]     因为K8
[08:54/09:48]     比如说假如说策略你设置的是两个G
[08:57/09:48]     到两个G的时候出发
[08:59/09:48]     然后你压的时候
[09:00/09:48]     你把这个到两个G
[09:03/09:48]     应该么按
[09:11/09:48]     这个稍微跟大家提一下
[09:13/09:48]     大家后面有机会的时候可以可以这个了解一下
[09:17/09:48]     可以了解一下好吧
[09:18/09:48]     那我们这节课就到这儿了



### 3、容器故障注入实战
[00:00/12:10]     [以下字幕均由机器生成]我们来看一下如何进行这个容器的故障注入
[00:04/12:10]     [以下字幕均由机器生成]不知道大家以前有没有接触过混沌工程这样的一个测试类型
[00:11/12:10]     就是说我们向我们的系统中注入不同的故障
[00:14/12:10]     去验证我们系统的高可用架构
[00:17/12:10]     我们的高可用架构是否可以兼容这些故障
[00:20/12:10]     比如说我们一般的这个软件都是有多本部的
[00:24/12:10]     就是我们多本部负载均
[00:29/12:10]     负载均衡
[00:30/12:10]     比如说我们有一个服务下面其实是在三台机器上部署了三个服务一起去撑这个业务的这三个服务是一模一样的
[00:38/12:10]     这三个服务是一模一样的
[00:39/12:10]     然后呢
[00:40/12:10]     用户的流量呢
[00:41/12:10]     会平均的分布分布到这三台机器
[00:44/12:10]     而这这三个机器的服务上
[00:46/12:10]     那如果有一台机器挂了
[00:48/12:10]     或者有一个服务出现相应的异常
[00:52/12:10]     那我们的载器
[00:55/12:10]     我们的系统里的载器检测到的故障之后
[01:00/12:10]     就会
[01:01/12:10]     把流量
[01:02/12:10]     转发到其他的两个副
[01:05/12:10]     这个机器的副本上
[01:06/12:10]     而不会就是不会转发到这个有故障的机器上了
[01:09/12:10]     这就是这个高科架构有启动的一个作用
[01:12/12:10]     所以说往往呢
[01:13/12:10]     我们在测试的过程中呢
[01:15/12:10]     去专门有一种测试的类型叫高科能测试业界呢
[01:20/12:10]     现在比较流行叫混沌工词混沌
[01:27/12:10]     本质上就是故障注入
[01:29/12:10]     那以前的时候呢
[01:31/12:10]     在以前的时候
[01:32/12:10]     我们是这个在虚拟机里面去部署了一些服务
[01:37/12:10]     那你去注入这些故障还是比较容易的比如说你想模拟进程的异常
[01:42/12:10]     你一个Q杠九命令就好了
[01:44/12:10]     那如果你想模拟断网这个故障呢
[01:47/12:10]     你用IP tables这个命令直接去
[01:51/12:10]     你丢包就可以了吧
[01:58/12:10]     到容器里面去执行这样的一个故障注入的操作呢
[02:04/12:10]     那可能有些同学会说
[02:05/12:10]     那我像虚拟机一样去操作不就可以了吗
[02:09/12:10]     答案是不行
[02:11/12:10]     因为
[02:13/12:10]     Docker在启动容器的时候会有一些限制
[02:16/12:10]     我们之前曾经说过
[02:17/12:10]     Docker是不隔离内核的
[02:19/12:10]     所有的容器都是在都是使用
[02:22/12:10]     都是在使用速主机的内核的
[02:25/12:10]     所以说一个容器
[02:26/12:10]     理论上一个容器它就可以把整个内核给弄挂掉
[02:31/12:10]     然后速主机也好
[02:32/12:10]     其他容器也好
[02:33/12:10]     所以说它比较危险
[02:35/12:10]     因为它不隔离内核嘛
[02:36/12:10]     所以说就会比较危险
[02:37/12:10]     所以说do默认启动容器的时候呢
[02:42/12:10]     是把一些权限给取消掉了的
[02:45/12:10]     比如说你想到一个容器里面执行IP tables命令
[02:49/12:10]     去注入一个断网的一个故障的话
[02:52/12:10]     然后你输入IP tables的这个命令后
[02:55/12:10]     它就会告诉你当前没有权限
[02:59/12:10]     因为IP tables命令它是只它是可以操控内核网络的
[03:03/12:10]     所以说待会直接把这些权限给禁掉了
[03:07/12:10]     给禁掉了
[03:08/12:10]     你是注入不了的
[03:10/12:10]     你是注入不了了
[03:11/12:10]     那可能有些同学会说
[03:12/12:10]     那有些时候我不注入断网的故障
[03:15/12:10]     就比如说
[03:17/12:10]     我可以注入一些其他的故障
[03:18/12:10]     我只要到这个容器里面有相相应的故障的注入工具
[03:23/12:10]     那我就可以注入了
[03:25/12:10]     那也不行
[03:26/12:10]     就算抛开权限的这个问题不谈
[03:30/12:10]     你到容器里面第一个你要面临的问题就是容器里并没有你需要的故障注入工具
[03:38/12:10]     比如说现在很流行的ksplay的阿里开源splay是现在蛮流行的一个故障录入工具的
[03:44/12:10]     你的容器里是不可能有SY的
[03:46/12:10]     对吧
[03:48/12:10]     那可能有同学说
[03:49/12:10]     那我装一个不好意思
[03:51/12:10]     可能你也装不了
[03:53/12:10]     因为我们后面学镜像的时候
[03:55/12:10]     镜像制作的时候的一些原理的时候
[03:59/12:10]     你就会知道我们的业务里面的镜像都是要极尽追求
[04:04/12:10]     镜像是非常小的
[04:06/12:10]     里面什么东西都没有
[04:07/12:10]     有的有些时候
[04:09/12:10]     能不装就不装
[04:10/12:10]     所以说可能连让你安装S的这个
[04:14/12:10]     这个命令行都没有
[04:15/12:10]     比如说他可能没有w get
[04:17/12:10]     没有样没有apt get
[04:19/12:10]     这些东西都是没有的
[04:20/12:10]     我甚至还见过有的这个镜像是没有shell环境的
[04:26/12:10]     是没有shell环境的
[04:27/12:10]     你一条shell命令都打不进去
[04:29/12:10]     所以说在这种情况下
[04:32/12:10]     在这种情况下
[04:33/12:10]     你很难到向某一个容器里面去注入故障的
[04:38/12:10]     那你很难的
[04:42/12:10]     非常非常难
[04:44/12:10]     那这个时候怎么办呢
[04:45/12:10]     这里边就要利用什么呢
[04:47/12:10]     利用到我们之前学习的
[04:51/12:10]     关于namespace Linux namespace的相关的知识了
[04:58/12:10]     相关的知识了
[05:00/12:10]     我们都我们之前曾经说过这个
[05:04/12:10]     Docker呢
[05:05/12:10]     是可以根据用户的需要打破隔离边界的
[05:09/12:10]     随时可以打破隔离边界的
[05:11/12:10]     所以呢
[05:17/12:10]     我们怎么办呢
[05:20/12:10]     我们完全可以利用这个特性
[05:22/12:10]     你space的特性去打破它的隔离边界
[05:27/12:10]     我们先来回顾一下
[05:28/12:10]     我们在容器里面注入故障呢
[05:32/12:10]     它就会面临两个问题
[05:33/12:10]     第一个问题是没有权限
[05:35/12:10]     第二个问题是没有相关的注入故障注入的工具
[05:40/12:10]     那么如果我们能够在宿主机上
[05:46/12:10]     执行
[05:49/12:10]     宿主机上去执行相关的命令
[05:54/12:10]     是不是就有权限了
[05:56/12:10]     假如说我们在四五级上能够操控容器的网络的话
[05:59/12:10]     那是不是就能解决这两个问题了
[06:01/12:10]     因为我在四五级上执行
[06:02/12:10]     所以说不管是权限的问题
[06:05/12:10]     还是故障注入工具的问题都是可以解决的
[06:08/12:10]     只要我在能在副副主机上切换到目标容器的网络名称空间就可以了
[06:16/12:10]     OK
[06:17/12:10]     那我们就来实践一下这个过程
[06:19/12:10]     其实最简单的就是这三步
[06:22/12:10]     首先我们有
[06:24/12:10]     我们先启动一个进程
[06:26/12:10]     我们先启动一个容器
[06:28/12:10]     Docker run杠杠
[06:29/12:10]     Name等于in
[06:34/12:10]     当地NX
[06:43/12:10]     好像是不应该有等号是吧
[06:47/12:10]     是已经有一个叫N吉的在了
[06:53/12:10]     启动之后
[06:56/12:10]     我们需要用docker inspect
[07:01/12:10]     查看一下它的源信息
[07:02/12:10]     Do inspect这个命令是查看某一个容器的源信息的
[07:06/12:10]     所以说它的各种各样的信息都会列在这里
[07:09/12:10]     包括它IP地址
[07:11/12:10]     地址啊
[07:13/12:10]     Network配置等等
[07:14/12:10]     这里面我们找什么
[07:15/12:10]     找PID
[07:20/12:10]     PID
[07:25/12:10]     Bid
[07:30/12:10]     Pad根据我们之前的讲解
[07:33/12:10]     根据我们之前的讲解
[07:35/12:10]     其实启动容器就是启动一个进程
[07:38/12:10]     只不过其中这个进程的时候是给它设置了不同的名称空间
[07:43/12:10]     所以说它就跟其他的进程
[07:46/12:10]     跟四主机进程
[07:48/12:10]     跟其他的容器
[07:49/12:10]     都是隔离的了对吧
[07:51/12:10]     所以说启动一个容器的时候
[07:53/12:10]     其实启动一个进程
[07:54/12:10]     这个进程就有它的PID的
[07:56/12:10]     这个进程就是它的PID了
[07:58/12:10]     而我们也之前也讲过
[07:59/12:10]     在Pro下面通过PID
[08:03/12:10]     能够找到
[08:04/12:10]     这个进程所在的这个进程现的所有信息
[08:07/12:10]     然后在NS里面我们是可以看到当前这个容器的
[08:12/12:10]     当前这个容器的所有的名称空间相关的信息的
[08:20/12:10]     民生攻坚相关的信息的
[08:21/12:10]     对吧
[08:22/12:10]     所以说实际上我们之前也说过
[08:24/12:10]     民生攻坚是分类型的
[08:26/12:10]     好多种类型对吧
[08:27/12:10]     所以说我们可以通过某种方式切换到任意一个
[08:32/12:10]     名称空间里面去
[08:34/12:10]     比如说我们当前保鲜所有的名声空间都还是使用四主机
[08:39/12:10]     我们当前这个root用户的
[08:41/12:10]     四主机的这个root用户的
[08:42/12:10]     对吧
[08:43/12:10]     如果我只想把网络名称空间切换到容器上
[08:47/12:10]     那要怎么做呢
[08:49/12:10]     那么就是NS这个命令NS
[08:55/12:10]     就是namespace inter的简写
[08:58/12:10]     NS就是namespace
[08:59/12:10]     它专门用来切换名称空间的
[09:02/12:10]     是Linux自带的一个命令
[09:04/12:10]     然后杠t target啊
[09:07/12:10]     杠T是target缩写
[09:08/12:10]     代表着什么呢
[09:09/12:10]     你的目标的PID是什么
[09:12/12:10]     你目标的PID那我们刚才查询到是5131
[09:16/12:10]     再然后呢
[09:17/12:10]     你要切换的是哪个民生空间
[09:19/12:10]     我们要切换到网络民生空间
[09:21/12:10]     那就是
[09:24/12:10]     回车
[09:25/12:10]     那至此
[09:26/12:10]     我们现在已经切换到了容器的网络里面了
[09:33/12:10]     如果现在我们用if conflict
[09:36/12:10]     回车
[09:38/12:10]     大家可以看到我们的网络设备
[09:43/12:10]     已经不一样了
[09:47/12:10]     当然我们要对比一下
[09:48/12:10]     我们退出来
[09:49/12:10]     退出之后
[09:50/12:10]     我们又回到了什么呢
[09:51/12:10]     又回到了四主机的网络美星空间里边
[09:56/12:10]     我们再用if con去看一下
[09:59/12:10]     你可以看到这里面有非常多的网络设备
[10:01/12:10]     因为我启容器多
[10:03/12:10]     你看这个刀客零是我们的桥接模式
[10:06/12:10]     就是桥接模式里边那个刀客零
[10:08/12:10]     对吧
[10:09/12:10]     而我们只要进入到了
[10:10/12:10]     通过这个命令进入到容器网络
[10:12/12:10]     我们再用if con
[10:13/12:10]     因为我们切换到容器网络里面
[10:15/12:10]     所以说
[10:17/12:10]     我们只能看到容器的这两个设备
[10:20/12:10]     一个是什么呢
[10:21/12:10]     一个是它的虚拟网卡
[10:25/12:10]     一个是什么呢
[10:26/12:10]     一个是它的本地回换设备
[10:29/12:10]     本地回款设备
[10:30/12:10]     所以说在这个时候
[10:32/12:10]     这个时候是一于一个有的一个状态
[10:36/12:10]     我们用都是宿主机上的进程
[10:43/12:10]     宿据上的文件
[10:44/12:10]     宿主线上的所有的东西
[10:46/12:10]     除了网络
[10:48/12:10]     我希望大家能体会一下
[10:50/12:10]     就是我现在只有网络民生空间是在容器网络里面的
[10:55/12:10]     这个我希望大家能那什么
[10:57/12:10]     希望大家能这个
[10:59/12:10]     能够好好的体会一下这个场景
[11:03/12:10]     那所以说在这个时候如果用IP tables命令把
[11:07/12:10]     网络断掉了
[11:09/12:10]     比如说所有发送到当前网络的这个报告全都丢掉
[11:14/12:10]     那其实就模拟了一个断网的故障了
[11:17/12:10]     就模拟了一个断网的故障
[11:21/12:10]     大家能明白否
[11:24/12:10]     这就是整个一个故障注入的一个过程
[11:28/12:10]     这也是一个namespace的一个使用方式
[11:32/12:10]     Namespace的一个使用方式
[11:34/12:10]     其实还有第二个
[11:36/12:10]     第二个课程不是第二个故障注入的方法第二个故障注入的方法其实我们之前也讲到过
[11:47/12:10]     我们之前也讲到过
[11:49/12:10]     但是我可以在这里面给大家留一个作业
[11:52/12:10]     这样我们到直播课里面可以宣布这个作业的答案
[11:55/12:10]     就是大家想一想
[11:56/12:10]     除了我现在讲的这种方式之外
[11:58/12:10]     还有一种方式可以注入网络故障
[12:01/12:10]     像一个容器里面注入网故障
[12:03/12:10]     大家可以想一想什么是什么方法
[12:06/12:10]     好吧



### 4、Docker 镜像分层设计
[00:00/07:53]     [以下字幕均由机器生成]哈
[00:00/07:53]     [以下字幕均由机器生成]大家好
[00:01/07:53]     [以下字幕均由机器生成]那这一小节呢
[00:02/07:53]     我们来看一下镜像分层设计这一个点
[00:09/07:53]     这个是有关我们接下来这几节呢
[00:13/07:53]     是有关我们如何设计一个特一个比较良好的一个镜像系统的这么一个
[00:22/07:53]     方法吧
[00:23/07:53]     我们先看一下镜像分层的这么一个设计
[00:27/07:53]     在doer当中的镜像呢
[00:28/07:53]     每一个镜像呢
[00:29/07:53]     是由多个层来组成的
[00:31/07:53]     那它为什么要这么设计呢
[00:34/07:53]     首先每一层其实是可以复用的比如说
[00:38/07:53]     我们编写do file的时候呢
[00:42/07:53]     就可以利用的它的这个每一层的分层镜像分层
[00:47/07:53]     并且有缓存这个特点就
[00:49/07:53]     去加速我们镜像开发的一个过程的
[00:54/07:53]     这我给大家举一个例子
[00:55/07:53]     比如说我们这边有两个do file
[01:00/07:53]     我们先看第一个
[01:03/07:53]     在第一个do file里面
[01:04/07:53]     我们可以看到我们在run指令里面
[01:07/07:53]     这里有个run指令
[01:09/07:53]     我们在run指令里面一个指令
[01:12/07:53]     大家可以看到我们是用这个斜线和两个and符号去拼接的
[01:17/07:53]     把好多个shell的命令拼接成了一个字符串
[01:21/07:53]     放到了一个run指令里面
[01:22/07:53]     这是一种形式
[01:31/07:53]     卡了怎么
[01:36/07:53]     大家稍等一下
[01:37/07:53]     网络卡了一下
[01:38/07:53]     突然
[01:40/07:53]     还有一种形式是什么呢
[01:41/07:53]     还有一种形式是
[01:44/07:53]     卡成这个样子
[01:50/07:53]     还有一种形式是这样的
[01:54/07:53]     怎么卡成这个样子
[02:05/07:53]     还有一种形式大家可以看到
[02:07/07:53]     在这一边我还可以用一多个run指令
[02:11/07:53]     我每个run指令里面只运行很少的命令
[02:14/07:53]     每个里面只运行很少的命令
[02:17/07:53]     我可以用多个run指令里面去写
[02:19/07:53]     那这两种方式哪一种
[02:23/07:53]     更好呢
[02:24/07:53]     哪一种更好呢
[02:28/07:53]     根据看效果就好
[02:29/07:53]     知道我们现在
[02:33/07:53]     用Bill的名义
[02:39/07:53]     哎呀
[02:41/07:53]     我调整一下网络
[02:42/07:53]     这里怎么这么卡
[02:50/07:53]     嗯
[02:53/07:53]     Do t
[02:54/07:53]     比如说叫TP
[02:58/07:53]     V1.0
[03:10/07:53]     我们看一下它的效果
[03:18/07:53]     我们正在跑的
[03:20/07:53]     我们正在安装这些软件来构建我们的镜像
[03:24/07:53]     我们等它运行完毕
[04:01/07:53]     安装起来可能稍微有点慢
[04:15/07:53]     大家可以看到安装一个镜像它是很慢的
[04:18/07:53]     我们安装完了
[04:20/07:53]     安装一个镜像很慢的
[04:21/07:53]     我们安装的还都是小软件
[04:23/07:53]     所以说构建这个镜像的时候是很慢的
[04:25/07:53]     但是我们在运行这个命令的时候
[04:27/07:53]     瞬间就执行完了
[04:29/07:53]     不论我运行多少次
[04:31/07:53]     都是瞬间执行完了
[04:32/07:53]     跟我们第一次运行的时候是不一样的
[04:36/07:53]     第一次运行的时候是不一样的
[04:42/07:53]     我们再做一个实验
[04:44/07:53]     比如说
[04:48/07:53]     我稍微修改一下
[04:49/07:53]     我们刚才修改的是最后一行的这个内容
[04:52/07:53]     最后一行的这个内容
[04:56/07:53]     我们刚才可以看到之前的时候
[04:58/07:53]     之前的时候
[05:01/07:53]     我们只要运行命令都会告诉你
[05:03/07:53]     Using cash using cash里缓存
[05:06/07:53]     这里是有缓存的
[05:07/07:53]     但是我刚才修改了一个东西之后呢
[05:09/07:53]     我们再看一下
[05:12/07:53]     大家可以看到前面还都是在using cash还是在使用缓存
[05:16/07:53]     到时候到了最后一步的时候
[05:18/07:53]     大家可以看到它又开始重新安装了
[05:20/07:53]     然后这时候我再去运行
[05:22/07:53]     再去运行
[05:24/07:53]     它还是立刻就结束了
[05:25/07:53]     因为全都是在大家可以看到这是利用了缓存的这么一个特性
[05:32/07:53]     而它的缓存是按照层来分的
[05:37/07:53]     它的缓存是按照层来分的
[05:39/07:53]     而在我们这里
[05:40/07:53]     一个指令就是一层
[05:49/07:53]     那
[05:51/07:53]     Docker
[05:53/07:53]     按照镜像分层的这么设计的第一个好处就是什么
[05:57/07:53]     就是每每指令就是说每一层是有缓存的
[06:02/07:53]     一旦它判断
[06:04/07:53]     一旦他判断你的当前的要生成的这一层是跟以前是一样的
[06:10/07:53]     那么他就不会重新执行
[06:11/07:53]     而是复用以前的那一层
[06:14/07:53]     大家能理解吧
[06:19/07:53]     所以说刀块运用这种设计可以有利于什么呢
[06:22/07:53]     有利于我们开发镜像
[06:25/07:53]     在开发镜像的时候在开发镜像的时候
[06:29/07:53]     我们就一个软指令
[06:30/07:53]     一个软指令怎么去写
[06:32/07:53]     这样一旦我假如说我写到一段时间
[06:37/07:53]     我跑一下子跑一下子测试一下
[06:39/07:53]     测试往接着往上写
[06:40/07:53]     但是写着写着
[06:41/07:53]     我一经发现我写错了
[06:42/07:53]     我需要修改一下
[06:44/07:53]     那么假设说我在这一行修改
[06:45/07:53]     那么在这一行修改完之后
[06:47/07:53]     可能从这一行开始往下需要重新执行
[06:49/07:53]     上面的都是可以利用缓存的
[06:53/07:53]     上面都是可以利用缓存的
[06:55/07:53]     那这个样子呢
[06:56/07:53]     就是十分的能够加速我们的
[07:01/07:53]     加速我们的镜像构建的过程
[07:10/07:53]     大家能明白吧
[07:12/07:53]     就是利用缓存的一个特性
[07:14/07:53]     OK
[07:16/07:53]     当然这样也不是最好的
[07:20/07:53]     因为如果我们的层数过多
[07:23/07:53]     我们的层数过多
[07:27/07:53]     会影响我们镜像启动容器后的IO性能
[07:30/07:53]     那它为什么会影响呢
[07:32/07:53]     层数多了为什么会影响呢
[07:34/07:53]     这个我们放到下一小节里面讲联合文件系统的时候说
[07:39/07:53]     那这一小节我们就到这里结束



### 5、Docker 联合文件系统详解
[00:00/08:17]     [以下字幕均由机器生成]我们来看一下docker镜像当中的联合文件系统
[00:05/08:17]     联合文件系统呢
[00:06/08:17]     它是构建docker的这个镜像的一个底层的一个技术
[00:13/08:17]     它也是这个docker的历史当中第一个
[00:18/08:17]     第一个这个第一个刀cker的文件系统驱动
[00:23/08:17]     后面呢
[00:24/08:17]     它为了实现它的分层镜像呢
[00:25/08:17]     其实也换过一些技术
[00:28/08:17]     比如说device map OA类Y
[00:30/08:17]     还有现在应该现在是最用的最多的o类二
[00:35/08:17]     但是其实大家可以把o类二当做是这个联合文件系统的一个升级版
[00:44/08:17]     一个升级版
[00:45/08:17]     它其实它要做的事情是一样的
[00:48/08:17]     要做的事情是一样的
[00:49/08:17]     只是as
[00:51/08:17]     它的这个就是联合文件系统
[00:53/08:17]     它的性能比较差
[00:55/08:17]     它性能比较差
[00:56/08:17]     哎哟这个后来开发出了o类FS
[01:02/08:17]     这当前这个图里呢
[01:04/08:17]     是一个图一个图冷不丁给你们看
[01:08/08:17]     肯定是
[01:10/08:17]     你们也不知道是怎么回事
[01:11/08:17]     所以说我还是需要在这给你们重新画一下
[01:15/08:17]     我再画一下
[01:17/08:17]     我们先说什么是联合文件系统
[01:20/08:17]     联合文件系统主要是为了解决一个问题
[01:25/08:17]     解决一个问题
[01:27/08:17]     就是什么呢
[01:28/08:17]     就是假设两个目录
[01:32/08:17]     假设有两个目录
[01:37/08:17]     两个目录里面分别有文件
[01:39/08:17]     文件a、文件B
[01:42/08:17]     比如说目录X
[01:43/08:17]     这是目录Y
[01:45/08:17]     然后有文件a和文件B
[01:55/08:17]     如果我是一个系统的文件管理员
[01:59/08:17]     那如果我要去维护文件a和B的话
[02:03/08:17]     就需要把目录切换到X目录或者和Y目录下
[02:08/08:17]     是比较麻烦的
[02:09/08:17]     我要切不停的切换目录才能够去操作这两个文件
[02:12/08:17]     然后呢
[02:13/08:17]     如果只有两个文件
[02:14/08:17]     当然是没有什么问题
[02:16/08:17]     但是假如说如果有成千上万个文件的话
[02:18/08:17]     那就维护起来就会是一个噩梦了
[02:21/08:17]     我们专门要维护一张很大的表
[02:24/08:17]     去记录哪个文件在哪个目录里面是非常麻烦的
[02:28/08:17]     所以说呢
[02:29/08:17]     联合文件系统它干了一件什么事情
[02:31/08:17]     他为了解决这个问题
[02:32/08:17]     他可以干一些什么
[02:33/08:17]     他提供一个视图层
[02:35/08:17]     就是自
[02:36/08:17]     Z目录一个视图目录
[02:38/08:17]     让这个Z目录里面呢
[02:40/08:17]     你既能够看到a文件
[02:43/08:17]     你也能够看到
[02:45/08:17]     B文件
[02:48/08:17]     同时呢
[02:49/08:17]     如果用户像a文件编写了一个
[02:53/08:17]     追加了一个单词
[02:54/08:17]     比如说然后用户也能够在原文件上也能够看到这个单词出现
[03:03/08:17]     用户就只需要在Z目录上去维护这些文件就可以了
[03:07/08:17]     再也不用切换这些目录
[03:10/08:17]     再也不用切换这些目录了
[03:12/08:17]     就是它为用户提供了一定的方便
[03:17/08:17]     但是呢
[03:18/08:17]     如果说我们放到do这个场景里面
[03:21/08:17]     假如说我们B文件里面
[03:24/08:17]     Hello
[03:27/08:17]     这个在原来的这个文件到这这行这个修改答案
[03:37/08:17]     相反的
[03:39/08:17]     是在
[03:41/08:17]     X目录下面记录了一个B的更改
[03:47/08:17]     就是说B文件修改了什么样的内容
[03:49/08:17]     记录在了X目录
[03:52/08:17]     为什么会这样呢
[03:53/08:17]     是因为联合文件系统在联合目录的时候
[03:56/08:17]     把监管目录联合在一起的时候
[03:58/08:17]     是可以给这些目录赋予读写权限的
[04:02/08:17]     而docker
[04:03/08:17]     而docker在构建镜像的时候
[04:07/08:17]     在构建镜像的时候
[04:09/08:17]     他在联合文件的时候
[04:11/08:17]     它只会给联合文件当中的第一个
[04:14/08:17]     目录
[04:16/08:17]     读写权限
[04:18/08:17]     第一个目录读写权限
[04:20/08:17]     剩下的都是只有只读权限
[04:24/08:17]     所以说你即便在这里面修改了B文件
[04:27/08:17]     但他也没有办法真正的改动
[04:29/08:17]     对原来的B文件做一个改动的
[04:32/08:17]     是没有办法的
[04:34/08:17]     是没有办法了
[04:35/08:17]     因为这是只读的
[04:36/08:17]     所以说他只能在这个可写的这一个目录里面记录一个B的更改
[04:41/08:17]     然后把B的更改文件和原文件B做一个展现给用户
[04:48/08:17]     做一个墨展现给用户
[04:55/08:17]     那根据这个其实大家应该可以出来这里
[04:59/08:17]     这个这个只有止血只读权限的
[05:05/08:17]     目录就是镜像层
[05:07/08:17]     可读可写的就是容器层
[05:10/08:17]     这个就是视图层
[05:14/08:17]     一般来说
[05:15/08:17]     当用户登录到容器里面
[05:17/08:17]     其实登录到的是视图层
[05:18/08:17]     你是直接看到的视图层
[05:20/08:17]     你是看不到容器层和镜像层
[05:23/08:17]     你是看不到的
[05:25/08:17]     你是绝对看不到的
[05:34/08:17]     这也解释了为什么我们在上一小节里面讲镜像分层的时候说层数越多
[05:40/08:17]     它的这个性能会越差的这么一个问题其实大家可以想一想
[05:44/08:17]     假如说我有十好几层
[05:45/08:17]     每一层都对这个B文件做了更改了
[05:51/08:17]     的每一层的B文件增长
[05:53/08:17]     最后你要展示的给用户的时候
[05:54/08:17]     就要制十几层的文件
[05:58/08:17]     那它的性能肯定是差的
[06:01/08:17]     那它的性能
[06:03/08:17]     所以说
[06:06/08:17]     所以说我们一般是什么样子的
[06:07/08:17]     我们一般在开发镜像的时候
[06:10/08:17]     是一个软指令里面写一个命令
[06:13/08:17]     但是如果软指令过多
[06:15/08:17]     那当然只有七八层
[06:16/08:17]     五六层五六个指令
[06:18/08:17]     那没什么没什么问题
[06:20/08:17]     但是如果你有七八十个软指令
[06:24/08:17]     那你就要考虑一下把部分的指令合并成一个令了
[06:29/08:17]     以它的数
[06:31/08:17]     以减少它的层数好吧
[06:35/08:17]     这个就是联合文件系统
[06:50/08:17]     目
[06:57/08:17]     一堆的目录和文件
[06:59/08:17]     只不过他们用了
[07:00/08:17]     我们之前讲过民生空间里有
[07:04/08:17]     Name专门文件的
[07:07/08:17]     我会通过
[07:11/08:17]     镜像规定的这些目录
[07:15/08:17]     挂载到了什么地方呢
[07:17/08:17]     挂载到了容器的root FS上
[07:20/08:17]     挂载了容器的日上
[07:22/08:17]     这样的话
[07:23/08:17]     你登的容器里面你看到的目录全都是镜像的里面的目录
[07:28/08:17]     我们的点是不是起来民
[07:35/08:17]     我们的这个name
[07:38/08:17]     也回答了我们在上这一系列的课的时候
[07:41/08:17]     最一开始的那个问题
[07:54/08:17]     那镜是什么
[07:55/08:17]     其实就是一堆文件
[07:57/08:17]     一堆文件
[07:58/08:17]     一堆目录
[08:01/08:17]     大家好好体会一下
[08:02/08:17]     这个小节呢
[08:04/08:17]     就到这里结束了



### 6、Docker 镜像设计方法实战
[00:00/06:49]     [以下字幕均由机器生成]那这一小节呢
[00:00/06:49]     [以下字幕均由机器生成]我们就在我们这列最后一个了
[00:04/06:49]     就是来介绍一下我们要如何介绍如何设计我们的镜像
[00:11/06:49]     其实本质上呢
[00:12/06:49]     这一小节内容跟上一节联合文件系统是是关联性非常的深的
[00:20/06:49]     因为我们要了解联合文件系统的原理之后
[00:24/06:49]     才知道我们要如何去设计一个镜像了
[00:29/06:49]     这个西呢
[00:31/06:49]     这个东西呢
[00:32/06:49]     主要是我们之前曾经讲过
[00:37/06:49]     就是有了联合文件系统之后
[00:38/06:49]     我们层也是可以用的
[00:51/06:49]     就变成了比如说我们现在我先把这些东西删除掉
[00:55/06:49]     现在想一个镜像
[00:58/06:49]     现在想要制作一个镜像那么
[01:00/06:49]     实际上我们启个要是
[01:08/06:49]     容器层copy过来
[01:13/06:49]     然后把让它指向下一层
[01:16/06:49]     指向进行层
[01:17/06:49]     这就变成了一个
[01:19/06:49]     两层的镜
[01:20/06:49]     两镜我们启动一个容器
[01:23/06:49]     启动一个新的容器
[01:28/06:49]     相当于什么呢
[01:29/06:49]     相当于我们创建了一个目录
[01:32/06:49]     空的目录
[01:33/06:49]     再与进行层进行联合
[01:35/06:49]     给用户一个视图层
[01:37/06:49]     那如果说假如说我又对这个
[01:41/06:49]     做了一些更改
[01:45/06:49]     就是说我添加了
[01:46/06:49]     我又对an在做更改
[01:47/06:49]     然后再去做一个镜像
[01:49/06:49]     又把这边一定copy过来
[01:52/06:49]     放到这里
[01:53/06:49]     变成了一个三层的镜象
[01:57/06:49]     三层的镜像
[01:58/06:49]     以此类推
[01:59/06:49]     这就是一个镜像制作的一个过程
[02:03/06:49]     镜制作一个过
[02:12/06:49]     比如说我们这一层第二层是依赖最底层的
[02:16/06:49]     但是并没有规定说只有它能够使用最底层的镜像理论上
[02:24/06:49]     我们完全可以
[02:26/06:49]     在
[02:30/06:49]     这一边
[02:32/06:49]     再创建一个定向仓也指向它
[02:37/06:49]     然后这一边也是一样的也是一样的
[02:45/06:49]     完全可以
[02:46/06:49]     所以当这个时候
[02:49/06:49]     我们的整个的镜像的
[02:53/06:49]     设计就变成了什么样子的呢
[02:55/06:49]     变成了什么样子呢
[02:57/06:49]     可能最下面这一层是我们的最基础的镜像层
[03:01/06:49]     基础镜像层
[03:03/06:49]     它可能可以是一个S
[03:07/06:49]     假如说它是一个S
[03:08/06:49]     那这边可以是一个Java的镜像
[03:12/06:49]     四点之上我要构建什么呢
[03:14/06:49]     我要构建一个Java的
[03:16/06:49]     接下来里边可能是装了JDK
[03:19/06:49]     让JDK装了
[03:21/06:49]     那这一边呢
[03:22/06:49]     可能是Python
[03:27/06:49]     Peasant镜像这边呢
[03:29/06:49]     可能是go long的镜像
[03:31/06:49]     但他们统一都依赖最底层的这个镜像
[03:34/06:49]     基础镜像
[03:35/06:49]     这个S的这个镜像
[03:37/06:49]     大家能明白吧
[03:39/06:49]     都依赖它
[03:40/06:49]     它上层也是
[03:41/06:49]     再上层可能就是APP了
[03:45/06:49]     在这之上
[03:46/06:49]     我可以构建多个APP的镜像层
[03:53/06:49]     都是一样的
[03:57/06:49]     一层依赖一层
[04:03/06:49]     这我给大家举一个例子
[04:04/06:49]     一层一层一层一层的
[04:06/06:49]     一层上层依赖下层
[04:08/06:49]     这的好处是什么呢
[04:10/06:49]     我镜是按照这的方式设计的镜分
[04:15/06:49]     我们先制作一个基础的镜像
[04:19/06:49]     然后再去根据我们的需要
[04:21/06:49]     比如说再设置一个语言的镜像层
[04:25/06:49]     语层只是装了GDK和这样的一些工具
[04:28/06:49]     一些语的语的配置环境变量这些东西
[04:31/06:49]     但是呢
[04:32/06:49]     它依赖操作系统的一些东西呢
[04:35/06:49]     都是在基础进行层的
[04:38/06:49]     然后再然后呢
[04:39/06:49]     我们在这些时上呢
[04:40/06:49]     可以构建各种各样的软件了
[04:42/06:49]     比如说我们好多模块都是用Java编写的
[04:45/06:49]     我们的产品里面好多模块都是Java编写的
[04:47/06:49]     那都可以去做这些模块镜像的时候
[04:49/06:49]     其实都可以去指定这个Java这一层作为
[04:54/06:49]     技术营销
[04:56/06:49]     这样的好处是什么呢
[04:58/06:49]     首先就是节省磁盘空间嘛
[05:00/06:49]     就是接磁盘空间说接层一般S差不多有五六百兆吧
[05:05/06:49]     假如说是600兆
[05:09/06:49]     它是600兆
[05:11/06:49]     然后加二这一层呢
[05:12/06:49]     可能有100兆
[05:14/06:49]     代码没多少
[05:16/06:49]     可能50兆就行了
[05:20/06:49]     如果说我们的上层的应用
[05:22/06:49]     依赖了全都是同样的基础层
[05:26/06:49]     那么我们就可以节省很大的磁盘空间
[05:31/06:49]     我们节省可以节省很大的磁盘空间
[05:33/06:49]     所以说我们在编写docker file的时候
[05:36/06:49]     大家都知道这是到票
[05:38/06:49]     你不要做做一个特别大的镜像
[05:44/06:49]     不要做一个特别大的镜像
[05:46/06:49]     你要分层
[05:48/06:49]     比如说你这里有十个业务
[05:50/06:49]     假如说有七个是Java的业务
[05:55/06:49]     这是七个加的业务呢
[05:56/06:49]     你就可以把它提炼成一个
[05:58/06:49]     为这七个业务提炼成一个加层出来
[06:02/06:49]     大家能理解我的意思吧
[06:04/06:49]     这样的话是能够接上磁盘开销的
[06:07/06:49]     这是为什么我P
[06:11/06:49]     画成了这样的一个图
[06:14/06:49]     我们是需要
[06:18/06:49]     我们是需要去这个根据我们的需要
[06:23/06:49]     设计不同的层次
[06:25/06:49]     设计不同的层次来做我们的复用
[06:28/06:49]     节省磁盘的空间
[06:35/06:49]     多要合理
[06:44/06:49]     好
[06:45/06:49]     这就是这节课的内容



## 72、docker 容器技术-直播训练营



### 1、【直播实战】docker 进阶实战
[00:03/03:53:56]     [以下字幕均由机器生成]Hello
[00:05/03:53:56]     [以下字幕均由机器生成]大家好
[00:07/03:53:56]     [以下字幕均由机器生成]我们调试一下设备
[00:10/03:53:56]     大家看我的画面
[00:11/03:53:56]     还有听我的声音都还正常吗
[00:21/03:53:56]     OK
[00:22/03:53:56]     都正常
[00:23/03:53:56]     好吧
[00:24/03:53:56]     那我们就要开始今天的课程了
[00:27/03:53:56]     我们在节前的时候呢
[00:28/03:53:56]     曾经给大家讲过刀客容器实战相关的一些内容
[00:33/03:53:56]     我给大家复简单复习一下
[00:35/03:53:56]     主要是先概括总结一下
[00:38/03:53:56]     主要是复习需要复习一下我们刀cker常用的启动容器
[00:43/03:53:56]     还有过容器管理相关的命令
[00:46/03:53:56]     然后呢
[00:48/03:53:56]     也带大家去使用docker去启动各种各样的场景
[00:53/03:53:56]     包括我们上节课可能后在上课的后半段详细给大家讲解了如何通过刀cker去启动普罗米修斯
[01:01/03:53:56]     并配置一个监控系统
[01:03/03:53:56]     以及如何利用这个刀客的原理
[01:09/03:53:56]     也就是我们的名称空间
[01:12/03:53:56]     利用民空间去进行故障的注入故障的注入
[01:18/03:53:56]     总结一下
[01:19/03:53:56]     这两部分内容可能会最别重要
[01:22/03:53:56]     尤其是后半段
[01:23/03:53:56]     最后我们讲解的是故障注入那一段
[01:27/03:53:56]     那一段是涉及到了容器的比较底层的原理
[01:31/03:53:56]     就是涉及到Linux相关的一些东西
[01:33/03:53:56]     然后知道老师我就是其实前两天也出去面试了
[01:36/03:53:56]     也出去面试了
[01:39/03:53:56]     面试一家语音公司
[01:40/03:53:56]     那其实他考核的就是你
[01:43/03:53:56]     如何进行故障注入
[01:45/03:53:56]     就是他不会听你说什么呢
[01:47/03:53:56]     不会听你说
[01:48/03:53:56]     你是用carespla或者SSH进行故障注入
[01:50/03:53:56]     他要求你解释什么呢
[01:52/03:53:56]     他要求你解释这两个工具在故障注入的原理是什么
[01:57/03:53:56]     他要你解释它的原理是什么
[02:00/03:53:56]     大概能明白吧
[02:02/03:53:56]     这样的话呢
[02:03/03:53:56]     就是所以说这个可能有些同学上节课的时候会会比较好奇
[02:08/03:53:56]     说我有各种各样的工具
[02:11/03:53:56]     我可以下载一个kpla的
[02:13/03:53:56]     我也可以下载一个KS
[02:15/03:53:56]     在这个KS里面
[02:16/03:53:56]     或者是在容器里面
[02:17/03:53:56]     又或者是在这个虚拟机里面去进行故障的注入
[02:21/03:53:56]     那我为什么还要学这些原理呢
[02:24/03:53:56]     就是因为如果你想要在这个领域里面往更深入的方向去发展
[02:28/03:53:56]     那你抛开不掉
[02:30/03:53:56]     你避免不了要学的更深入你
[02:34/03:53:56]     就是说如果你想达到一个专家岗位这么一个位置的话
[02:38/03:53:56]     那你肯定不是说这些东西你会用就行
[02:40/03:53:56]     而是什么呢
[02:41/03:53:56]     而是你深入的了解它的一些原理
[02:43/03:53:56]     并且根据它的原理能做出一些的事情
[02:47/03:53:56]     这也是为什么我上课在最后呢
[02:49/03:53:56]     宁愿给大家拖一会堂
[02:50/03:53:56]     也要给大家去讲一下这方面的东西
[02:54/03:53:56]     这个希望大家能注意一下
[02:55/03:53:56]     如果后续大家有想去什么阿里云
[02:57/03:53:56]     腾讯云
[02:58/03:53:56]     华为云
[02:59/03:53:56]     这些云公司里面
[03:01/03:53:56]     去这个去工作
[03:05/03:53:56]     那么我上节课讲这些内容
[03:07/03:53:56]     大家都要去了解到了解到好
[03:10/03:53:56]     那现在开始我们复习一遍吧
[03:13/03:53:56]     这个毕竟已经隔了两个多礼拜了
[03:15/03:53:56]     中间隔了一个假期
[03:16/03:53:56]     我不知道大家有没有回去好好自己的练习
[03:18/03:53:56]     但是不管大家是怎么样
[03:21/03:53:56]     那我给大家复习一下
[03:23/03:53:56]     我给大家复习一下
[03:24/03:53:56]     那么复习一下的它的这个
[03:29/03:53:56]     它的这个从哪开始复习呢
[03:30/03:53:56]     就就先从简单的开始
[03:32/03:53:56]     我们先从容器的管理
[03:35/03:53:56]     Docker PS命令
[03:36/03:53:56]     还有知道通过docker PS命令我们是列出当前正在容运行的容器
[03:43/03:53:56]     大家可以看到这是我们当前机器运行的容器
[03:46/03:53:56]     之所以有这么多
[03:49/03:53:56]     这是因为我在这上面启动了一个K8S集群
[03:52/03:53:56]     我自己有时候会备课
[03:54/03:53:56]     自己做实验
[03:55/03:53:56]     会启动KS群
[03:56/03:53:56]     就是在这里KY机群
[03:58/03:53:56]     所以说这些这么一长串的都是KYS集群需要的镜象
[04:02/03:53:56]     需要的容器
[04:03/03:53:56]     所以说大家可以不用管
[04:05/03:53:56]     而这个呢
[04:06/03:53:56]     是我启动的
[04:07/03:53:56]     是我刚才备课的时候启动的一个getb的一个容器
[04:11/03:53:56]     启动一个getb一个容器
[04:13/03:53:56]     我们刚才说do PS命令会列出所有正在运行的容器
[04:18/03:53:56]     但是其实它会有也会有一些什么东西呢
[04:20/03:53:56]     也会有已经停止运行的容器
[04:23/03:53:56]     那所以说如果我们想看的话
[04:25/03:53:56]     加一个杠a这个参数对在回车你可以看到很多处于退出状态的
[04:30/03:53:56]     你看
[04:33/03:53:56]     状态这容器也会被列出来也会被列出来
[04:37/03:53:56]     然后高除了单位之外
[04:39/03:53:56]     还有一个杠S命令
[04:40/03:53:56]     那这个命令会比较长
[04:42/03:53:56]     它要统计你所有正在
[04:46/03:53:56]     你所有的容器
[04:47/03:53:56]     统计你所有的容器所占用的磁盘空间
[04:52/03:53:56]     每一个容器所占的磁盘空间
[04:53/03:53:56]     所以说它的运行的时间会比较长
[04:57/03:53:56]     尤其是如果你在工作环境中
[04:58/03:53:56]     一台机器里面启动了两三百个容器的时候
[05:05/03:53:56]     这不要奇怪
[05:06/03:53:56]     一台机器上起两三百容器是非常正常
[05:08/03:53:56]     是非常正常的
[05:09/03:53:56]     这也是容器和虚拟之间的区别嘛
[05:12/03:53:56]     那虚容器没有虚拟化内核
[05:14/03:53:56]     所以说容器是什么呢
[05:15/03:53:56]     容器它可以干一些什么事情呢
[05:18/03:53:56]     它可以用很少的资源把你的这些服务都启动起来
[05:23/03:53:56]     这是它跟虚拟机不一样了
[05:25/03:53:56]     所以说你在1000机器上启动几百个容器
[05:26/03:53:56]     实际上是是是是很正常的一件事情
[05:29/03:53:56]     那当我们用杠S这个命令的时候
[05:32/03:53:56]     我们可以看到这多出了一个叫size的引列
[05:37/03:53:56]     就代表了你当前容器运行的时候所占用的磁盘空间
[05:43/03:53:56]     这里边有两个值
[05:44/03:53:56]     一个值是
[05:45/03:53:56]     在括号外面的代表了
[05:47/03:53:56]     就是说你这个容器启动之后
[05:48/03:53:56]     你像磁盘空间新写入的
[05:52/03:53:56]     新写入的这个文件的大小
[05:57/03:53:56]     而后面是握
[05:58/03:53:56]     括号里边有一个握
[05:59/03:53:56]     握是什么呢
[06:00/03:53:56]     代表虚拟的
[06:01/03:53:56]     你可以理解为什么你可以
[06:03/03:53:56]     你暂且可以把它理解为它镜像所占用的磁盘空间
[06:07/03:53:56]     那它为什么占是握手呢
[06:09/03:53:56]     这部分内容呢
[06:11/03:53:56]     可能是今天的我们讲镜像的时候要给大家详细讲解的
[06:15/03:53:56]     因为镜像层是可以是可以被共享的
[06:20/03:53:56]     镜像层是可以自己共享的
[06:21/03:53:56]     也就是说所有的这些镜像
[06:23/03:53:56]     你假如说你看到一共十个镜像
[06:25/03:53:56]     每个镜像显示是一个G
[06:28/03:53:56]     你可能认为它这个这些镜像实际的占样环境空间可能是十个G
[06:32/03:53:56]     但其实不是这样的
[06:33/03:53:56]     因为镜像层和镜像之间是可以共享的
[06:36/03:53:56]     是可以共享的
[06:37/03:53:56]     它可以复用的
[06:38/03:53:56]     所以说实实际上它可能是没有占用实际那么大的
[06:41/03:53:56]     所以说它这里面只会显示一个叫的一个大小
[06:47/03:53:56]     就是说这个这个镜像可能占了2.25GB大小
[06:51/03:53:56]     但是说什么呢
[06:52/03:53:56]     这可能不是他独立占有的
[06:54/03:53:56]     因为可能其他的容器
[06:56/03:53:56]     就是其他的镜像也共享了这个这部分空这个这个文件
[07:00/03:53:56]     也复用了这部文件
[07:03/03:53:56]     所以说这不是它独占的这个磁盘空间
[07:07/03:53:56]     这个需要大家能理解
[07:08/03:53:56]     这需要大家理解
[07:09/03:53:56]     这节课在后面的时候
[07:10/03:53:56]     我会详细给大家讲解这部分的原理
[07:12/03:53:56]     好吧
[07:13/03:53:56]     OK
[07:14/03:53:56]     这是dops命令dops命令我们常用的管理容器
[07:19/03:53:56]     还有一些其他的命令吗
[07:21/03:53:56]     比如说do logs命令
[07:25/03:53:56]     Do logs是干什么的呢
[07:27/03:53:56]     它是专门的去看容器的日志的
[07:31/03:53:56]     比如说你写一个容器的
[07:33/03:53:56]     Get lab容器的名称
[07:37/03:53:56]     它会告诉你它的值
[07:40/03:53:56]     如果你又加了一个杠F
[07:41/03:53:56]     那它会不停的追加
[07:44/03:53:56]     你看它会不它会到不停的追加
[07:46/03:53:56]     不停的追加
[07:48/03:53:56]     在这个就跟效果就跟T杠F是一样的T杠F是一样的
[07:53/03:53:56]     OK
[07:54/03:53:56]     那除了还有exec
[07:57/03:53:56]     这个是干什么呢
[07:59/03:53:56]     这个是容器去执行一条命令
[08:04/03:53:56]     当然有些和这里边最常用的用法是跟什么
[08:07/03:53:56]     跟一个
[08:08/03:53:56]     跟一个BI或者跟ESH代表了以容器的身份打开一个窗口
[08:14/03:53:56]     这样你就达到了间接的登录到容器里的目的
[08:18/03:53:56]     当然这个命令它不是只能够
[08:22/03:53:56]     它不是只能够去做登录用的
[08:25/03:53:56]     因为你跟一个是按照容器的这个身份打一个打开一个窗口
[08:31/03:53:56]     但是如果你输入别的命令
[08:32/03:53:56]     比如说P命令W100度
[08:38/03:53:56]     卧底是不是得拿这个
[08:43/03:53:56]     引号给围上
[08:46/03:53:56]     没有ping命令是吗
[08:47/03:53:56]     没有令了
[08:48/03:53:56]     那用一个什么呢
[08:49/03:53:56]     那用LS命令有吧
[08:51/03:53:56]     你看LS命令有LS命令有
[08:54/03:53:56]     那所以说你看它就在容器里面运行了一个LS
[08:57/03:53:56]     你可以看到这是容器里面的目录
[09:01/03:53:56]     没有目录
[09:02/03:53:56]     所以说真正的docker exec
[09:04/03:53:56]     它的这个作用是在容器当中执行一个命令
[09:12/03:53:56]     是只能好吧
[09:17/03:53:56]     是CT get查看这个容器的原信息
[09:26/03:53:56]     大家还记得上节课我们去讲如何在容器当中进行故障注入吗
[09:31/03:53:56]     它的原理就是什么呢
[09:32/03:53:56]     你就需要doer in克命令
[09:35/03:53:56]     你需要找到这个容器的PID
[09:38/03:53:56]     大家还记得吧
[09:39/03:53:56]     容器就是进程
[09:41/03:53:56]     其中一个容器实际上就是启动一个进程
[09:43/03:53:56]     只是它用不同的民生空间启动的而已
[09:45/03:53:56]     所以说它一定会有一个进程ID
[09:47/03:53:56]     你找到它的PID
[09:48/03:53:56]     你才能够进行故障的注入
[09:50/03:53:56]     对吧
[09:52/03:53:56]     这是docker inpi
[09:54/03:53:56]     还有一些什么呢
[09:55/03:53:56]     还有一个比如说docker info
[09:58/03:53:56]     它是查看当前容在这整个这台机器维度的这个容器的一些基本信息
[10:06/03:53:56]     包括它当前的容器数量
[10:09/03:53:56]     镜像数量
[10:10/03:53:56]     当前安装的安装的这个版本等等等等一些相关的一些信息都是在这里的
[10:18/03:53:56]     包括他会把当前的系统架构给你列出来
[10:21/03:53:56]     你看它的系统类型是Linux
[10:25/03:53:56]     它的架构是叉8664
[10:29/03:53:56]     然后它的CPU现在有八核
[10:31/03:53:56]     然后16个G8核16个G
[10:35/03:53:56]     然后它保存的径是这导保存的径是这里那这些呢
[10:40/03:53:56]     是我们常用的容器管理命令
[10:43/03:53:56]     当然我们还有容器运行
[10:45/03:53:56]     就是如果说你需要去运行一个容器的话干什么呢
[10:49/03:53:56]     说对吧
[10:52/03:53:56]     然后杠杠name首一个容器的名称
[10:55/03:53:56]     比如说N
[10:56/03:53:56]     然后杠P端口映射对吧
[10:59/03:53:56]     比如说
[11:01/03:53:56]     比如说你把8080端口应该是到八零端口这个启动
[11:04/03:53:56]     我记得没错的话
[11:05/03:53:56]     应该是八零端口启动的
[11:06/03:53:56]     对吧
[11:07/03:53:56]     然后你在杠D后台运行
[11:09/03:53:56]     对然后这个再然后你用这个NGX的这个镜像去启动
[11:18/03:53:56]     当然它还有一些其他参数
[11:19/03:53:56]     比如说什么呢
[11:20/03:53:56]     刚刚CPU
[11:22/03:53:56]     比如说你限制它最多使用两个核的CPU
[11:26/03:53:56]     或者再加一个杠
[11:27/03:53:56]     M那种在2G
[11:30/03:53:56]     或者是200兆
[11:31/03:53:56]     限制它最高能使用200兆的内存空间
[11:36/03:53:56]     你也可以加一个什么杠
[11:39/03:53:56]     你可以加一个加一个
[11:41/03:53:56]     比如说刚刚restar等于true
[11:44/03:53:56]     Start等于true代表什么呢
[11:51/03:53:56]     代表什么呢
[11:53/03:53:56]     代表这个等老拼错代表这个它do自动帮你重启等等等
[11:59/03:53:56]     这个我不细讲了
[12:00/03:53:56]     只是给大家稍微复习一下
[12:03/03:53:56]     这是我们运行时期的一些
[12:07/03:53:56]     运行时期的一些需要的命令命令
[12:10/03:53:56]     但是着重的给大家还要再复习一下
[12:12/03:53:56]     我们再给大家演示一下
[12:14/03:53:56]     光注入
[12:16/03:53:56]     刚才我们说过
[12:18/03:53:56]     假设说我们现在在这里
[12:24/03:53:56]     大家可以看到
[12:25/03:53:56]     在这里面我们已经有一个启动着的给他
[12:30/03:53:56]     一个一个get
[12:35/03:53:56]     入才inspect
[12:42/03:53:56]     找到这个容器的PID
[12:48/03:53:56]     我们搜一下
[12:50/03:53:56]     这PID
[12:52/03:53:56]     找到这PID
[12:53/03:53:56]     然后再下一个
[12:54/03:53:56]     大家还记不记得用什么命令
[12:55/03:53:56]     用NS
[12:56/03:53:56]     就是用来切换名称空间的NS
[13:01/03:53:56]     然后杠T
[13:03/03:53:56]     指定你要切换哪个进程的名称空间
[13:05/03:53:56]     然后你
[13:07/03:53:56]     这里面就写PID嘛
[13:08/03:53:56]     然后你再去用杠N指定去切换它的网络名称空间
[13:13/03:53:56]     然后回车
[13:15/03:53:56]     然后这时候大家可以看到了
[13:17/03:53:56]     现在我虽然还在主机上
[13:19/03:53:56]     但是我的网络已经切到了容器里面我的网络已经切到了容器里面
[13:26/03:53:56]     大家还记得名称空间的
[13:29/03:53:56]     名称空间的这个
[13:33/03:53:56]     含义吧
[13:34/03:53:56]     对吧
[13:35/03:53:56]     每一个容器启动的时候都会有独立的名称空间
[13:40/03:53:56]     都会有独立的名称空间
[13:43/03:53:56]     容器是用名称空间进行通信上的隔离的
[13:48/03:53:56]     大家可以把什么呢
[13:50/03:53:56]     可以把容器当成是
[13:54/03:53:56]     就是把容器当成是一个进程来看
[13:57/03:53:56]     然后一个进程可以把它当成一个对讲机来看
[14:02/03:53:56]     对讲机之间通信呢
[14:03/03:53:56]     需要把他们各自的频道调调调整到同一个频道上
[14:08/03:53:56]     那这个频道就可以当成是一个什么
[14:10/03:53:56]     当成是一个对讲
[14:11/03:53:56]     不当成是这个名称空间所以说频道是可以切的
[14:17/03:53:56]     比如说我现在四语机里面
[14:18/03:53:56]     我就可以切到某一个容器的频道上
[14:21/03:53:56]     就切到某一个容器的名称空间上
[14:24/03:53:56]     这样的话我进入到它的名称空间里
[14:27/03:53:56]     我就可以操控它
[14:28/03:53:56]     这是我们故障注入的原理
[14:30/03:53:56]     这部分非常重要
[14:31/03:53:56]     所以说NSN这个命令干的事情
[14:35/03:53:56]     干的事情就是切换民生空间
[14:37/03:53:56]     所以说我刚才用命令大家可以看到
[14:42/03:53:56]     用这个命令我看到网络设备
[14:46/03:53:56]     我看到的网络设备是容器的
[14:48/03:53:56]     如果我退出了
[14:49/03:53:56]     我退出以后我再用
[14:51/03:53:56]     你看到了是四五机的
[14:53/03:53:56]     你看到四五有这么多网络设备
[14:54/03:53:56]     有零
[14:55/03:53:56]     有CIA这些这么多
[14:58/03:53:56]     有flyno这么多
[14:59/03:53:56]     但是如果我进入到容器里面
[15:01/03:53:56]     我只能看到零一个是它的虚拟网卡
[15:04/03:53:56]     一个是它的本地回环设备
[15:06/03:53:56]     就是自己拼自己用的
[15:07/03:53:56]     你看这里有个look back回环设备
[15:09/03:53:56]     自己拼自己的时候会用到这个东西
[15:14/03:53:56]     归纳这个东西
[15:15/03:53:56]     OK
[15:16/03:53:56]     那现在我经
[15:19/03:53:56]     我已经在我们的这个容器的网络名称空间里了
[15:25/03:53:56]     你看我现在刷新我这还是可以能够看得到的
[15:28/03:53:56]     那我要一个故障怎么呢
[15:30/03:53:56]     IP tables
[15:34/03:53:56]     埃佩洛杠a
[15:38/03:53:56]     比如说我在哪呢
[15:43/03:53:56]     在pray或者说在output吧
[15:47/03:53:56]     OUTPUT2张
[15:49/03:53:56]     就加一个规则
[15:50/03:53:56]     加这个规则是什么
[15:51/03:53:56]     就是加一个动作是什么呢
[15:53/03:53:56]     加一个动作是drop
[15:56/03:53:56]     是不是还得有一个杠
[16:00/03:53:56]     PTCP
[16:02/03:53:56]     我这个命令有点不太记得了
[16:06/03:53:56]     IP
[16:09/03:53:56]     杠a
[16:14/03:53:56]     我查一下
[16:16/03:53:56]     这个命令突然有点不太记得了
[16:18/03:53:56]     IP tables
[16:23/03:53:56]     A杠
[16:34/03:53:56]     还是我哪拼错了
[16:47/03:53:56]     IP tables
[16:48/03:53:56]     添加规则
[16:54/03:53:56]     杠input
[16:59/03:53:56]     杠a、杠G
[17:04/03:53:56]     是必须大写是不是
[17:07/03:53:56]     对果然是必须大写
[17:09/03:53:56]     这个这个这个错了
[17:11/03:53:56]     这一条规则是什么意思呢
[17:14/03:53:56]     这条规则是说我在IP tables链出链
[17:19/03:53:56]     出口链上我加一条规则是什么
[17:22/03:53:56]     就丢包
[17:23/03:53:56]     我让它出不去
[17:24/03:53:56]     我让网络是我网网络请求是出不去
[17:28/03:53:56]     这个容这个机器的
[17:30/03:53:56]     所以说那我现在到了这个容器里面
[17:33/03:53:56]     我再刷新
[17:34/03:53:56]     他应该是不行的
[17:37/03:53:56]     大家可以看到这个一直在转圈
[17:39/03:53:56]     它一直在转圈
[17:41/03:53:56]     他他已经访问不到了
[17:42/03:53:56]     他已经访问到你点哪都是没有反应的
[17:44/03:53:56]     已经访问不到了
[17:47/03:53:56]     因为我已经在这边把这个网络流量都给丢包了大家注意什么
[17:53/03:53:56]     大家注意是你你在input链和output链去注入故障
[17:59/03:53:56]     它的行为是不一样的
[18:04/03:53:56]     它的行为是不一样
[18:05/03:53:56]     大家可能这个在故障之入里面
[18:08/03:53:56]     就如果不熟悉的
[18:09/03:53:56]     可能区分不出它的它的这个它的这个这什么
[18:13/03:53:56]     它的这个这个这个这个区别
[18:16/03:53:56]     你可能区分不出来它这个区别
[18:18/03:53:56]     它区别是什么呢
[18:19/03:53:56]     它区别我给他换一下
[18:22/03:53:56]     我给它换一下
[18:29/03:53:56]     是今天用不上什么什么PPT
[18:31/03:53:56]     但是我先打开一个
[18:32/03:53:56]     主要是为了给大家画一下的区别是什么
[18:36/03:53:56]     这不知道大家还记不记得
[18:39/03:53:56]     其实上节课我讲过
[18:41/03:53:56]     对于这个it是它有四表五链
[18:45/03:53:56]     四表五链比如说它的入口是input链
[18:50/03:53:56]     它的出口是output链
[18:56/03:53:56]     Output
[18:57/03:53:56]     然后这个还有进入入口之
[19:03/03:53:56]     其实还有一个叫什么叫做
[19:06/03:53:56]     叫做路由前叫pray
[19:08/03:53:56]     就是routine
[19:09/03:53:56]     然后还有一个pray
[19:12/03:53:56]     还有一个post routine路由后
[19:16/03:53:56]     然后还有一个什么呢
[19:18/03:53:56]     Forward转发链
[19:23/03:53:56]     不知道大家还记不记得我不知道大家记不记得
[19:26/03:53:56]     就上课我讲过这五条量
[19:27/03:53:56]     这五条代表什么
[19:29/03:53:56]     代表的是一个网络流量一个网络请求
[19:35/03:53:56]     Linux内核当中的生命周期的五个阶段
[19:40/03:53:56]     它是整个网络流转的生命周期的五个阶段
[19:44/03:53:56]     一个网络请求先进入到这台机器的时候
[19:48/03:53:56]     是进入到哪呢
[19:49/03:53:56]     先进入到pre
[19:50/03:53:56]     就是由前
[19:52/03:53:56]     进入到由前这个上
[19:56/03:53:56]     由前这个链上这个时候呢
[19:59/03:53:56]     你可以在由前这个链上你去干什么呢
[20:04/03:53:56]     你去添加一些规则进对它进行拦截
[20:08/03:53:56]     如果是发送到本机的
[20:11/03:53:56]     如果是发送到本机的网络请求
[20:13/03:53:56]     它会放到input链上
[20:16/03:53:56]     就是流入这个入口
[20:17/03:53:56]     然后input链会给进程去处理
[20:21/03:53:56]     然后在处理的结果放到这个output链上流出
[20:25/03:53:56]     然后再经过后
[20:28/03:53:56]     再经过路由后去那什么的
[20:30/03:53:56]     去那个再把它浏览出去
[20:32/03:53:56]     那如果你发送的不是本机
[20:35/03:53:56]     那它会转发到所有的链上
[20:38/03:53:56]     这大家还记得吧
[20:39/03:53:56]     大家讲的
[20:40/03:53:56]     我给大家讲的好吧
[20:42/03:53:56]     那所以说为什么你在input链或者说你在链上去注入故障和在output output链上去注入故障是不一样的呢
[20:51/03:53:56]     为什么说不一样的
[20:52/03:53:56]     因为什么呢
[20:53/03:53:56]     因为如果你的网络请求已经通过了链
[20:58/03:53:56]     它下一步干嘛
[20:59/03:53:56]     应链一旦一旦通过了之后
[21:01/03:53:56]     它就传给进程了
[21:02/03:53:56]     进程开始处理了
[21:03/03:53:56]     假如说你要你要干什么呢
[21:07/03:53:56]     你要注入的一个故障
[21:12/03:53:56]     这个这个服务是用来去数据库添加一条记录的
[21:17/03:53:56]     如果说你是在input链之前
[21:22/03:53:56]     就是在input这个链上就已经把故障注入进去了
[21:26/03:53:56]     比如说包了
[21:28/03:53:56]     那你的这个请求是传到进程的
[21:32/03:53:56]     是传不到进程上的
[21:33/03:53:56]     那所以说这个进程压根没到这个请求
[21:35/03:53:56]     而如果是out链
[21:39/03:53:56]     去注入了这个故障
[21:40/03:53:56]     那也就是说你的请求已经经过进程处理完了
[21:46/03:53:56]     他已经处理完毕了
[21:50/03:53:56]     可能已经保存在自己的文件系统里了
[21:51/03:53:56]     他已经处理完毕了
[21:53/03:53:56]     然后呢
[21:54/03:53:56]     你返回的时候失败了
[21:57/03:53:56]     它返回的时候失败了
[21:59/03:53:56]     就是给给你的客户端一个返回应的请求的时候失败了
[22:03/03:53:56]     因为在你的out链上已经注入故障
[22:05/03:53:56]     所以说大家要区分出UT入程
[22:16/03:53:56]     你希望理这个请求
[22:19/03:53:56]     你就在上去注故障
[22:21/03:53:56]     如果你不希望理请求的话
[22:23/03:53:56]     那你就在input上去注入故障
[22:25/03:53:56]     要注意在不同的测试目的下你要注入的
[22:29/03:53:56]     地方是不一样的注入的地方是不一样的
[22:33/03:53:56]     比如说你想测的是
[22:36/03:53:56]     你想测的是什么呢
[22:37/03:53:56]     你想测的是数据会不会丢
[22:39/03:53:56]     那你就在链上
[22:42/03:53:56]     去助手故障
[22:43/03:53:56]     如果你想测的是数据
[22:44/03:53:56]     会不会重复
[22:46/03:53:56]     那你就是在out上去进行故障植入为什么呢
[22:51/03:53:56]     因为你你想验证一下数据会不会重复
[22:55/03:53:56]     那这种场景一般来说是什么场景呢
[22:57/03:53:56]     一般来说是
[22:59/03:53:56]     针对一个高可能的设计请求
[23:02/03:53:56]     一个设计它一定会要retri
[23:04/03:53:56]     比如说这是你的S端
[23:10/03:53:56]     这是你的client
[23:14/03:53:56]     一般来说
[23:15/03:53:56]     Server请求client
[23:18/03:53:56]     Client请求server client请求server
[23:20/03:53:56]     然后server处理完之后要把请求
[23:24/03:53:56]     就又会返回来
[23:27/03:53:56]     就通知他
[23:28/03:53:56]     你可以理解为发一个AC啊
[23:30/03:53:56]     通知他就是请求已经处理成功了
[23:32/03:53:56]     那么如果说你的故障发生在什么阶段呢
[23:35/03:53:56]     如果说client向sir请求是没有发生故障的
[23:40/03:53:56]     是没发生故障
[23:41/03:53:56]     Server已经把这条记录已经保存到了
[23:45/03:53:56]     比如说它它它它这是一个insert的一个请求
[23:48/03:53:56]     这套记录
[23:50/03:53:56]     已经保存到他的自己的库里面了
[23:55/03:53:56]     已经保存到自己的库里
[23:56/03:53:56]     已经保存好了
[23:57/03:53:56]     但是它返回给client的时候挂了
[24:02/03:53:56]     就是在这挂了
[24:05/03:53:56]     这个时候按照高可用的设计是什么呢
[24:07/03:53:56]     一般来说高可用设计它要进行re try重试
[24:13/03:53:56]     要重试
[24:14/03:53:56]     你这条请求挂了吗
[24:16/03:53:56]     因为从的角度来看
[24:17/03:53:56]     他不知道是不是真的已经保存好了
[24:20/03:53:56]     反正他认为我我我我没有拿到返回值
[24:23/03:53:56]     我已我觉得我已经挂了
[24:24/03:53:56]     挂了那我就要重试
[24:26/03:53:56]     那我就重试
[24:27/03:53:56]     那这时候会出现什么问题
[24:29/03:53:56]     它会不会导致于sor
[24:30/03:53:56]     因为它重新重试又重新进去
[24:32/03:53:56]     它会不会多一个数据
[24:38/03:53:56]     这是高可能测试的一个场景
[24:41/03:53:56]     这里给大家扩展一下
[24:42/03:53:56]     这是高测试的一个场景
[24:44/03:53:56]     验证你视你的接口是不是密等的
[24:48/03:53:56]     如果是密等的话
[24:50/03:53:56]     Serve端是有能力判断出你又发送过来的这个请求它是不是重复的
[24:58/03:53:56]     它不会重复保存
[25:00/03:53:56]     如果你会发现
[25:01/03:53:56]     如果你注入故障之后
[25:02/03:53:56]     然后这个不停的重试的前提下
[25:05/03:53:56]     你的serve这里面的数据重复数据已经开始堆积了
[25:08/03:53:56]     就证明什么呢
[25:10/03:53:56]     就证明有bug了它是没有设计好它的密等性的
[25:15/03:53:56]     所以说我回到刚才那个话题
[25:18/03:53:56]     在input去注入链上去注入故障和在output链上去注入故障是不一样的
[25:26/03:53:56]     是不一样的
[25:27/03:53:56]     这个大家弄清楚
[25:28/03:53:56]     OK
[25:29/03:53:56]     然后我还得把这个恢复了l input
[25:37/03:53:56]     嗯
[25:39/03:53:56]     Happy both
[25:44/03:53:56]     又有点忘了这个规则
[25:49/03:53:56]     不是干嘛
[25:54/03:53:56]     太长时间不用
[25:57/03:53:56]     已经有点忘了查看当前
[26:04/03:53:56]     规则
[26:20/03:53:56]     这out库链上
[26:25/03:53:56]     好
[26:29/03:53:56]     我可以只查奥特的字
[26:31/03:53:56]     不行啊
[26:35/03:53:56]     太久没用这个命令了
[26:41/03:53:56]     那我就得用ipks杠D
[26:47/03:53:56]     D编号1OUTPUT对在后边
[26:55/03:53:56]     OK
[26:56/03:53:56]     我把这个规则再删掉
[26:57/03:53:56]     故障删掉之后我再刷新你看
[27:00/03:53:56]     就又回来了
[27:01/03:53:56]     你就能刷新出来了
[27:03/03:53:56]     OK
[27:04/03:53:56]     大家能明白
[27:05/03:53:56]     好讲到这大家复习给大家复习到这
[27:08/03:53:56]     大家有没有什么懵逼的地方吗
[27:10/03:53:56]     还有什么懵逼的地方吗
[27:26/03:53:56]     大家稍等我一下
[27:27/03:53:56]     我到这
[27:40/03:53:56]     好
[27:55/03:53:56]     大家没有问题吗
[27:59/03:53:56]     我看没有人
[28:06/03:53:56]     你设置了ipcs
[28:08/03:53:56]     云服务器进不去了
[28:10/03:53:56]     你当然进不去了
[28:12/03:53:56]     你真敢就在直接在云服务器上干这事
[28:16/03:53:56]     这我我是个务己
[28:26/03:53:56]     自己的名生空间里面干这件事情了
[28:28/03:53:56]     就是说IP tables你进器了
[28:33/03:53:56]     你确定吗
[28:34/03:53:56]     你进去的是容器吗
[28:36/03:53:56]     因为什么呢
[28:37/03:53:56]     因为如果你进去容器去运行的这个IP命令的话
[28:41/03:53:56]     你已经切容器的网络密称间的话
[28:43/03:53:56]     你是不会对云服务器有任何影响的
[28:46/03:53:56]     因为你们不在同一个民生空间里面
[28:50/03:53:56]     你是不是操作错了
[28:51/03:53:56]     你运行的是哪个命令
[28:53/03:53:56]     你不会运行IP叉或者当前的那个都了吧
[29:12/03:53:56]     就IP tables命令
[29:14/03:53:56]     它是比较危险的
[29:17/03:53:56]     运维经常用IPS命令来实现防火墙
[29:24/03:53:56]     来实现防火墙的这么一个目的
[29:27/03:53:56]     防火墙的这么一个目的运维
[29:29/03:53:56]     而测试人员经常用IPS用来做由或者故障注入的工具
[29:35/03:53:56]     如果你设置一个output加
[29:38/03:53:56]     像我刚才一样
[29:39/03:53:56]     如果说我刚才不是在容器里面
[29:43/03:53:56]     而是直接在降降速机里面
[29:47/03:53:56]     我运行刚才的这个
[29:49/03:53:56]     这个命令
[29:54/03:53:56]     Drop
[29:56/03:53:56]     我如果我在
[29:59/03:53:56]     现在我现在在在主机上
[30:01/03:53:56]     我没在容器里
[30:02/03:53:56]     我在机我运行这个病
[30:03/03:53:56]     我的容我的这个教学服务器也不行了
[30:06/03:53:56]     也贵了
[30:08/03:53:56]     你什么都没有了
[30:10/03:53:56]     你如果说你的你的云服务器现在登录不上了
[30:14/03:53:56]     那你一定不是在容器里面
[30:17/03:53:56]     你是在什么地方呢
[30:18/03:53:56]     你就是在云服务器当前的这个shell界面里面
[30:27/03:53:56]     你没切进去容器
[30:32/03:53:56]     你没切进去
[30:34/03:53:56]     一定是的
[30:36/03:53:56]     如果你切进去的话
[30:37/03:53:56]     它不属于同一个民生空间
[30:39/03:53:56]     你在容器的民生空间
[30:40/03:53:56]     你怎么折腾它都不可能影响到你的四级的
[30:44/03:53:56]     这东西没了
[30:45/03:53:56]     你只能联系客服重启重置了
[30:50/03:53:56]     重置服务器了
[30:52/03:53:56]     我刚想说大家这个命令一定要看好了再打
[30:55/03:53:56]     不要在自己的就是关键的服务器上打
[30:59/03:53:56]     打这个命令一定要确认好了
[31:01/03:53:56]     你是在容器里边打了这个命令
[31:03/03:53:56]     否则的话
[31:04/03:53:56]     你你如果没弄好
[31:07/03:53:56]     你就你就登录不上去了
[31:09/03:53:56]     就这事我之前干过
[31:11/03:53:56]     我我因为我在我我在公司的时候就是专门负责高可测试的嘛
[31:15/03:53:56]     就故障注入
[31:16/03:53:56]     那就是家常便家常便饭的一件事
[31:18/03:53:56]     有一次我就手滑了
[31:23/03:53:56]     不小心把那个整个服务器IP规则重置了
[31:28/03:53:56]     然后就贵了
[31:31/03:53:56]     光就贵了
[31:33/03:53:56]     这个郑博燕同学你可能得联系一下
[31:37/03:53:56]     你是哪个服务器厂商的
[31:40/03:53:56]     看看能不能把服务器重置一下
[31:42/03:53:56]     重装一下
[31:43/03:53:56]     重置一下
[31:47/03:53:56]     如果你不重置的话
[31:49/03:53:56]     那就得物理方式解决
[31:50/03:53:56]     就是你就得让人进到机房里面
[31:53/03:53:56]     不能因为你现在你现在这个操作应该是把整个这个机器的网络给废了
[31:58/03:53:56]     你任何通过网络的方式
[32:00/03:53:56]     你都防不了这台
[32:03/03:53:56]     你只能是物理连接
[32:06/03:53:56]     直接到机房里边
[32:08/03:53:56]     再把那个IP那条规则给删了
[32:10/03:53:56]     只能是这样
[32:14/03:53:56]     所以说这个故障注入需谨慎
[32:17/03:53:56]     大家这个注意一下
[32:18/03:53:56]     故障注入需谨慎
[32:20/03:53:56]     不要把自己的机器玩玩
[32:21/03:53:56]     彻底玩坏了
[32:25/03:53:56]     OK
[32:26/03:53:56]     还有什么其他问题吗
[32:32/03:53:56]     因为我觉得就是这这地方不简单
[32:35/03:53:56]     就这段地方是不简单的
[32:37/03:53:56]     我当初接触这块的时候
[32:39/03:53:56]     其实绕了好长时间才理解的
[32:41/03:53:56]     大家现在是一点问题
[33:05/03:53:56]     真的没有问题了吗
[33:12/03:53:56]     如果没有问题的话
[33:13/03:53:56]     那我们的复习内容就差不多到这了
[33:16/03:53:56]     就差不多到这了
[33:17/03:53:56]     那我们就要开始讲今天新的内容了重启恢复了
[33:22/03:53:56]     那OKOK
[33:24/03:53:56]     那我们可能就要讲今天要讲新的内容了
[33:27/03:53:56]     好吧
[33:31/03:53:56]     新的内容是什么呢
[33:33/03:53:56]     新的内容是我今天讲跟镜像有关系的东西
[33:36/03:53:56]     上节课我们都是讲容器有关的东西
[33:39/03:53:56]     就跟容器运行
[33:40/03:53:56]     故障注入这些东西有关系
[33:42/03:53:56]     今天我们讲倾向的
[33:45/03:53:56]     讲镜像管理制作镜像do file相关的内容相关的内容OK
[33:52/03:53:56]     那么
[33:53/03:53:56]     首先我们先需要讲的第一个内容是如何搭建一个镜像仓库
[34:01/03:53:56]     因为我上节课给大家讲过
[34:03/03:53:56]     如果大家希望找一些这个镜像的话
[34:07/03:53:56]     一般来说是两个途径
[34:09/03:53:56]     比如我最常我就去找do
[34:13/03:53:56]     全球最大的镜像管理网站
[34:17/03:53:56]     镜像仓库
[34:19/03:53:56]     它是全球最大的健康仓库
[34:21/03:53:56]     一般就是就是我会用do比较多当然如果你的网络环境有一些限制
[34:30/03:53:56]     也限制
[34:31/03:53:56]     比如说你的网速不是特别好
[34:33/03:53:56]     你的网速不是特别好
[34:34/03:53:56]     你可以选择用阿里云
[34:36/03:53:56]     然后你配置一个阿里的镜像加速器录播客里面有
[34:41/03:53:56]     录播客里面应该是有的
[34:42/03:53:56]     你配置一个案例的镜像加速器
[34:46/03:53:56]     然后你可以你的镜像的下载速度会比从do上会更快
[34:52/03:53:56]     会更快
[34:53/03:53:56]     但是do它毕竟它是全球公共的一个一个镜像仓库
[35:00/03:53:56]     我们在公司内部肯定是不能用do来保存自己的形象的
[35:06/03:53:56]     也最主要原因也是不安全
[35:07/03:53:56]     对吧
[35:08/03:53:56]     你把你自己公司内部的这些商业化的一些全都暴露在公网上
[35:14/03:53:56]     那肯定是不允许的
[35:16/03:53:56]     公司肯定是不允许的就是第一个原因
[35:18/03:53:56]     第二个原因也是因为太慢了
[35:21/03:53:56]     因为你在公网上跟你的公司内部网络肯定是不一样的
[35:25/03:53:56]     你的镜像的上传
[35:27/03:53:56]     下载啊
[35:28/03:53:56]     那你们的这个速度肯定是不一样的所以说一般都会去搭建一个一个私有的镜像仓库
[35:36/03:53:56]     那私有的镜像仓库要怎么搭建呢
[35:40/03:53:56]     其实也非常的简单
[35:43/03:53:56]     非常的简单
[35:44/03:53:56]     对我还我还忘了创建课程体呢
[35:47/03:53:56]     我现在先创建一个
[35:48/03:53:56]     新建话题今天是几号来着
[35:51/03:53:56]     今天是16号
[35:54/03:53:56]     Docker镜像实战
[35:58/03:53:56]     然后十月
[36:02/03:53:56]     16只
[36:05/03:53:56]     OK
[36:06/03:53:56]     然后现在先是搭建搭建镜像仓库
[36:17/03:53:56]     搭建镜像仓库
[36:19/03:53:56]     那搭建镜像仓库的
[36:23/03:53:56]     命令是什么呢
[36:26/03:53:56]     当然我PPT都有
[36:27/03:53:56]     但我还都给你们课程里
[36:29/03:53:56]     你们想
[36:30/03:53:56]     你们想PPT就PPT
[36:33/03:53:56]     你们想用课上帖就课上帖
[36:35/03:53:56]     因为我都在
[36:36/03:53:56]     我的这些所有的脚本都在我的教学服务器里面
[36:40/03:53:56]     搭建仓库的命令其实也比较简单
[36:45/03:53:56]     它也是用容器化部署的
[36:47/03:53:56]     使用的镜像的名称就是
[36:52/03:53:56]     然后版本号是二
[36:54/03:53:56]     版本是二
[36:55/03:53:56]     我们通过这种形式
[36:59/03:53:56]     通过这种形式可以把我们的镜像仓库
[37:06/03:53:56]     把我们的镜像仓库给搭建起来
[37:09/03:53:56]     给搭建起来
[37:12/03:53:56]     这里需要注意的是什么呢
[37:13/03:53:56]     当然一个是端口映射了
[37:14/03:53:56]     一个是端口映射了
[37:15/03:53:56]     因为我们毕竟这个它是用容器启动的
[37:19/03:53:56]     默认是没有办法跟它进行网络交互的
[37:22/03:53:56]     所以说你必须用端映设
[37:23/03:53:56]     然后你需要把容器的一个这样的一个目录库给挂载出来来做一个数据的持久化
[37:31/03:53:56]     因为毕竟它是有状态的
[37:32/03:53:56]     就是它是要保存数据的
[37:34/03:53:56]     你为了把这些数据持久化
[37:38/03:53:56]     所以说你必须要把它挂载出来
[37:39/03:53:56]     所以说加这个参数
[37:42/03:53:56]     然后杠
[37:45/03:53:56]     AR always这个是让它是让它自动重启
[37:50/03:53:56]     所以说命令很简单
[37:53/03:53:56]     命令很简单
[37:54/03:53:56]     没有什么过多需要讲的
[37:56/03:53:56]     我在这
[38:02/03:53:56]     给大家放在这里创建话题
[38:06/03:53:56]     然后这个地址在这边发送给你问好
[38:14/03:53:56]     我们再编辑一下
[38:15/03:53:56]     一会儿可能还是要写新的命令
[38:17/03:53:56]     搭建仓库
[38:19/03:53:56]     所以说当我们把它给bash doer image加SSH启动起来
[38:29/03:53:56]     启动起来之后
[38:31/03:53:56]     我们可以看到它就启动起来了他动起来
[38:35/03:53:56]     这里面我们需要还需要注意一件什么样的事情呢
[38:37/03:53:56]     就是如何把镜像给推送到镜像仓库里呢
[38:44/03:53:56]     如何把镜像推送到镜像仓库里呢
[38:47/03:53:56]     大家想
[38:48/03:53:56]     我们在之前用命令的时候
[38:53/03:53:56]     比如说poor my so扣
[38:57/03:53:56]     或者什么
[39:01/03:53:56]     我是没有加任何镜像仓库的信息的
[39:05/03:53:56]     那他是怎么知道
[39:07/03:53:56]     他是怎么知道去哪里去拉取镜像的呢
[39:13/03:53:56]     答案是什么呢
[39:14/03:53:56]     首先在这里面需要注意两件事情
[39:16/03:53:56]     一件事情是什么
[39:18/03:53:56]     第件事情是说docker会有默认值
[39:21/03:53:56]     如果你在使用docker命令的时候没有指定一些对应的参数
[39:26/03:53:56]     那么它就会用默认值去填充
[39:29/03:53:56]     默认值去填充
[39:30/03:53:56]     所以说这也是为什么我们使用docker铺去拉取镜像的时候
[39:35/03:53:56]     即便我没有
[39:36/03:53:56]     没有我我的
[39:38/03:53:56]     在我的这个命令行里没有任何镜像仓库的信息也能拉取
[39:41/03:53:56]     拉取下来就是因为它使用了默认参数帮我们去填充
[39:47/03:53:56]     比如说他会告诉你这边会用using defaultag告诉你会一个认本
[39:56/03:53:56]     用一个默认的版本就是
[39:58/03:53:56]     而这个版本是我们需要的是里面约定俗成的一个本
[40:04/03:53:56]     代表最新有很多用户他第一次接触一个软件的时候
[40:10/03:53:56]     可能他并不知道应该拉取哪一个版本的
[40:14/03:53:56]     软件是合适的
[40:17/03:53:56]     比如说我假如说我对不熟
[40:20/03:53:56]     我不知道哪个版本对我来说是最好的
[40:22/03:53:56]     那一般用户习惯是什么
[40:25/03:53:56]     那我就拉新的版本
[40:25/03:53:56]     我去感受一下
[40:28/03:53:56]     我去体验一下这个S这个软件最新的版本的能力是什么这是非常非常普遍的一个需求
[40:37/03:53:56]     非常普遍的一个需求
[40:38/03:53:56]     所以说在每一个镜像仓库里面
[40:41/03:53:56]     每一个镜像
[40:44/03:53:56]     它都会有一个叫的版本号
[40:47/03:53:56]     就是约定俗成的一个规范约定俗成的一个规范就是给用户
[40:52/03:53:56]     就是说他我不知道要去下载哪个镜像的时候
[40:56/03:53:56]     那我就下载这个最新的这个镜像
[41:00/03:53:56]     所以说大家要记住这是一个这是一个规则吧
[41:04/03:53:56]     当你使用镜像的时候
[41:07/03:53:56]     你在任何一个需要使用到镜像的一个场景里面
[41:11/03:53:56]     场景里面如果你没有指定它的版本号的话
[41:14/03:53:56]     刀客都会默认你使用latest的这个版本
[41:32/03:53:56]     大吧仓值library library
[41:40/03:53:56]     就是library这里
[41:42/03:53:56]     所以说大家可以看到
[41:44/03:53:56]     当你只指定这个名之后没有
[41:48/03:53:56]     镜像仓库的径也没有跟版本号的信息
[41:52/03:53:56]     但是待会会默认帮你补全默认你补全这里我们也可以知道
[41:57/03:53:56]     我们是通过在镜像名称里面
[42:02/03:53:56]     在镜像名称里面去带的镜像仓库的信息
[42:06/03:53:56]     来完成的这个镜像仓库的地址这些指令
[42:09/03:53:56]     所以说如果我们在这个场景要拉X的话
[42:12/03:53:56]     其实它的全写就是它比较完整的一个写法
[42:17/03:53:56]     应该是这样的
[42:21/03:53:56]     这是你正确的拉取
[42:23/03:53:56]     拉取的一个姿势
[42:27/03:53:56]     正确的
[42:28/03:53:56]     你要拉取一个定向的姿势
[42:30/03:53:56]     你要先把镜像仓库的地址写上
[42:33/03:53:56]     然后经过一个斜线
[42:34/03:53:56]     代表的是从前面是代表镜像仓库的地址
[42:38/03:53:56]     后面代表的是你这个镜像的名称
[42:40/03:53:56]     然后和版本号
[42:43/03:53:56]     和版本号
[42:47/03:53:56]     所以现在我们在本地
[42:52/03:53:56]     我们在本地启动了一个进行仓库
[42:55/03:53:56]     一个私有的进行仓库
[42:56/03:53:56]     我们如果要把
[43:00/03:53:56]     我们的镜像推送到这个本地的四个仓库里面
[43:04/03:53:56]     那是什么要求
[43:05/03:53:56]     我的镜像名称应该是这样的一个格式
[43:07/03:53:56]     Localhost
[43:10/03:53:56]     然后冒号5000
[43:12/03:53:56]     为什么呢
[43:13/03:53:56]     Localhot代表的是IP地址
[43:15/03:53:56]     5000代表是端口号
[43:18/03:53:56]     然后斜线
[43:20/03:53:56]     然后跟上镜像名称
[43:22/03:53:56]     然后跟上版本号
[43:24/03:53:56]     就是1.0
[43:25/03:53:56]     是这样的一个
[43:27/03:53:56]     规范
[43:28/03:53:56]     那现在我们并不具备这样的一个条件
[43:31/03:53:56]     比如说假如说我去拉了一个叫busy box的
[43:35/03:53:56]     另外box的一个
[43:39/03:53:56]     是
[43:40/03:53:56]     我现在有一个叫busy bos的一个镜像
[43:42/03:53:56]     那我们能把busy bos这个镜像推送到私有的镜像仓库吗
[43:47/03:53:56]     那还是答是不行的
[43:48/03:53:56]     比如说我们用do push busy box
[43:52/03:53:56]     你不上去的
[43:54/03:53:56]     那假如说有同学说
[43:55/03:53:56]     那我就这样行不行
[43:56/03:53:56]     我指定一个
[44:00/03:53:56]     我这么push一下可不可以
[44:02/03:53:56]     我在斜线左边
[44:03/03:53:56]     我跟上它的地址是不行
[44:05/03:53:56]     他也行不行
[44:09/03:53:56]     这怎么突然行了对不行吗
[44:13/03:53:56]     为什么他告诉你不存在
[44:16/03:53:56]     这个镜像根本就不存在
[44:20/03:53:56]     这个定向根本就不存在
[44:24/03:53:56]     就是说前面这个镜像的仓库的地址
[44:28/03:53:56]     它是属于镜像名称的一部分
[44:31/03:53:56]     我们刚才下载这个镜像的时候
[44:32/03:53:56]     它就叫box
[44:36/03:53:56]     Images
[44:41/03:53:56]     Busy box
[44:44/03:53:56]     看我们刚才下载的最新的这个
[44:46/03:53:56]     它就叫busy box
[44:48/03:53:56]     不叫别的
[44:50/03:53:56]     下面这个是我备课的时候自己做的
[44:52/03:53:56]     你就可以不用叫包
[44:54/03:53:56]     所以说现在这个镜是不具备推送到镜像仓库的资格的
[45:00/03:53:56]     那你要怎么办呢
[45:01/03:53:56]     你就得命这个一个
[45:06/03:53:56]     这个新的名字你要按规范来
[45:08/03:53:56]     就是LOCAL5000
[45:10/03:53:56]     然后比如说busy busy box
[45:19/03:53:56]     起的新的名字
[45:20/03:53:56]     当然
[45:21/03:53:56]     我们还要给他一个当前的box
[45:24/03:53:56]     当前的镜
[45:25/03:53:56]     把当前这个镜名称指定进去一个名回撤回之个命
[45:32/03:53:56]     你会发现什么呢
[45:33/03:53:56]     就发现这多了一个LOCAL5000
[45:36/03:53:56]     然后也是的一个版本号的一个景象
[45:41/03:53:56]     当然你可以看到刚才的这个叫box也在
[45:43/03:53:56]     大家一定要注意
[45:44/03:53:56]     Doctor命令很多同学都会误以为它是什么呢
[45:49/03:53:56]     它是改名的
[45:50/03:53:56]     它不是把之前的这个镜名称改了一下是什么
[45:54/03:53:56]     而是说你给这个镜添加了一个新的名字
[45:56/03:53:56]     所以说之前那个电商名称还在这儿
[45:59/03:53:56]     它还在这儿
[46:00/03:53:56]     你新的这个定向名称也在这儿
[46:03/03:53:56]     这个大家需要注意
[46:04/03:53:56]     这个需要打这那么当我们已经有了这样新的一个定向名称过去之后呢
[46:10/03:53:56]     那我们就用do push
[46:13/03:53:56]     你看这个普试成功了
[46:15/03:53:56]     这样的话就不成功
[46:17/03:53:56]     然后你到客铺呢
[46:19/03:53:56]     也可以成功a do客铺
[46:24/03:53:56]     把它铺下来
[46:25/03:53:56]     拉下来看也能拉成功
[46:28/03:53:56]     槟了
[46:29/03:53:56]     所以说这里面有几个注意点
[46:30/03:53:56]     首先你镜镜像名称的命名规范
[46:33/03:53:56]     一般来说
[46:34/03:53:56]     你在公司内部
[46:35/03:53:56]     当你去制作镜像的时候
[46:37/03:53:56]     你的镜像名称就要按照这个规范来
[46:38/03:53:56]     要不然你哪个镜像仓库你都是push不上去的
[46:42/03:53:56]     这是一个
[46:43/03:53:56]     第二是什么呢
[46:44/03:53:56]     第二个是你的一定要用
[46:46/03:53:56]     如果说你要用doer tag
[46:48/03:53:56]     就把别的镜像仓库里面去的镜像转到这个镜像仓库
[46:53/03:53:56]     那你就给用doer t命令给这个镜像添加一个名字
[46:58/03:53:56]     大家注意
[46:59/03:53:56]     是新添加一个名字
[47:01/03:53:56]     然后再继续用do push命令把这个镜像推送到你自己的镜像仓库里面
[47:06/03:53:56]     那讲到这儿大家能明白否
[47:08/03:53:56]     有没有什么问题
[47:17/03:53:56]     蒋老师
[47:28/03:53:56]     没有问题吗
[47:34/03:53:56]     OK
[47:37/03:53:56]     如果没有问题
[47:38/03:53:56]     我们就往上讲
[47:39/03:53:56]     那讲到镜像仓库了
[47:41/03:53:56]     那现在讲完镜像仓库了
[47:43/03:53:56]     那下面我们就要干什么呢
[47:44/03:53:56]     我们要讲如何制作一个镜像了
[47:46/03:53:56]     如何制作一个镜像
[47:49/03:53:56]     制作镜像的方法有两种
[47:55/03:53:56]     第一种是什么
[47:56/03:53:56]     第一种是比较简单的
[47:58/03:53:56]     我们从一个正在运行的容器去扩
[48:01/03:53:56]     去把它制作成一个定箱
[48:03/03:53:56]     不知道大家有没有用过虚拟集
[48:05/03:53:56]     虚拟集的方式其实很简单
[48:07/03:53:56]     你要制作一个虚拟机的镜像
[48:08/03:53:56]     你怎么制作
[48:09/03:53:56]     你当然是在一个已经运行着的虚拟机上给它打个快照
[48:13/03:53:56]     给它做个那shop
[48:14/03:53:56]     然后把它转换成一个镜像
[48:19/03:53:56]     你下一次用这个ste shop这个快照再就可以启动一个一模一样的虚拟机了
[48:25/03:53:56]     所以说其实理论上是什么呢
[48:27/03:53:56]     理论上就是说你如果制作一个需要制作一个新的镜像
[48:30/03:53:56]     那你一定手里已经有一个原本的一个基础的镜像
[48:34/03:53:56]     用这个基础镜像启动成一个容器
[48:36/03:53:56]     然后在这个容器里面安装对应的软件
[48:40/03:53:56]     你需要的软件
[48:41/03:53:56]     然后再把它保存成一个新的镜像出来所以说第一个制作镜像的方式
[48:47/03:53:56]     最简单的方式是什么呢
[48:48/03:53:56]     就是
[48:50/03:53:56]     Commit commit后面跟容器名称
[48:56/03:53:56]     比如说我们刚才提到了一个叫get的一个一个容器
[49:03/03:53:56]     你把这个容器保存成一个新的镜像
[49:06/03:53:56]     那这个新的像
[49:07/03:53:56]     比如说你就可以叫什么呢
[49:08/03:53:56]     叫LOCALHOST5000
[49:13/03:53:56]     然后
[49:15/03:53:56]     就叫给来吧
[49:17/03:53:56]     也就叫
[49:19/03:53:56]     然后V1.0
[49:22/03:53:56]     回车
[49:25/03:53:56]     这就制作完成了
[49:27/03:53:56]     用image命令
[49:29/03:53:56]     然后你去搜
[49:31/03:53:56]     你会发现这里有一个local器
[49:34/03:53:56]     六秒钟之前刚制作的定向
[49:37/03:53:56]     那你当然你也可以通过do复试命令
[49:41/03:53:56]     把它给
[49:44/03:53:56]     普到我们刚才搭建的镜像仓库里做1.0也是OK的
[49:51/03:53:56]     你可以看到它正在push的过程中
[49:54/03:53:56]     当然get lab的镜像是比较大的
[49:56/03:53:56]     他需要PUSH1小会儿
[49:58/03:53:56]     我们等他一下
[50:18/03:53:56]     大家稍等一下
[50:49/03:53:56]     有点
[50:52/03:53:56]     当然这里还有个副作用
[50:53/03:53:56]     如果我在这边用CTRLC
[50:58/03:53:56]     就是说我我给大家讲一下
[51:00/03:53:56]     如果说我在制作镜像的过程中
[51:03/03:53:56]     用CTRLC去取消了的一个镜像的这么一个
[51:09/03:53:56]     一个操作的话就是我在镜像的制作的过程中
[51:13/03:53:56]     可能自己取消了
[51:14/03:53:56]     它会有一个副作用
[51:16/03:53:56]     会在你的当前机器里边有很多处于状态的
[51:21/03:53:56]     就是他的版本号是
[51:22/03:53:56]     那现在他进项名称也是na
[51:26/03:53:56]     的这么一个状态的镜像
[51:27/03:53:56]     这是因为我们在镜像制作的过程中就把它给取消掉了所带来的副作用
[51:35/03:53:56]     所带来的副作用
[51:36/03:53:56]     这些东西也比较让人苦恼
[51:39/03:53:56]     而且比较让人苦恼
[51:40/03:53:56]     我看我当前的当前的这个这个已经push完了
[51:44/03:53:56]     我看我当前的机器上有没有
[51:49/03:53:56]     有的是你看有你看
[51:52/03:53:56]     镜像的名称是
[51:55/03:53:56]     然后的号也是
[51:58/03:53:56]     就是因为制作镜像的中间被打断了而造成的
[52:01/03:53:56]     而它也是占磁盘空间的
[52:04/03:53:56]     大家可以看到它也是占磁盘空间的
[52:06/03:53:56]     所以说这里就给大家扩展一下这个扩展一下
[52:09/03:53:56]     其实docker它有一个poor命令
[52:12/03:53:56]     Q
[52:13/03:53:56]     你
[52:16/03:53:56]     你可以看到
[52:17/03:53:56]     就是说这里面不常用
[52:20/03:53:56]     基本上不常用很少用一次
[52:21/03:53:56]     我一年可能用不上一次
[52:23/03:53:56]     就是可以去清理不常用的数据
[52:27/03:53:56]     可以清理不常用的一个数据
[52:31/03:53:56]     但是呢
[52:33/03:53:56]     这个怎么说呢
[52:38/03:53:56]     但是怎么说呢
[52:39/03:53:56]     就是用的时候还是很少的
[52:41/03:53:56]     所以说我一般不会给大家讲
[52:43/03:53:56]     但但是可以给大家了解一下
[52:45/03:53:56]     比如说这边有一个刀image就生理镜像
[52:49/03:53:56]     清理叫什么
[52:50/03:53:56]     叫虚无镜像
[52:51/03:53:56]     这个反也是醉了
[52:52/03:53:56]     其实就是没有
[52:55/03:53:56]     没有容器和其没有其他的容器和镜像去使用它这个镜像的的这些镜像就都会被清掉
[53:03/03:53:56]     用这个命令呢
[53:04/03:53:56]     可以把可以一下子就可以把你当前的整个机器上面的这些用不上的这个容器
[53:11/03:53:56]     包括处于状态的容器给删掉
[53:14/03:53:56]     当然如果你不想这么干
[53:15/03:53:56]     你想定点去清它的话
[53:17/03:53:56]     那你就只能用电ID
[53:19/03:53:56]     因为你没有这个
[53:21/03:53:56]     镜像名称没有镜像名称
[53:23/03:53:56]     所以说你只能用RRI然后
[53:29/03:53:56]     用它的定向ID
[53:31/03:53:56]     这定向ID去删
[53:33/03:53:56]     你只能这样去算
[53:35/03:53:56]     这算很麻烦
[53:36/03:53:56]     所以说后面呢
[53:37/03:53:56]     你可以了解一下这个docker
[53:40/03:53:56]     这个怎么念
[53:43/03:53:56]     我也不太很不是很确定
[53:46/03:53:56]     叫破还是叫什么
[53:47/03:53:56]     我我不不清楚
[53:49/03:53:56]     反正有这么个事儿给大家讲一下
[53:52/03:53:56]     给有这么个事
[53:53/03:53:56]     当然也有这个清理什么清理容器的
[53:55/03:53:56]     清理正在这种属于停止状态容器的
[53:58/03:53:56]     清理数据卷的
[54:00/03:53:56]     就是用不到的数据卷的
[54:03/03:53:56]     这些OK
[54:05/03:53:56]     那这是制作镜像的第一种方式
[54:07/03:53:56]     通过doer commit命令
[54:09/03:53:56]     当然我们说ER命令
[54:11/03:53:56]     这个是最简单的制作镜行的方式
[54:14/03:53:56]     同时也是我们最不推荐的
[54:18/03:53:56]     为什么呢
[54:20/03:53:56]     因为它整个的一个制作镜像的过程是一个黑盒
[54:24/03:53:56]     是一个黑盒的
[54:25/03:53:56]     它跟虚拟机一样也是黑盒的
[54:27/03:53:56]     那它带来的问题是什么
[54:28/03:53:56]     他的问题是你作为这个镜的开发者
[54:31/03:53:56]     可能过了两三个月以后
[54:33/03:53:56]     你自己都已经忘了你自己对这个镜像做过什么事了
[54:37/03:53:56]     就你怎么制作的这个镜像
[54:39/03:53:56]     这个镜像里装了什么软件
[54:40/03:53:56]     做了什么样的配置
[54:41/03:53:56]     你自己都忘了
[54:42/03:53:56]     更不要说你如果你想要把你的这个镜像交给其他人去维护
[54:46/03:53:56]     比如说其他人要根据你的镜像去进行扩展
[54:48/03:53:56]     那扩展这个人就需要知道
[54:50/03:53:56]     需要知道那你这个镜像里面都干了什么
[54:52/03:53:56]     你装了什么
[54:55/03:53:56]     我只有一个名称
[54:57/03:53:56]     信息太少了
[54:59/03:53:56]     这样的话呢
[55:01/03:53:56]     你对这个镜像的扩展和维护会非常的不方便
[55:04/03:53:56]     我非常的难
[55:05/03:53:56]     作为镜像开发者
[55:07/03:53:56]     你自己可能过了两三个月之后
[55:08/03:53:56]     你自己也忘了
[55:09/03:53:56]     然后你说我想改这个镜像
[55:12/03:53:56]     你发现你已经改不了
[55:14/03:53:56]     因为你不知道对你已经对这个定向做了什么事情了
[55:16/03:53:56]     你已经改不了它了
[55:18/03:53:56]     你可能你你都害怕就改坏了
[55:20/03:53:56]     这是第一个问题
[55:21/03:53:56]     第二个问题是什么呢
[55:22/03:53:56]     第二个问题是如果你的
[55:24/03:53:56]     如果你是去做的镜像的话
[55:27/03:53:56]     那会面临一个问题
[55:28/03:53:56]     就是如果你的镜像丢了
[55:30/03:53:56]     那就真的丢了
[55:32/03:53:56]     你没有任何办法
[55:33/03:53:56]     而如果你是通过我们马上马上讲
[55:37/03:53:56]     我们解决这两个问题
[55:40/03:53:56]     就能解决两个问题
[55:41/03:53:56]     首先说镜像会不会丢的问题
[55:42/03:53:56]     就算你的镜像丢了
[55:44/03:53:56]     你的do还在
[55:46/03:53:56]     那其实你可以在任何一台有doer的这么一个机器上
[55:49/03:53:56]     迅速的就能够把这个用最短的时间就把这个镜像给恢复出来
[55:53/03:53:56]     是一模一样的
[55:55/03:53:56]     同时do也记录了你制作镜像的每一个过程
[56:00/03:53:56]     我总说我们可以把当成是制作镜像的一个自动化版本
[56:06/03:53:56]     你就把它当成一个自动化脚本
[56:08/03:53:56]     你就把把commit的这个制作镜像的整套流程
[56:15/03:53:56]     整套流程全都转化成了一个自动化脚本
[56:19/03:53:56]     那这个自动化脚本就是
[56:22/03:53:56]     所以说其实本身就是这个镜像的文档
[56:25/03:53:56]     文档你通过你可以知道这个镜像里都做了一些什么样的事情
[56:29/03:53:56]     你可以通过修改去维护扩展这个这个
[56:37/03:53:56]     所以说do是我们这个推荐的镜像制作的一个方式
[56:43/03:53:56]     其实
[56:44/03:53:56]     这里面还有一个小故事
[56:46/03:53:56]     就是说容器这个东西
[56:48/03:53:56]     它不是cker发生的
[56:49/03:53:56]     它不是发明的
[56:52/03:53:56]     在诞生之前很久
[56:55/03:53:56]     其实容器就已经存在了
[56:58/03:53:56]     容器就已经存在了
[56:59/03:53:56]     只是它并不流行
[57:01/03:53:56]     它并不流行
[57:03/03:53:56]     为什么说docker出现之后能就能够立马让容器这个东西流行起来呢
[57:11/03:53:56]     为什么呢
[57:12/03:53:56]     就是因为field出现
[57:14/03:53:56]     因为doctor field的出现
[57:17/03:53:56]     他把镜像的制作
[57:21/03:53:56]     他把镜像的制作的成本降低到了一个非常低的一个地步
[57:27/03:53:56]     我以前总说嘛
[57:29/03:53:56]     但会X就会写shell
[57:32/03:53:56]     写shell脚本
[57:34/03:53:56]     而就是很初级的shell脚本呢
[57:36/03:53:56]     很初级的shell脚本就会写doer
[57:38/03:53:56]     它的成本非常低
[57:40/03:53:56]     制作镜像的速度非常的快
[57:43/03:53:56]     Docker镜像它的整个镜像的体系
[57:46/03:53:56]     它的设计都是非常良好的
[57:49/03:53:56]     如果说如果没有刀ER票
[57:51/03:53:56]     如果没有刀ER对于镜像的这些设计
[57:53/03:53:56]     那其实刀客是流行不起来的
[57:55/03:53:56]     尤其是之前有很多其他产品
[57:58/03:53:56]     其他产品也是有容器能力的
[58:01/03:53:56]     但他们都流流行了起来
[58:03/03:53:56]     就是因为它是什么
[58:04/03:53:56]     因为他们的镜像设计的不好OK
[58:08/03:53:56]     那这里我们看一下到票的一个使用情况
[58:13/03:53:56]     Do基本上基本上有几个简单的指令
[58:23/03:53:56]     Do常用的指令不超过十个
[58:26/03:53:56]     常用的指令不超过十个
[58:30/03:53:56]     虽然你看do file的文档里边可能有好几十个
[58:34/03:53:56]     但其实常用的不会超过十个
[58:36/03:53:56]     我常用到的就是这几个
[58:38/03:53:56]     都列到当前的这个do file里面
[58:40/03:53:56]     我给大家挨个解释
[58:41/03:53:56]     挨个解释
[58:42/03:53:56]     我们刚才曾经说过
[58:43/03:53:56]     曾经说过
[58:44/03:53:56]     就是说你要制作一个镜像的前提是你已经先有一个镜了
[58:47/03:53:56]     你是在这个已有的镜像往外扩展
[58:50/03:53:56]     你通过已有的镜像启动一个容器
[58:53/03:53:56]     在这个容器上安装你软件
[58:55/03:53:56]     然后形成再保存成你的新的镜像
[58:57/03:53:56]     所以说每一个第一个指令都是什么
[59:00/03:53:56]     都是from指令
[59:01/03:53:56]     代表着什么呢
[59:02/03:53:56]     代表着你要从哪一个基础镜上进行扩展
[59:09/03:53:56]     就是说你当前的镜像是依赖于哪个镜像的
[59:12/03:53:56]     这from令令令面去
[59:22/03:53:56]     因为有很多的东西
[59:25/03:53:56]     你是没有办法在面去描述的
[59:27/03:53:56]     就比如说一个很复杂脚本
[59:28/03:53:56]     你希望在你的你的容器里面
[59:31/03:53:56]     在你的镜里面是保存一个脚本
[59:33/03:53:56]     或者保存一个软件
[59:35/03:53:56]     那你是不很多时候你是不可能在镜像里面直接去做的
[59:40/03:53:56]     你不能在镜像里面do里面直接写这脚本是不不行
[59:44/03:53:56]     或者说你需要下载一个软件
[59:47/03:53:56]     不管是下载JDK也好
[59:48/03:53:56]     下载什么也好
[59:49/03:53:56]     你总不能在大现写一个
[59:52/03:53:56]     JK吧
[59:53/03:53:56]     那也是不行的
[59:54/03:53:56]     所以说它需要什么呢
[59:56/03:53:56]     它需要一个指令
[59:58/03:53:56]     能够能从容器外部
[01:00:01/03:53:56]     能从镜像外部把镜像外部的文件copy到镜像里面的这么一个能力这个指令有两个
[01:00:09/03:53:56]     这其中一个就是a
[01:00:11/03:53:56]     还有是copy
[01:00:13/03:53:56]     它们俩的功能是类似的
[01:00:16/03:53:56]     只不过从主要的使用场景来看呢
[01:00:19/03:53:56]     Copycopy功能呢
[01:00:21/03:53:56]     它会它在这个镜像的多阶段构建里面多阶段构建里面它能够起到一个至关重要的一个作用它比这个I的使用场景多
[01:00:33/03:53:56]     而I的指令呢
[01:00:34/03:53:56]     比比比copy指令的多一个功能是什么呢
[01:00:37/03:53:56]     它能够自动解压
[01:00:39/03:53:56]     如果你传进来的是一个他包
[01:00:41/03:53:56]     那爱的指令能够自动将自动的帮你把这个他包给解压出来
[01:00:47/03:53:56]     解压出来这是他们ADD和copy指令的不一样的地方
[01:00:52/03:53:56]     然后下面是user指令
[01:00:54/03:53:56]     就是代表着什么呢
[01:00:55/03:53:56]     代表着你的
[01:00:58/03:53:56]     你当前的要以什么样的用户
[01:01:01/03:53:56]     以什么样的身份去运行这些指令
[01:01:04/03:53:56]     比如说在这边我切到了root
[01:01:05/03:53:56]     那下面所有的我运行的这些这些shell的地方
[01:01:09/03:53:56]     那全都是用root用户去执行的
[01:01:12/03:53:56]     都是用route句题型的
[01:01:13/03:53:56]     然后下面是range指令
[01:01:15/03:53:56]     Run指令是什么呢
[01:01:16/03:53:56]     就是跑she命令的地方
[01:01:18/03:53:56]     这一般来说一个大file里面range指令应该是最多的
[01:01:21/03:53:56]     注意里面令
[01:01:25/03:53:56]     都是可以存在多个的
[01:01:28/03:53:56]     除了这个point
[01:01:30/03:53:56]     剩下这些指源都可以有多个的
[01:01:32/03:53:56]     你看range有很多个
[01:01:35/03:53:56]     论令可以很多个
[01:01:36/03:53:56]     它运行了很多个
[01:01:37/03:53:56]     安装了很多个软件然后你看下面user指令
[01:01:42/03:53:56]     它右边有一个user指令
[01:01:45/03:53:56]     你看
[01:01:47/03:53:56]     他用了一个叫S的这么一个指令
[01:01:52/03:53:56]     还有一个用户
[01:01:54/03:53:56]     然后再下面是work
[01:01:56/03:53:56]     代表了工作目录
[01:01:59/03:53:56]     就是说你你你现在要切换到哪个工作目录下再然后最后一个指令就是什么呢
[01:02:06/03:53:56]     是启动脚本
[01:02:07/03:53:56]     我们制镜之后
[01:02:09/03:53:56]     镜启动一个容器的时候
[01:02:11/03:53:56]     你希望它运行的第一个命就是它的脚本
[01:02:16/03:53:56]     就是它的启动脚本
[01:02:18/03:53:56]     你可以大家细心同学
[01:02:20/03:53:56]     大家可以发现启动脚本
[01:02:21/03:53:56]     你会发现这就是我们的启动脚本
[01:02:23/03:53:56]     就是我们刚才通过I的指令从外面加载进来的
[01:02:28/03:53:56]     加载进来的
[01:02:29/03:53:56]     好吧
[01:02:30/03:53:56]     那我把它保存一下
[01:02:34/03:53:56]     当我们已经有了这样的一个doer file之后
[01:02:37/03:53:56]     那我就可以用doer build命令
[01:02:39/03:53:56]     然后杠t host
[01:02:42/03:53:56]     5000
[01:02:43/03:53:56]     但一定要
[01:02:44/03:53:56]     一定要习惯这种镜像的制作的时候
[01:02:47/03:53:56]     它的这个镜像的规则
[01:02:50/03:53:56]     你一定要跟镜像仓库的名称
[01:02:52/03:53:56]     要不然你push不上去
[01:02:54/03:53:56]     刀客比我的杠T
[01:02:56/03:53:56]     Docker build杠
[01:02:57/03:53:56]     然后LOCALHOT5000
[01:03:00/03:53:56]     5000结束之后5000结束之后
[01:03:02/03:53:56]     然后我们跟上自己的名镜
[01:03:04/03:53:56]     像仓库进项的名称叫什么呢
[01:03:07/03:53:56]     比如说叫这叫戴叫叫DEMO
[01:03:11/03:53:56]     然后
[01:03:13/03:53:56]     给你一个点
[01:03:14/03:53:56]     这个点代表着工作目录的地址
[01:03:17/03:53:56]     工作目录的地址径
[01:03:21/03:53:56]     这个工作目录代表什么呢
[01:03:23/03:53:56]     这个工作目录就代表的是
[01:03:25/03:53:56]     就比如说刚才我们在do file里面要用指令把外部文件加载到当前的镜像里面
[01:03:32/03:53:56]     Copy到当前的镜像里
[01:03:33/03:53:56]     那它从哪去找这个外部文件呢
[01:03:35/03:53:56]     就是从工作目录
[01:03:36/03:53:56]     所以说我们用doctor build的时候需要什么呢
[01:03:40/03:53:56]     需要给他
[01:03:42/03:53:56]     提供一个
[01:03:44/03:53:56]     Do一个工作的径
[01:03:46/03:53:56]     一般来说就就是当前径
[01:03:48/03:53:56]     所以说就是第二
[01:03:49/03:53:56]     当然这还有一个杠
[01:03:50/03:53:56]     F参数指定file的地址就是径
[01:03:53/03:53:56]     你告诉他在哪
[01:03:55/03:53:56]     只不过一般来说它的默认默认行为是什么呢
[01:04:00/03:53:56]     默认行为是找当前工作目录下面这个叫do file这个文件
[01:04:05/03:53:56]     所以一般来说
[01:04:06/03:53:56]     我们把doer都起名叫doer都起名叫do
[01:04:10/03:53:56]     然后我们就不用指认这个参数
[01:04:11/03:53:56]     然后回撤
[01:04:18/03:53:56]     OK
[01:04:21/03:53:56]     那这个镜像就制作出来了
[01:04:23/03:53:56]     如果在这个过程当中
[01:04:25/03:53:56]     我们需要大家注意一点注意一点
[01:04:31/03:53:56]     大家看这里面的日志
[01:04:33/03:53:56]     第一个
[01:04:34/03:53:56]     有一个消息后跟KB
[01:04:42/03:53:56]     这是什么意思呢
[01:04:44/03:53:56]     这意思是说
[01:04:45/03:53:56]     Docker为了制作镜像
[01:04:48/03:53:56]     他会把你工作目录下所有的文件全部发送给docker
[01:04:55/03:53:56]     全部发送给ER
[01:04:57/03:53:56]     所以说这里面大家一定要注意
[01:04:58/03:53:56]     你保存ER file那个工作目录
[01:05:01/03:53:56]     就那个目录下面不能有其他无关的东西
[01:05:05/03:53:56]     否则的话它都会被发送到docker里面去
[01:05:09/03:53:56]     这里面大家感受不到
[01:05:11/03:53:56]     比如说这是只有一个4.6
[01:05:12/03:53:56]     就是只有4.6K嘛
[01:05:13/03:53:56]     所以说你感觉不到
[01:05:14/03:53:56]     假如说你在这里面保存了一个GDK
[01:05:16/03:53:56]     几百兆的一个GDK
[01:05:18/03:53:56]     你就明显感觉到它3BUILD contact这个步骤
[01:05:22/03:53:56]     它一直在loading loading loading你的文件越大
[01:05:25/03:53:56]     它loading时间越长
[01:05:27/03:53:56]     它受的时间也越长
[01:05:29/03:53:56]     所以说我们的一个规范是什么呢
[01:05:31/03:53:56]     你保存目录一定是独立的目录
[01:05:34/03:53:56]     而且这个录里面除了
[01:05:36/03:53:56]     跟制作镜像有关的文件之外
[01:05:40/03:53:56]     什么都不能有
[01:05:41/03:53:56]     什么都不影响
[01:05:42/03:53:56]     因为如果你有其他文件
[01:05:43/03:53:56]     都会影响你镜像制作的速度
[01:05:46/03:53:56]     和资源
[01:05:49/03:53:56]     好
[01:05:50/03:53:56]     接着往下说
[01:05:52/03:53:56]     是什么呢
[01:05:55/03:53:56]     再往后是你可以看到它是根据一步一步来了
[01:05:59/03:53:56]     但是每一步都是什么呢
[01:06:01/03:53:56]     每一步你比如说在这running in
[01:06:03/03:53:56]     然后后边跟一个ID running in后边跟ID
[01:06:05/03:53:56]     这是什么
[01:06:06/03:53:56]     是启动了一个临时的容器
[01:06:09/03:53:56]     Doer启动了一个临时的容器
[01:06:11/03:53:56]     在一个容器里面去运行什么呢
[01:06:16/03:53:56]     去运行你的指令
[01:06:20/03:53:56]     我刚才也说过
[01:06:21/03:53:56]     就是说是什么东西
[01:06:26/03:53:56]     它本质上就是什么呢
[01:06:30/03:53:56]     就是你ER是制作镜像的
[01:06:32/03:53:56]     就手工制作手动制作镜像
[01:06:34/03:53:56]     那除了自动化版本
[01:06:36/03:53:56]     所以说呢
[01:06:39/03:53:56]     它的原理其实并没有改变
[01:06:41/03:53:56]     它的原理并没有改变
[01:06:42/03:53:56]     它还是需要什么呢
[01:06:44/03:53:56]     它还是需要你通过基础镜像启动一个临时的容器
[01:06:50/03:53:56]     然后在这个临时容器里安装一堆软件
[01:06:54/03:53:56]     然后再把这个
[01:06:56/03:53:56]     容器制作成一个新的镜像出来
[01:07:00/03:53:56]     它的原理是没有改变的
[01:07:01/03:53:56]     所以说你看每一个指令下面它
[01:07:06/03:53:56]     上面这些指令是有cash
[01:07:08/03:53:56]     有cash它就不重新进行了
[01:07:10/03:53:56]     刚才我专门故意改了一块
[01:07:11/03:53:56]     让它没有cash
[01:07:12/03:53:56]     你可以看到
[01:07:14/03:53:56]     Me状态的contain就是这个ID
[01:07:27/03:53:56]     这俩ID是一样的
[01:07:29/03:53:56]     然后后面可以看到这也是一样的
[01:07:32/03:53:56]     Running一个地方
[01:07:33/03:53:56]     然后然后
[01:07:39/03:53:56]     然后build成功之后给他一个给他一个
[01:07:43/03:53:56]     所以说大家这里面可以大家可以了解到
[01:07:45/03:53:56]     应该可以出来
[01:07:47/03:53:56]     应该可以看出来
[01:07:48/03:53:56]     Do其实就是你手动用do的去制作镜像的一个自动化版本而已
[01:07:57/03:53:56]     本质上他们是没有区别的
[01:07:58/03:53:56]     只不过一个是手动的
[01:07:59/03:53:56]     一个是自动化的
[01:08:01/03:53:56]     OK
[01:08:02/03:53:56]     讲到这大家能听明白吗
[01:08:04/03:53:56]     有没有什么问题
[01:08:06/03:53:56]     安娜同学问
[01:08:09/03:53:56]     原镜像文件更新了的镜像文件也是同一个文件
[01:08:14/03:53:56]     所以也会更新
[01:08:15/03:53:56]     答案是错的
[01:08:19/03:53:56]     不是会
[01:08:20/03:53:56]     我得先问你个前提
[01:08:21/03:53:56]     你说原镜像文件更新的的镜像文件也是同一个文件
[01:08:25/03:53:56]     所以也会更新
[01:08:27/03:53:56]     这是什么场景呢
[01:08:29/03:53:56]     你说是什么场景
[01:08:35/03:53:56]     去制作了一个叫的一个版本号了
[01:08:37/03:53:56]     因为我这边没指定版本号
[01:08:39/03:53:56]     所以说其实它就是那假说
[01:08:40/03:53:56]     我再根据一个1.0
[01:08:42/03:53:56]     我再一个1.0的在这
[01:08:47/03:53:56]     我制作一个1.0的
[01:08:49/03:53:56]     在这我说我再改一下
[01:08:51/03:53:56]     我得改一下
[01:08:59/03:53:56]     随便改一下
[01:09:01/03:53:56]     然后我再在这制作一个1.0的会车
[01:09:12/03:53:56]     大家等一下制作镜像会有一些时间
[01:09:36/03:53:56]     好
[01:09:37/03:53:56]     这时候我们再看你用image命令
[01:09:41/03:53:56]     你去过滤一下
[01:09:44/03:53:56]     你可以看到这是两个镜像
[01:09:46/03:53:56]     一个是版本的
[01:09:47/03:53:56]     一个是1.0版本的
[01:09:49/03:53:56]     你后边对比后面的镜像ID
[01:09:53/03:53:56]     你会发现它是完全不同的镜像
[01:09:56/03:53:56]     它是完全不同的镜像
[01:09:59/03:53:56]     它是完全不同的镜
[01:10:00/03:53:56]     所以说如果你不管你用docker tag mini好
[01:10:03/03:53:56]     还是说你把这个docker file
[01:10:07/03:53:56]     改了
[01:10:08/03:53:56]     你把这个docel改了
[01:10:11/03:53:56]     比如说你改一下
[01:10:12/03:53:56]     我再把这个删了
[01:10:13/03:53:56]     你把它改一下
[01:10:19/03:53:56]     这个改原件下
[01:10:21/03:53:56]     你再去用这个东西看
[01:10:23/03:53:56]     你会发现什么呢
[01:10:24/03:53:56]     你会发现它还是两个不一样的ID
[01:10:30/03:53:56]     他数要是不会互相影响它
[01:10:33/03:53:56]     你不会因为更新了一个镜像
[01:10:35/03:53:56]     会导致于另外一个版本的镜像也会改变
[01:10:37/03:53:56]     是这个是不会的
[01:10:39/03:53:56]     这你能明白否
[01:10:42/03:53:56]     Run命令后面可以解释一下吗
[01:10:45/03:53:56]     就指令是吧
[01:10:46/03:53:56]     好run指令后边跟shell脚本很好解释
[01:10:50/03:53:56]     就是你会发现就是运行shell命令嘛
[01:10:52/03:53:56]     后边跟着一个shell命跟另外一个shell命令
[01:10:56/03:53:56]     指令后边就是跟shell命令的地方
[01:10:58/03:53:56]     原声的shell命令
[01:11:06/03:53:56]     还有其他问题吗
[01:11:19/03:53:56]     还有没有其他问题
[01:11:42/03:53:56]     没有是吧
[01:11:44/03:53:56]     如果没有其他问题的话
[01:11:46/03:53:56]     接下来给大家一点时间来练习一下
[01:11:50/03:53:56]     给大家留一个课堂作业
[01:11:53/03:53:56]     第一个呢
[01:11:54/03:53:56]     是把我刚才讲到的这些东西
[01:11:55/03:53:56]     包括这个大件镜像仓库
[01:11:59/03:53:56]     以及用do file去制作这个镜像的这么一个流程
[01:12:05/03:53:56]     你们一定要自己练习一遍
[01:12:07/03:53:56]     自己敲一遍
[01:12:09/03:53:56]     一定要自己敲一遍
[01:12:11/03:53:56]     这是第一个作业
[01:12:13/03:53:56]     第二个作业是什么呢
[01:12:15/03:53:56]     第二个作业我先把这个东西更新到课程
[01:12:27/03:53:56]     Do file指令
[01:12:35/03:53:56]     保存
[01:12:37/03:53:56]     二个作业是什么
[01:12:38/03:53:56]     二个作业我们一个场景
[01:12:40/03:53:56]     你们一个实际的场景
[01:12:43/03:53:56]     如Java们
[01:12:46/03:53:56]     Java的项目编译成一个架包
[01:12:50/03:53:56]     然后
[01:12:51/03:53:56]     把它什么呢
[01:12:52/03:53:56]     把它推送
[01:12:53/03:53:56]     就是把它这个包制作成一个镜像
[01:12:57/03:53:56]     制作一个定向
[01:12:58/03:53:56]     然后并且启动起来
[01:13:01/03:53:56]     并且启动起来
[01:13:02/03:53:56]     如果你是Python的
[01:13:03/03:53:56]     就把你们的一个Python项目制作成镜像
[01:13:07/03:53:56]     并且在这个镜像通过镜像启动容器
[01:13:09/03:53:56]     在容器里面运行起来
[01:13:11/03:53:56]     好吧
[01:13:12/03:53:56]     给大家就是20分钟左右时间
[01:13:16/03:53:56]     OK
[01:13:18/03:53:56]     大家开始练习吧
[01:14:09/03:53:56]     就下了
[01:14:10/03:53:56]     我不认识
[01:14:12/03:53:56]     没有记忆
[01:16:19/03:53:56]     大家如果在练习的过程中有任何的问题
[01:16:22/03:53:56]     都在讨论区里留言
[01:16:51/03:53:56]     这鹌我没发给你
[01:16:55/03:53:56]     这个point的内容其实很简单
[01:17:02/03:53:56]     它就是个你们自己弄吧
[01:17:08/03:53:56]     你可以看到就是在这个
[01:17:17/03:53:56]     我们在跟do同级目录里面有一个叫engine point的一个一个一个一个这个东西
[01:17:24/03:53:56]     然后里面其实就是一个P
[01:17:25/03:53:56]     我让它进入一个死循环
[01:17:27/03:53:56]     这样的话呢
[01:17:28/03:53:56]     这个容器它能那它的容器它能能一直运行状态
[01:17:31/03:53:56]     因为如果安全point退出了
[01:17:33/03:53:56]     执行完毕了退出了
[01:17:36/03:53:56]     那它这个容器就也就退出运行了
[01:17:38/03:53:56]     所以说一般一定要是处于一种持续运行的状态
[01:17:43/03:53:56]     要不然你的容器就直接就挂了退运运行退出了
[01:17:46/03:53:56]     就这大家需要注意
[01:17:50/03:53:56]     大家需要注意
[01:17:53/03:53:56]     令
[01:18:09/03:53:56]     镜里的某一个目录里面user是什么呢
[01:18:13/03:53:56]     User代表的是
[01:18:15/03:53:56]     User代表是你要把当运行当前这个里面那个用户用户切换到
[01:18:22/03:53:56]     这个S叫在用户上work
[01:18:25/03:53:56]     是工作目录
[01:18:27/03:53:56]     就是说你当前运行的这些指令是在哪个目录
[01:18:30/03:53:56]     在下面去运行的是你的容器的启动脚本
[01:21:17/03:53:56]     嗯
[01:45:43/03:53:56]     好啊
[01:45:44/03:53:56]     大家回来吧
[01:45:45/03:53:56]     稍等一下
[01:45:46/03:53:56]     我再倒点水
[01:45:57/03:53:56]     快点水
[01:46:07/03:53:56]     我们要继续往下讲了
[01:46:10/03:53:56]     继续往下讲了
[01:46:12/03:53:56]     接下来呢
[01:46:14/03:53:56]     但是我先问一下大家有多少已经成功的首先第一步
[01:46:17/03:53:56]     就是我们刚才在这个演示的这个大家有成功了吗
[01:46:22/03:53:56]     演示的这个最基础这个赛或者说有没有没成功的嘛
[01:46:28/03:53:56]     应该都成功了吗
[01:46:29/03:53:56]     已经给了大家差不多我我算一下差不多有25分钟的时间了
[01:46:36/03:53:56]     有没有没成功的
[01:46:38/03:53:56]     就是你如果你没通
[01:46:39/03:53:56]     你要说
[01:46:40/03:53:56]     你把你的错误信息发出来
[01:46:41/03:53:56]     让我看看你是哪有问题
[01:46:44/03:53:56]     然后我告诉你怎么解决
[01:46:50/03:53:56]     没有没成功的是吗
[01:46:53/03:53:56]     都成功了
[01:46:54/03:53:56]     那第二个问题就是我让大家自己做一个镜像
[01:46:57/03:53:56]     有成功的吗
[01:46:58/03:53:56]     就是如果你是Java的
[01:46:59/03:53:56]     你是写Java的
[01:47:01/03:53:56]     你做个镜
[01:47:02/03:53:56]     如果有
[01:47:03/03:53:56]     你是写Python的
[01:47:04/03:53:56]     你你做个Python的镜像
[01:47:09/03:53:56]     有成功的吗
[01:47:10/03:53:56]     就大家怎么一点反馈都没有
[01:47:11/03:53:56]     我不知道现在什么情况
[01:47:17/03:53:56]     怎么一点反馈都没有呢
[01:47:28/03:53:56]     这样吧
[01:47:29/03:53:56]     我给大家演示一下
[01:47:30/03:53:56]     做做一个加镜像吧
[01:47:32/03:53:56]     不演示做on的
[01:47:34/03:53:56]     因为镜像它比较复杂
[01:47:35/03:53:56]     你们在如果你们在工作当中去
[01:47:39/03:53:56]     做一些跟持续基层相关的工作呢
[01:47:41/03:53:56]     你们面对的更多的可能是加的象是
[01:47:44/03:53:56]     因为这个毕竟研发他们使用的互联网的业务语言主要还是家对吧
[01:47:51/03:53:56]     OK
[01:47:52/03:53:56]     当然演示这个提前呢
[01:47:54/03:53:56]     先给大家介绍一下这个
[01:47:57/03:53:56]     项目是干嘛用的
[01:47:59/03:53:56]     这是一个普罗米修斯的
[01:48:00/03:53:56]     我用Java的这个client写的
[01:48:04/03:53:56]     自己写的一个
[01:48:05/03:53:56]     大家还记得是什么意思
[01:48:08/03:53:56]     对吧
[01:48:09/03:53:56]     台机port是个什么意思
[01:48:14/03:53:56]     具体的代码怎么写的
[01:48:16/03:53:56]     大家可以不用管
[01:48:19/03:53:56]     因为这也不是让你去教你们在不是在教你
[01:48:23/03:53:56]     教你们开发怎么去定义
[01:48:26/03:53:56]     普罗米修斯只是说
[01:48:29/03:53:56]     这是一个Java的项目
[01:48:32/03:53:56]     这是一个的项目
[01:48:33/03:53:56]     我们需要把它制作成一个镜像
[01:48:35/03:53:56]     并且干什么呢
[01:48:36/03:53:56]     并且
[01:48:39/03:53:56]     并且把它部署起来起来那
[01:48:44/03:53:56]     我肯定不会重头的去把它给
[01:48:50/03:53:56]     把它给这个制作一遍
[01:48:52/03:53:56]     我们一定要善于什么
[01:48:54/03:53:56]     一定要善于利用其他人的已经做好的镜像去进行扩展
[01:49:02/03:53:56]     比如说现在我就是要一个Java的一个镜像
[01:49:04/03:53:56]     对吧
[01:49:06/03:53:56]     我现在是一个Java的项目
[01:49:07/03:53:56]     如果但如果我从头配置环境变量头去做这个JDK
[01:49:11/03:53:56]     下载JDK
[01:49:12/03:53:56]     安装GDK
[01:49:13/03:53:56]     那必然是一件很麻烦的事情
[01:49:14/03:53:56]     那我可不可以去找一个已有的一个
[01:49:20/03:53:56]     基础的加相等是可以的
[01:49:24/03:53:56]     是可以的
[01:49:25/03:53:56]     是完全可以有的
[01:49:33/03:53:56]     嗯
[01:49:35/03:53:56]     怎么是from s
[01:49:39/03:53:56]     Doctor
[01:49:43/03:53:56]     嗯
[01:49:56/03:53:56]     等会儿等会儿等会儿等会儿
[01:49:58/03:53:56]     这这这这
[01:50:07/03:53:56]     怎么全都是from OS
[01:50:09/03:53:56]     有吗
[01:50:11/03:53:56]     没有吧
[01:50:26/03:53:56]     这呢
[01:50:27/03:53:56]     这个才是对这个才是
[01:50:30/03:53:56]     你看我先去什么呢
[01:50:34/03:53:56]     我先去找了这么一个角GDK的一个基础
[01:50:37/03:53:56]     这这个大家可以在刀
[01:50:39/03:53:56]     File里面去找
[01:50:42/03:53:56]     或不是do file到括号里面去找
[01:50:44/03:53:56]     你可以找Java
[01:50:48/03:53:56]     你看这里有加opendk的
[01:50:50/03:53:56]     有有这个
[01:50:53/03:53:56]     这是可以的
[01:50:54/03:53:56]     然后但是我在这个项目里面可以看
[01:50:58/03:53:56]     我就使用了一个base image open gd8
[01:51:02/03:53:56]     的版本
[01:51:04/03:53:56]     这个do票
[01:51:05/03:53:56]     然后呢
[01:51:06/03:53:56]     我把一个已经编译好的架包
[01:51:09/03:53:56]     通过I的指令
[01:51:15/03:53:56]     Copy进来
[01:51:16/03:53:56]     然后呢
[01:51:17/03:53:56]     Point就是一个拜师命令
[01:51:19/03:53:56]     一个拜师的命令
[01:51:21/03:53:56]     这种Java去启动一个就Java这个命令去把这个加包给启动起来
[01:51:27/03:53:56]     总体来说非常简单了
[01:51:28/03:53:56]     就对吧
[01:51:29/03:53:56]     大家一定要善于利用其他人已经做好了基础镜像
[01:51:34/03:53:56]     这样的可以把你的这个镜像构建的步骤变得非常的简单
[01:51:39/03:53:56]     变成的非常的简单
[01:51:45/03:53:56]     Master
[01:51:51/03:53:56]     这个人很奇怪
[01:51:53/03:53:56]     这什么时候改的
[01:51:55/03:53:56]     那我得把这给改一下
[01:52:13/03:53:56]     这都给copy过来
[01:52:15/03:53:56]     我的master分支不知道什么时候给我自己给改了
[01:52:18/03:53:56]     还是别人给我动了
[01:52:19/03:53:56]     我也忘了
[01:52:20/03:53:56]     应该是这样的
[01:52:23/03:53:56]     应该是这样的吧
[01:52:25/03:53:56]     很奇怪
[01:52:27/03:53:56]     什么时候变成改掉的
[01:52:29/03:53:56]     我上持续上课的时候还好使呢
[01:52:36/03:53:56]     Master分支怎么就变了呢
[01:52:41/03:53:56]     我看一下是我自己改的吗
[01:52:44/03:53:56]     还是然后后面再说吧
[01:52:46/03:53:56]     这有个history是吧
[01:52:49/03:53:56]     不对
[01:52:50/03:53:56]     五月前改的还是
[01:52:53/03:53:56]     改我自己改成S的
[01:52:57/03:53:56]     这是为啥呢
[01:52:58/03:53:56]     为啥要改呢
[01:53:02/03:53:56]     我也自己也忘了原因了
[01:53:04/03:53:56]     反正这个安我改回来先
[01:53:08/03:53:56]     那我再检查一下
[01:53:14/03:53:56]     没什么问题
[01:53:15/03:53:56]     那有了这样的一个doctor file之后
[01:53:17/03:53:56]     我们先做一件事情是什么
[01:53:18/03:53:56]     先用ma meaning ma meaning m vn package PH PH先打包
[01:53:30/03:53:56]     我们先打包
[01:53:32/03:53:56]     好
[01:53:33/03:53:56]     打完标成功了
[01:53:34/03:53:56]     打完抛成功就可以用docker build命令了
[01:53:37/03:53:56]     Doer build
[01:53:38/03:53:56]     杠T
[01:53:39/03:53:56]     杠T就叫啥呢
[01:53:41/03:53:56]     就叫我记得
[01:53:43/03:53:56]     我记得
[01:53:44/03:53:56]     我在这好像也写过
[01:53:45/03:53:56]     还是叫以前的那个名字会比较好一点
[01:53:52/03:53:56]     大块比如体logo
[01:53:54/03:53:56]     这叫加va X对吧
[01:53:55/03:53:56]     行吧
[01:53:56/03:53:56]     叫Java X
[01:53:58/03:53:56]     回撤啊
[01:54:01/03:53:56]     他要先下载镜像
[01:54:04/03:53:56]     看看下这个镜像下多久
[01:54:19/03:53:56]     下载不下来了又
[01:54:25/03:53:56]     这现象不存在了吗
[01:54:26/03:53:56]     已经我我搜一个新的吧
[01:54:28/03:53:56]     我刚才加了open jdk
[01:54:35/03:53:56]     Open j AK official
[01:54:40/03:53:56]     我要找八
[01:55:01/03:53:56]     嗯
[01:55:08/03:53:56]     看看这个能不能用看看
[01:55:14/03:53:56]     这是它的do file加二时
[01:55:31/03:53:56]     Je links把
[01:55:50/03:53:56]     我找一找
[01:55:56/03:53:56]     因为我用今天K8
[01:56:02/03:53:56]     去写的
[01:56:05/03:53:56]     所以我尽量找一个JDK8版本
[01:56:08/03:53:56]     现在这么写
[01:56:09/03:53:56]     那么现在JDK版本一下
[01:56:11/03:53:56]     看一下
[01:56:22/03:53:56]     都十级了
[01:56:24/03:53:56]     都已经
[01:56:28/03:53:56]     大家稍等一下
[01:56:29/03:53:56]     我看我能不能找到一个稍微合适的版本
[01:56:38/03:53:56]     我1.8
[01:56:57/03:53:56]     什么情况
[01:57:11/03:53:56]     怎么什么都搜不出来了
[01:57:31/03:53:56]     像今天20了都已经
[01:57:33/03:53:56]     我的天
[01:57:38/03:53:56]     那我就直接搜JDK呢
[01:57:46/03:53:56]     Talks
[01:57:49/03:53:56]     一样的
[01:57:58/03:53:56]     这这有个GD可拔的是吧
[01:58:00/03:53:56]     这有接吧
[01:58:02/03:53:56]     我试试这个能不能拉下来
[01:58:08/03:53:56]     It not image information about
[01:58:14/03:53:56]     我先下一个这个试试看
[01:58:26/03:53:56]     这里可以搜一下
[01:58:33/03:53:56]     这就一个接力黑八
[01:58:37/03:53:56]     待会下一个如果是那个不行的话
[01:58:39/03:53:56]     我们就下一个这个试试看
[01:58:41/03:53:56]     怎么都下载不下来了呢
[01:58:43/03:53:56]     说我们当前这个网络有什么问题吗
[01:58:46/03:53:56]     大家稍等一下
[01:58:48/03:53:56]     我们得下一个
[01:58:50/03:53:56]     如果后台使用PHP做的可以吗
[01:58:53/03:53:56]     那你下载一个PP的镜像就可以了
[01:58:56/03:53:56]     或者你自己制作一个PP的镜像
[01:59:00/03:53:56]     好这个这个可以用
[01:59:47/03:53:56]     好
[01:59:48/03:53:56]     那我们就换一下
[01:59:51/03:53:56]     就dog
[02:60:03/03:53:56]     我们换一下换成这个
[02:60:08/03:53:56]     然后我们再build一下试试
[02:60:15/03:53:56]     最后披露成功了
[02:60:17/03:53:56]     那当然我们也可以通过push把它push到定向仓库里面
[02:60:23/03:53:56]     对吧
[02:60:24/03:53:56]     把它布置到定向仓库里面
[02:60:47/03:53:56]     那我们可以把它启动起来试试
[02:60:51/03:53:56]     我不知道换了这个新的技术镜像行不行
[02:60:54/03:53:56]     我们试试
[02:60:56/03:53:56]     每轮启动起来会不会出问题
[02:60:59/03:53:56]     嗯
[02:61:06/03:53:56]     那我们就5005吧
[02:61:14/03:53:56]     映射到5005
[02:61:16/03:53:56]     Blocks
[02:61:18/03:53:56]     不行
[02:61:26/03:53:56]     这个镜像临时的镜像果然不行
[02:61:37/03:53:56]     嗯
[02:61:46/03:53:56]     换换这个试试
[02:61:47/03:53:56]     我们试一下我们试一下看这行不行
[02:61:52/03:53:56]     不要着急
[02:61:53/03:53:56]     一般来说你制作的时候你就得自己多尝试尝试
[02:61:56/03:53:56]     自己多尝试尝试
[02:62:03/03:53:56]     之前的那个镜像为什么不存在了呢
[02:62:08/03:53:56]     拉不下来了呢
[02:62:09/03:53:56]     为什么
[02:62:13/03:53:56]     我
[02:62:19/03:53:56]     Base image open
[02:62:20/03:53:56]     这里可是有人把这个东西删了吗
[02:62:24/03:53:56]     在这呢
[02:62:32/03:53:56]     这是为啥
[02:62:33/03:53:56]     在这为啥下不来呢
[02:62:49/03:53:56]     这个网络是什么情况
[02:62:58/03:53:56]     如果我现场先做一个这类镜像的话
[02:63:00/03:53:56]     那可费劲了
[02:63:02/03:53:56]     我试试这个吧
[02:63:04/03:53:56]     这个估计下不下来了
[02:63:08/03:53:56]     我们看一下
[02:63:18/03:53:56]     Build
[02:63:26/03:53:56]     嗯
[02:63:32/03:53:56]     什么情况这么快呢
[02:63:34/03:53:56]     全都是开始
[02:63:36/03:53:56]     不对不对不对不对
[02:63:51/03:53:56]     试试这个
[02:64:05/03:53:56]     如果这次再不成功的话
[02:64:07/03:53:56]     我们就不尝试了
[02:64:08/03:53:56]     就给那就是简单给介绍一下做这个镜像
[02:64:11/03:53:56]     如果这次再不成功就不尝试了
[02:65:50/03:53:56]     好
[02:65:51/03:53:56]     这回我们再试试
[02:65:53/03:53:56]     再试试docker
[02:65:58/03:53:56]     我得先把之前的给删掉
[02:66:04/03:53:56]     那我们再试一下DOS
[02:66:12/03:53:56]     也不行
[02:66:15/03:53:56]     OK
[02:66:16/03:53:56]     不给大家尝试了
[02:66:17/03:53:56]     不浪费大家时间了
[02:66:19/03:53:56]     就这不知道为什么
[02:66:20/03:53:56]     这个镜像我之前在服务器镜像也被人删了
[02:66:24/03:53:56]     然后这个之前那镜像也下载不下来了
[02:66:28/03:53:56]     或者那个do镜像下载不下来了
[02:66:30/03:53:56]     不给大家演示了
[02:66:32/03:53:56]     就只给大家看一下
[02:66:34/03:53:56]     你构建镜像的时候
[02:66:35/03:53:56]     如果你已经可以找到一个其他人已经制作好的一个基础镜像的话
[02:66:39/03:53:56]     那么你的这个镜像制作的过程就会变得非常的简单
[02:66:44/03:53:56]     就会变得非常的简单
[02:66:46/03:53:56]     这个很奇怪
[02:66:49/03:53:56]     为什么就下载不下来了呢
[02:66:52/03:53:56]     Anyway OK
[02:66:54/03:53:56]     我们进入到下一个内容吧
[02:66:56/03:53:56]     我们进入下一个内容
[02:66:57/03:53:56]     下一容是讲什么呢
[02:67:00/03:53:56]     讲一下缓存
[02:67:02/03:53:56]     我不知道大家之前有没有注意过一个事情
[02:67:08/03:53:56]     我之前讲的时候
[02:67:11/03:53:56]     其实我说过
[02:67:13/03:53:56]     这里面所有的指令都可以写多个的
[02:67:16/03:53:56]     都可以写多个了
[02:67:17/03:53:56]     比如说指令这边有好多个指令
[02:67:19/03:53:56]     这里面有好多个软
[02:67:21/03:53:56]     那么
[02:67:24/03:53:56]     如果我用另外一种形式去写
[02:67:29/03:53:56]     另外一种形式是放到哪了来着比如说在这里面
[02:67:40/03:53:56]     看到里串式
[02:67:49/03:53:56]     你看就只有一个指令
[02:67:51/03:53:56]     但是我一个运行了好多shell
[02:67:53/03:53:56]     全都是用字符串拼接的方式去拼在一起去执行的
[02:67:59/03:53:56]     去执行的
[02:68:00/03:53:56]     那么我想问一下大家
[02:68:02/03:53:56]     大家现在能不能想到这两种形式各有什么优缺点吗
[02:68:08/03:53:56]     当然有些同学说说他俩啥不一样的嘛
[02:68:10/03:53:56]     个人变变成习惯
[02:68:13/03:53:56]     有的人喜欢喜欢在一个指令里边
[02:68:15/03:53:56]     有的人喜欢多个指令
[02:68:16/03:53:56]     它其实它不仅仅是一个风格的问题
[02:68:20/03:53:56]     他们在功能和性能上确实是不一样的
[02:68:23/03:53:56]     大家能有没有事先看过这个录播课的
[02:68:28/03:53:56]     录播课的时候我好像记得我讲过这块
[02:68:31/03:53:56]     有知道为有知道这是什么时候应该用一个指令
[02:68:36/03:53:56]     什么时候应该用多个指令吗
[02:68:38/03:53:56]     有同学知道吗
[02:68:48/03:53:56]     失败的时候有区别吧
[02:68:51/03:53:56]     算是吧
[02:68:52/03:53:56]     就是你可能没到点上
[02:68:53/03:53:56]     但是但是这个思已经对了
[02:68:57/03:53:56]     思路已经对了
[02:68:58/03:53:56]     然后手机尾号同学说分层策略
[02:69:04/03:53:56]     也对
[02:69:06/03:53:56]     就是已基本上基本上是对的吧
[02:69:09/03:53:56]     但是描述的太笼统了
[02:69:17/03:53:56]     还有其他答案吗
[02:69:43/03:53:56]     然后我给大家说吧
[02:69:43/03:53:56]     首先我给大家看一下
[02:69:46/03:53:56]     做一个小实验做一个小实验
[02:69:50/03:53:56]     其实刚才这实验效果
[02:69:52/03:53:56]     其实刚才给大家看过
[02:69:53/03:53:56]     就是没没估计大家也没注意
[02:69:54/03:53:56]     我也没有
[02:69:55/03:53:56]     我也没有给大家提这个事情
[02:69:58/03:53:56]     我们在这边有一个到的时候
[02:70:01/03:53:56]     如果我现在什么也不改
[02:70:05/03:53:56]     我现在什么也不干
[02:70:07/03:53:56]     就doctor build杠P
[02:70:09/03:53:56]     比如说就叫DEMO
[02:70:15/03:53:56]     叫LOCALHOST5000DEMO
[02:70:22/03:53:56]     然后第第二
[02:70:24/03:53:56]     大家能看到瞬间就结束了
[02:70:26/03:53:56]     瞬间就结束了
[02:70:28/03:53:56]     不论我重新执行多少次
[02:70:30/03:53:56]     都是一瞬间就结束了
[02:70:31/03:53:56]     而且不论我执行多少次
[02:70:33/03:53:56]     你会发现它的
[02:70:38/03:53:56]     你看它这是最后的ID是F948
[02:70:42/03:53:56]     我运行一遍
[02:70:43/03:53:56]     再运行一遍
[02:70:44/03:53:56]     再查ID还是F98
[02:70:46/03:53:56]     而它的镜线根本就没有变过
[02:70:49/03:53:56]     至于为什么会这样呢
[02:70:50/03:53:56]     大家你可以看一下
[02:70:53/03:53:56]     你们可以看一下
[02:70:55/03:53:56]     我们在这个
[02:70:57/03:53:56]     我们在这个打印出来的日志里面可以看到
[02:71:00/03:53:56]     每一步它都有一个using cash using cash
[02:71:03/03:53:56]     也就是说镜
[02:71:10/03:53:56]     它是有缓存的
[02:71:15/03:53:56]     一旦他发现你现在要执行这个步骤
[02:71:18/03:53:56]     你之前执行缓存里有它就不会重新执行了
[02:71:23/03:53:56]     重新执行
[02:71:25/03:53:56]     所以说你在同一份do票
[02:71:27/03:53:56]     如果你没有修改多次运行的话
[02:71:29/03:53:56]     其实它真正只运行那一次真正只那一次
[02:71:34/03:53:56]     而我对他做了一个更改
[02:71:36/03:53:56]     比如说我在这改了一下
[02:71:39/03:53:56]     我在这给它改一下
[02:71:42/03:53:56]     大家这时候再看一下
[02:71:45/03:53:56]     或者是加一个我再去好
[02:71:51/03:53:56]     你会发现前面的这些步还是这几步还是优金开始
[02:71:55/03:53:56]     但到这我刚才更改的这一这一步开始运行了
[02:71:59/03:53:56]     他不能再用
[02:72:02/03:53:56]     不能够再用那什么了
[02:72:04/03:53:56]     不能再用缓存了
[02:72:05/03:53:56]     因为我已经修改过了
[02:72:06/03:53:56]     它不能再用缓存了
[02:72:07/03:53:56]     这时候它就开始重新运行
[02:72:09/03:53:56]     重新安装
[02:72:11/03:53:56]     这是我刚才说的缓存
[02:72:14/03:53:56]     它是需要缓存的
[02:72:34/03:53:56]     我们等它运行完
[02:72:38/03:53:56]     OK
[02:72:39/03:53:56]     当你运行完之后
[02:72:41/03:53:56]     你这个时候你再查它的镜像
[02:72:44/03:53:56]     你看它的ID才会发生变化
[02:72:47/03:53:56]     它的ID才会发生变化
[02:72:48/03:53:56]     对吧
[02:72:49/03:53:56]     在这时候我再重新运行
[02:72:52/03:53:56]     又是瞬间就结束了
[02:72:53/03:53:56]     瞬间就结束了
[02:72:54/03:53:56]     然后你再查它的ID是没有变化的
[02:72:57/03:53:56]     也就是说docker为了提高你构建镜像的速度
[02:73:03/03:53:56]     会给每一步都加一个缓存
[02:73:15/03:53:56]     每一步都会加一个缓存
[02:73:16/03:53:56]     但是如果他发现中间有任何一步
[02:73:20/03:53:56]     修改了
[02:73:21/03:53:56]     那它后面的就都要重新执行了
[02:73:25/03:53:56]     比如说它的修改只是单纯的字符串发生变化
[02:73:28/03:53:56]     不是说实例内容方
[02:73:29/03:53:56]     比如说这里是要这个安装WG
[02:73:34/03:53:56]     那我只是换个顺序
[02:73:38/03:53:56]     你看看他是什么情况
[02:73:43/03:53:56]     就实际内容没有变化
[02:73:44/03:53:56]     我只是给它换了个顺序
[02:73:46/03:53:56]     你会发现它还是在重新运行了
[02:73:50/03:53:56]     他还是在重新运行
[02:73:52/03:53:56]     到了这一步
[02:73:53/03:53:56]     但可能有些同学会比较好奇
[02:73:57/03:53:56]     那实际安装的内容是没有变化
[02:73:59/03:53:56]     都是W还会给他
[02:74:01/03:53:56]     为什么它还要重新运行的
[02:74:03/03:53:56]     这是因为doer判断
[02:74:06/03:53:56]     你的这一步有没有缓存是什么
[02:74:08/03:53:56]     是根据你当前这个这个运行就这一步的
[02:74:13/03:53:56]     这一步的she这个字符串去做的
[02:74:17/03:53:56]     算法的最后算出那个哈希值作为依据的
[02:74:22/03:53:56]     所以说只要你的字符串有任何的改动
[02:74:25/03:53:56]     虽然你认为你实际内容没有改动
[02:74:27/03:53:56]     但是字符串有任何的改动
[02:74:29/03:53:56]     它都会导致你重新的去安装
[02:74:32/03:53:56]     重新安装
[02:74:34/03:53:56]     这是它的缓存的机制
[02:74:36/03:53:56]     那这样的这样的一个设计呢
[02:74:38/03:53:56]     就涉及到我们到底是应该用一个指令还是多个指令的问题了
[02:74:43/03:53:56]     根据我们刚才说的
[02:74:44/03:53:56]     你对这个字符串做任何的更改都会重新运行
[02:74:46/03:53:56]     那么我有想而知可以想到
[02:74:48/03:53:56]     当你在发这个镜像的时候
[02:74:53/03:53:56]     当你在开发这个镜像的时候
[02:74:58/03:53:56]     你一般是要用什么呢
[02:75:01/03:53:56]     是用多个range去写的
[02:75:03/03:53:56]     就是如果你中间任何一步写错了
[02:75:08/03:53:56]     你跑着跑着
[02:75:09/03:53:56]     跑着跑着跑着写错了
[02:75:10/03:53:56]     我知道我发现我这写错了
[02:75:12/03:53:56]     那我改中间这一步
[02:75:13/03:53:56]     那上面这些步都不会重新执行
[02:75:16/03:53:56]     它是有缓存的
[02:75:19/03:53:56]     大家能理解吧
[02:75:21/03:53:56]     所以说我们开发的
[02:75:22/03:53:56]     包括我们自己写程序
[02:75:25/03:53:56]     我们肯定是写一点就一点
[02:75:26/03:53:56]     我们不可能个大招对吧
[02:75:28/03:53:56]     就写了个1万
[02:75:30/03:53:56]     然后憋大招去测试
[02:75:31/03:53:56]     那那测试成本太高了
[02:75:33/03:53:56]     大家都是做测试的
[02:75:35/03:53:56]     一定是尽早测试
[02:75:36/03:53:56]     那么你发现bug成本就越低
[02:75:39/03:53:56]     所以说我可能写个两三行
[02:75:42/03:53:56]     我就想跑一遍看看他
[02:75:44/03:53:56]     他看看他能不能运行起来
[02:75:46/03:53:56]     看他能不能运营起来
[02:75:48/03:53:56]     那写了两行运营之后
[02:75:50/03:53:56]     我写下一行
[02:75:51/03:53:56]     然后再重新运行
[02:75:52/03:53:56]     那前面这几步我不会重新跑了
[02:75:54/03:53:56]     因为是有缓存的
[02:75:55/03:53:56]     包括如果说错了
[02:75:56/03:53:56]     我重新改一下也是一样的
[02:76:00/03:53:56]     也是一样的
[02:76:01/03:53:56]     前面都有缓存
[02:76:02/03:53:56]     所以修改
[02:76:05/03:53:56]     所以在开发镜像的时候
[02:76:07/03:53:56]     刚才的那种形式
[02:76:08/03:53:56]     刚才的那种形式就是这种是不可取的
[02:76:17/03:53:56]     如果如果你要这么写的话
[02:76:18/03:53:56]     写到可能你咣咣咣咣写了100行
[02:76:20/03:53:56]     写到第99行的时候
[02:76:22/03:53:56]     或者说你写一晚上都完了
[02:76:24/03:53:56]     然后你跑起来发现跑挂了
[02:76:27/03:53:56]     哪挂了呢
[02:76:29/03:53:56]     第99行或者说第50行的时候写错了
[02:76:31/03:53:56]     你改一下
[02:76:33/03:53:56]     你会发现前面的第前面的90几行
[02:76:36/03:53:56]     假如你第99行写错了
[02:76:38/03:53:56]     那你前面的这
[02:76:39/03:53:56]     你前面的那90多行都要重新跑一遍
[02:76:42/03:53:56]     速度是非常慢的
[02:76:44/03:53:56]     效率是非常低的
[02:76:45/03:53:56]     所以说大家一定要利用好缓存
[02:76:48/03:53:56]     尽量在你开发镜像的时候
[02:76:52/03:53:56]     开发这个do file的时候
[02:76:54/03:53:56]     一个指令里面你只写一个
[02:76:58/03:53:56]     只写一个一两个
[02:76:59/03:53:56]     好这个形式去写
[02:77:01/03:53:56]     充分的利用缓存三一
[02:77:07/03:53:56]     我这里又想问一个问题那
[02:77:09/03:53:56]     这种形式就是最好的了吗
[02:77:11/03:53:56]     就是我们要一直保持这种形态吗
[02:77:14/03:53:56]     那当然也不是为什么
[02:77:16/03:53:56]     这就涉及到了刚才这个有的同学在这个里面去这个提到的分层策略了
[02:77:25/03:53:56]     分层策略
[02:77:26/03:53:56]     我们的镜像是的
[02:77:27/03:53:56]     镜像是分很多个层的
[02:77:32/03:53:56]     的镜像是分很多个的
[02:77:36/03:53:56]     分很多个层的
[02:77:37/03:53:56]     你可以理解为一条软指令就是一层
[02:77:41/03:53:56]     一条指令就是一层
[02:77:43/03:53:56]     那么层数多了会影响你的IO性能呢
[02:77:47/03:53:56]     它为什么会影响你的IO性能呢
[02:77:49/03:53:56]     这个待会我们讲镜像的原理的时候给大家再解释
[02:77:53/03:53:56]     给大家解释
[02:77:54/03:53:56]     但是你一定要注意
[02:77:55/03:53:56]     层数过多影响你L
[02:78:00/03:53:56]     当然我说的过多的可能说解释上百层
[02:78:02/03:53:56]     你明显出来它的性能出问题了
[02:78:06/03:53:56]     就是如果你只有七八层12层的那无所谓
[02:78:09/03:53:56]     那那无所谓
[02:78:10/03:53:56]     那确实是无所谓的对吧
[02:78:14/03:53:56]     所以说
[02:78:20/03:53:56]     你的run指令不能过多
[02:78:22/03:53:56]     不能过多
[02:78:23/03:53:56]     如果你run指令过多的话
[02:78:25/03:53:56]     那你就像我刚才展示的那个do file里面写的一样
[02:78:30/03:53:56]     写的一样
[02:78:32/03:53:56]     你要做一件什么事情呢
[02:78:34/03:53:56]     你要把相应的指令进行合并
[02:78:38/03:53:56]     进行合并
[02:78:41/03:53:56]     OK
[02:78:43/03:53:56]     那这个大家能理解吗
[02:78:50/03:53:56]     有没有理解的
[02:79:25/03:53:56]     OK
[02:79:26/03:53:56]     我们接着往下讲
[02:79:27/03:53:56]     接着讲我们另外一个内容
[02:79:30/03:53:56]     就是多阶段构建
[02:79:32/03:53:56]     可以多阶段构建
[02:79:36/03:53:56]     什么是多阶段构建呢
[02:79:39/03:53:56]     就是这个这个导表
[02:79:43/03:53:56]     就是这个导表
[02:79:48/03:53:56]     多阶段构建的意思是什么呢
[02:79:50/03:53:56]     它是要解决一类问题
[02:79:57/03:53:56]     什么问题呢
[02:79:58/03:53:56]     我给大家描述一下
[02:80:00/03:53:56]     不知道大家有没有接触过持续集成相关的内容
[02:80:05/03:53:56]     如果我们产品中有很多个模块
[02:80:07/03:53:56]     每个模块都要制作自己的镜像
[02:80:09/03:53:56]     对吧
[02:80:10/03:53:56]     制作自己的产出物
[02:80:12/03:53:56]     如我们先说没有
[02:80:16/03:53:56]     没有容器
[02:80:17/03:53:56]     就是还没有容器技术
[02:80:18/03:53:56]     他们是怎么做的呢
[02:80:19/03:53:56]     是有一台编译的机器
[02:80:22/03:53:56]     不管是S
[02:80:23/03:53:56]     是把这台编译器加入到slave了
[02:80:26/03:53:56]     还是怎么样会有一个编译的机器编译
[02:80:29/03:53:56]     编译机里面呢
[02:80:32/03:53:56]     就有各种各样编译代码需要的环境依赖了
[02:80:35/03:53:56]     比如说它已经装好了JDK了
[02:80:37/03:53:56]     装好了JK了
[02:80:38/03:53:56]     装好了ma了
[02:80:40/03:53:56]     如果Python的编译机的话
[02:80:42/03:53:56]     也装好了Python相关的东西
[02:80:43/03:53:56]     它的产出需要存到一个地方
[02:80:49/03:53:56]     比如说你的加包
[02:80:50/03:53:56]     如果你是价项目的话
[02:80:51/03:53:56]     它编译出来是一个价包
[02:80:52/03:53:56]     对吧
[02:80:53/03:53:56]     那你就要存到什么呢
[02:80:55/03:53:56]     你就要存到
[02:80:56/03:53:56]     一个中间产出物里面
[02:80:59/03:53:56]     比如说NFS
[02:81:00/03:53:56]     或者说某些存储
[02:81:02/03:53:56]     分布式存储
[02:81:08/03:53:56]     然后呢
[02:81:09/03:53:56]     再到你的部署机里面去
[02:81:12/03:53:56]     或者说到你的测试环境
[02:81:15/03:53:56]     或者说叫生产环境
[02:81:18/03:53:56]     或者是什么那个
[02:81:22/03:53:56]     反正就是类似的一些部署环节去进行部署
[02:81:27/03:53:56]     嗯
[02:81:35/03:53:56]     这是没有容器的时候他们的玩法
[02:81:39/03:53:56]     他们的玩法
[02:81:40/03:53:56]     那么
[02:81:43/03:53:56]     如果有了容器要怎么做呢
[02:81:47/03:53:56]     有了容器要怎么做呢
[02:81:50/03:53:56]     有的容器一般来说
[02:81:55/03:53:56]     肯定会有什么编译镜像
[02:81:59/03:53:56]     就编译容器吧
[02:82:02/03:53:56]     叫编译容器
[02:82:05/03:53:56]     编译容器
[02:82:08/03:53:56]     它也要把产出一个夹包了
[02:82:12/03:53:56]     也要产出一个夹包的
[02:82:14/03:53:56]     然后呢
[02:82:15/03:53:56]     还会有一个部署容器
[02:82:17/03:53:56]     这里面部署镜像
[02:82:20/03:53:56]     要制作成一个部署镜像
[02:82:22/03:53:56]     这里面大家要大家要明白一点是什么呢
[02:82:25/03:53:56]     编译容器它假如说变成一个架包
[02:82:27/03:53:56]     你要把这个架包打到一个镜像里面
[02:82:30/03:53:56]     所以说你最后要还要产出一个镜出来
[02:82:34/03:53:56]     所以说你这里面有两个东西
[02:82:35/03:53:56]     有一个编译的
[02:82:36/03:53:56]     有一个部署的一个镜像编译容器
[02:82:39/03:53:56]     当然也会有一编译的镜像启动的一个一个东西
[02:82:41/03:53:56]     然后你先要把代码放到编译容器里面去进行干什么呢
[02:82:47/03:53:56]     去进行编译
[02:82:51/03:53:56]     编译出来产出架包
[02:82:53/03:53:56]     再去放到另外一个地方生成它的部署进行
[02:82:58/03:53:56]     或者说我在这边这个词比较拗口
[02:83:00/03:53:56]     比如说叫叫叫生产部署镜像的容器
[02:83:13/03:53:56]     就是说
[02:83:16/03:53:56]     他
[02:83:17/03:53:56]     这个编译容器或者说编译镜像也好
[02:83:21/03:53:56]     编译容器也好
[02:83:22/03:53:56]     你们随便怎么叫
[02:83:23/03:53:56]     需要传输架包
[02:83:27/03:53:56]     给
[02:83:28/03:53:56]     这个容器专门生产部署镜像的容器
[02:83:32/03:53:56]     然后他再去
[02:83:37/03:53:56]     制作镜像
[02:83:41/03:53:56]     制作最后最终要部署的那个镜像到
[02:83:46/03:53:56]     镜像仓库里镜像仓库
[02:83:51/03:53:56]     加法就是镜像
[02:83:56/03:53:56]     它就比就比上面的我们说虚拟机的那个时代
[02:84:01/03:53:56]     就多出了这么一步
[02:84:05/03:53:56]     多数赠与
[02:84:08/03:53:56]     然后后面他们就是在生产环境里面
[02:84:12/03:53:56]     或者在测试环境里面
[02:84:15/03:53:56]     的
[02:84:23/03:53:56]     部署到生产环境或者测试环境里面
[02:84:25/03:53:56]     测试环境
[02:84:27/03:53:56]     通过经营仓库
[02:84:30/03:53:56]     在测试环境里从经营仓库里拉到镜像
[02:84:32/03:53:56]     然后进行部署
[02:84:34/03:53:56]     那这里面本身是没有什么问题的
[02:84:37/03:53:56]     它问题出在哪儿呢
[02:84:39/03:53:56]     就是编译容器如何把价包给这个生产部署镜像的容器呢
[02:84:47/03:53:56]     它也要依赖一个中间存储
[02:84:50/03:53:56]     你知道吧
[02:84:51/03:53:56]     就他也要一类一个中间
[02:84:53/03:53:56]     中间我们把这两个把后面的先先删掉
[02:84:56/03:53:56]     后面删它也要依赖一个中间存储
[02:84:58/03:53:56]     它没有办法直接传过去
[02:85:01/03:53:56]     那怎么办呢
[02:85:02/03:53:56]     依赖一个中间存储
[02:85:04/03:53:56]     这个中间存储可能是什么呢
[02:85:13/03:53:56]     也是一个类似于NFS的一个
[02:85:19/03:53:56]     一个分布式存储
[02:85:22/03:53:56]     当然它也可能是什么呢
[02:85:23/03:53:56]     它也可能是一个本地存储
[02:85:27/03:53:56]     它也可能是本地的
[02:85:29/03:53:56]     就是说编译容器和生产部署定向的容器呢
[02:85:32/03:53:56]     就是它它俩可是可以在一块
[02:85:34/03:53:56]     是可以在一台机器上的
[02:85:37/03:53:56]     是完全可以
[02:85:38/03:53:56]     所以说它也可以用本地存储
[02:85:39/03:53:56]     那怎么用本地存储也比较简单
[02:85:41/03:53:56]     也比较简单
[02:85:42/03:53:56]     那很简单
[02:85:43/03:53:56]     就比如说你编译容器和这个生产部署的这个镜像的这个容器
[02:85:48/03:53:56]     它俩挂在同一个目径就行了
[02:85:51/03:53:56]     生产部署镜像容器
[02:85:56/03:53:56]     你让他们两个挂在同一个
[02:86:00/03:53:56]     这样的话他俩就共享目录了嘛
[02:86:02/03:53:56]     所以说编译容器生产的包就可以被生产部署镜像容器的那个
[02:86:08/03:53:56]     那个这个容器给读取的到了
[02:86:11/03:53:56]     大家能明白吧
[02:86:12/03:53:56]     只要两个挂在同一个目录就行
[02:86:16/03:53:56]     挂在同一个目录
[02:86:27/03:53:56]     同一个目录
[02:86:29/03:53:56]     那这里面一直有一个问题是什么呢
[02:86:31/03:53:56]     一直有一个问题是什么呢
[02:86:34/03:53:56]     一直有一个问题
[02:86:35/03:53:56]     就是说你一定要有一个地方去
[02:86:37/03:53:56]     它的中间产物就是这个包
[02:86:40/03:53:56]     就这个架包
[02:86:42/03:53:56]     但这个架包理论上是没有什么卵用的
[02:86:46/03:53:56]     它是没什么用的
[02:86:47/03:53:56]     它跟如果说你是在没有容器的时代
[02:86:50/03:53:56]     你的这个架包
[02:86:51/03:53:56]     你这个架包存架包的这些地方就是有用的
[02:86:54/03:53:56]     因为这个包就是最终的产出
[02:86:55/03:53:56]     你要放在测试环境里面去进行部署的
[02:86:57/03:53:56]     但是在容器时代
[02:87:01/03:53:56]     你这加班没有什么用
[02:87:05/03:53:56]     因为最终到生产环境或者说到测试环境里面
[02:87:09/03:53:56]     它的是镜
[02:87:10/03:53:56]     有镜就可以了
[02:87:12/03:53:56]     所以说你这中间会产生的这个包是没有任何作用的
[02:87:18/03:53:56]     它是没有任何作用的
[02:87:21/03:53:56]     只要进项出来之后
[02:87:23/03:53:56]     这个加班就可以退休了
[02:87:26/03:53:56]     所以说这就造成了一个问题呢
[02:87:27/03:53:56]     如果你再去构建这样的一个编译机器的话
[02:87:30/03:53:56]     你的成本除了有镜像仓库之外
[02:87:32/03:53:56]     你成本除了有定向仓库之外
[02:87:36/03:53:56]     你还要再有一个存储的成本是存这些包的
[02:87:41/03:53:56]     存这些加班的
[02:87:43/03:53:56]     那这个东西就比较麻烦
[02:87:46/03:53:56]     那我们可不可以有一种形式是什么呢
[02:87:48/03:53:56]     我们能不能让不要这个目录了
[02:87:51/03:53:56]     我能不能让编译的
[02:87:54/03:53:56]     直接编译出来的包
[02:87:56/03:53:56]     就不通过任何的中间的存储介质
[02:87:59/03:53:56]     直接传到这里面可以
[02:88:03/03:53:56]     这就是多阶段构建
[02:88:09/03:53:56]     就是这个do file里展示的内容
[02:88:13/03:53:56]     这个里展示的内容
[02:88:14/03:53:56]     那这种多构实际上是什么
[02:88:17/03:53:56]     是个就是多个
[02:88:20/03:53:56]     以有两个from指令的
[02:88:34/03:53:56]     有令
[02:88:44/03:53:56]     比如说我们可以把第一个from指令就当成我们刚才的编译过程
[02:88:51/03:53:56]     代表我们编译过程
[02:88:52/03:53:56]     我们模拟一下
[02:88:53/03:53:56]     比如说我们一开始的编译
[02:88:55/03:53:56]     编译它需要一个比较完整的环境
[02:88:57/03:53:56]     比如说它下载是6.9
[02:89:00/03:53:56]     然后假设我们下面我们是模拟出来一个叫点的一个包出来
[02:89:05/03:53:56]     这就是我出的物镜镜box
[02:89:13/03:53:56]     是from box
[02:89:14/03:53:56]     因为什么呢
[02:89:15/03:53:56]     因为这个部署镜一般要的要精要小
[02:89:19/03:53:56]     它不能直接用量太大了
[02:89:23/03:53:56]     所以说只是运行一个包嘛
[02:89:25/03:53:56]     只要有一个box
[02:89:26/03:53:56]     然后上面装一个
[02:89:27/03:53:56]     装一个g re就行了
[02:89:29/03:53:56]     对吧
[02:89:30/03:53:56]     然后这里面关键在什么地方呢
[02:89:32/03:53:56]     关键就在于我们在运行第一个from指令的时候
[02:89:36/03:53:56]     用了一个S给它起了一个别名
[02:89:39/03:53:56]     这个别名叫什么
[02:89:40/03:53:56]     叫builder
[02:89:42/03:53:56]     这个别名叫builder
[02:89:45/03:53:56]     然后
[02:89:47/03:53:56]     然后我们在构建最终的部署镜像的时候
[02:89:49/03:53:56]     就会有一个copy指令
[02:89:52/03:53:56]     Copy指令然后杠杠from等于build
[02:89:56/03:53:56]     意思是什么呢
[02:89:57/03:53:56]     从上一个镜像里面copy东西
[02:90:00/03:53:56]     Copy什么的呢
[02:90:02/03:53:56]     考会
[02:90:05/03:53:56]     这个得改一下
[02:90:11/03:53:56]     加Frank加carfrank.car copy过来
[02:90:14/03:53:56]     就是说从上一个镜里边拷东西
[02:90:17/03:53:56]     这样我们就完成了
[02:90:18/03:53:56]     什么呢
[02:90:19/03:53:56]     我们就完成了编译到部署的
[02:90:21/03:53:56]     直接把架包传递过去
[02:90:23/03:53:56]     没有中间商了
[02:90:26/03:53:56]     这时候就没有中间商了
[02:90:27/03:53:56]     这个就是多基站构
[02:90:30/03:53:56]     当我们运行这个build之后
[02:90:33/03:53:56]     当我们运行完这个刀客
[02:90:35/03:53:56]     这个刀客镜线之后
[02:90:36/03:53:56]     在本地是就是你在任何地方其实都是找不到什么呢
[02:90:40/03:53:56]     等于都是找不到那个径
[02:90:43/03:53:56]     找不到那个加包了因为我们没有中间商的这个需要保保存加包的这个步骤了已经
[02:90:51/03:53:56]     OK
[02:90:52/03:53:56]     这个就是多阶段构建多阶段构建大家能明白否
[02:91:01/03:53:56]     能明白吗
[02:91:09/03:53:56]     大家能明白吗
[02:91:16/03:53:56]     有没有不明白的吗
[02:91:18/03:53:56]     不明白的打一哪
[02:91:19/03:53:56]     不明白我再给你讲一遍
[02:91:59/03:53:56]     如果没有问题的话
[02:92:00/03:53:56]     没有问题就这样
[02:92:02/03:53:56]     这回给大家练习时间就比较少了
[02:92:05/03:53:56]     就给大家十分钟到15分钟时间吧
[02:92:08/03:53:56]     因为后面我还要讲比较多的内容
[02:92:12/03:53:56]     把这个do这个多阶段构建和我刚才讲到的一些内容都实践一遍
[02:92:17/03:53:56]     包括缓存
[02:92:18/03:53:56]     感受一下那个缓存
[02:92:22/03:53:56]     来多技能构建
[02:92:25/03:53:56]     我怎么复制他去了
[02:92:26/03:53:56]     这多技能构建在这
[02:92:45/03:53:56]     多阶段多阶段勾结
[02:92:49/03:53:56]     OK
[02:92:50/03:53:56]     大家开始练习吧
[02:92:52/03:53:56]     十到15分钟时间
[02:92:54/03:53:56]     这样吧
[02:92:55/03:53:56]     我们现在是04:33
[02:92:59/03:53:56]     我们04:50回来
[02:93:00/03:53:56]     大家掐点
[02:93:01/03:53:56]     这样也给大家一点休息时间
[02:93:03/03:53:56]     如果大家不愿意练习的话
[02:93:04/03:53:56]     自己休息休息就好吧
[02:96:21/03:53:56]     挑衅我们在
[02:96:37/03:53:56]     一日去
[02:97:48/03:53:56]     可以说
[02:98:04/03:53:56]     的信念
[02:98:39/03:53:56]     网上有那么多大师的游戏
[02:99:56/03:53:56]     其实这些事情
[02:100:03/03:53:56]     是期的
[02:100:11/03:53:56]     一片日可见
[02:100:14/03:53:56]     好
[02:101:12/03:53:56]     你还是喜欢学习
[02:101:48/03:53:56]     做的事情
[02:102:06/03:53:56]     无耻
[02:102:39/03:53:56]     就去
[02:103:21/03:53:56]     说等于几点要去a
[02:103:50/03:53:56]     还是继续
[02:105:19/03:53:56]     这是
[02:105:26/03:53:56]     相
[02:105:28/03:53:56]     程序
[02:106:07/03:53:56]     双手
[02:106:40/03:53:56]     坚定和真心相爱
[02:106:46/03:53:56]     取于
[02:109:17/03:53:56]     出来了
[02:109:31/03:53:56]     嗯
[02:110:45/03:53:56]     OK
[02:110:59/03:53:56]     大家回来吧
[02:111:02/03:53:56]     我们要接着往下讲
[02:111:04/03:53:56]     刚才我也是趁着这段时间呢
[02:111:07/03:53:56]     我把之前的镜像又给找回来了
[02:111:11/03:53:56]     我把之前的镜像找回来
[02:111:12/03:53:56]     我们刚才不是给大家演示这个启动制作一个Java的一个
[02:111:19/03:53:56]     制作一个Java的一个镜像嘛
[02:111:21/03:53:56]     然后失败了嘛
[02:111:23/03:53:56]     是因为我当初做当初找的那个基础镜像
[02:111:27/03:53:56]     它下载不下来了
[02:111:28/03:53:56]     那刚才我已经把它找回来了
[02:111:29/03:53:56]     找回来之后呢
[02:111:31/03:53:56]     那我们重新看一下这个do
[02:111:33/03:53:56]     那我们依赖的是这个JDKJDK8的这么一个基础的定向
[02:111:38/03:53:56]     对吧
[02:111:40/03:53:56]     然后呢
[02:111:41/03:53:56]     把我们的打进来
[02:111:42/03:53:56]     把我们打进来
[02:111:43/03:53:56]     所以说它的流程还是跟以前一样
[02:111:45/03:53:56]     流程还是跟以前一样
[02:111:47/03:53:56]     通过这个maven package打包
[02:112:00/03:53:56]     打出的包呢
[02:112:00/03:53:56]     它会在这个target目录下呢
[02:112:01/03:53:56]     在这
[02:112:03/03:53:56]     所以说我们在data file data file里面是要把用I的指令把这个加班给
[02:112:10/03:53:56]     把这个架包给copy过来
[02:112:14/03:53:56]     加到我们当前镜像里面
[02:112:15/03:53:56]     然后再用en里用BI命令呢
[02:112:18/03:53:56]     去运行Java杠架这么一个命令
[02:112:20/03:53:56]     把它启动起来所以说我们用这个
[02:112:25/03:53:56]     Docker build命令
[02:112:27/03:53:56]     我们去
[02:112:29/03:53:56]     尺度定向
[02:112:32/03:53:56]     好制作完毕
[02:112:33/03:53:56]     制作完毕之后呢
[02:112:35/03:53:56]     就要去这个
[02:112:40/03:53:56]     我先把它删掉
[02:112:42/03:53:56]     然后制把它制作完镜像之后把它启动起来
[02:112:46/03:53:56]     好
[02:112:47/03:53:56]     启动起来之后我们用命令
[02:112:51/03:53:56]     去看一下他的日志
[02:112:53/03:53:56]     他的日志没有问题
[02:112:56/03:53:56]     然后我们到这边去刷新一下
[02:112:58/03:53:56]     他启动服务就在这儿
[02:113:00/03:53:56]     这个就是我们刚才说的用Java写的一个X expter
[02:113:03/03:53:56]     普罗米修斯的ex expter
[02:113:06/03:53:56]     如果我们这时候看日志的话
[02:113:08/03:53:56]     你可以让他会刷刷指标
[02:113:10/03:53:56]     他会不停的刷指标
[02:113:12/03:53:56]     再过一段时间应该还会再刷一个指标过来
[02:113:19/03:53:56]     你看3.0了都
[02:113:21/03:53:56]     因为我写的是一个累加
[02:113:24/03:53:56]     我写的是一个累加
[02:113:26/03:53:56]     它会一直再刷刷3.0
[02:113:28/03:53:56]     再变成四点零一会会有五点零一直在累加
[02:113:31/03:53:56]     指标会在累加
[02:113:33/03:53:56]     好吧
[02:113:34/03:53:56]     那这个算是给给演示成功了
[02:113:36/03:53:56]     刚才来给大家要需要演示的这个东西
[02:113:39/03:53:56]     给演示成功了
[02:113:40/03:53:56]     好吧
[02:113:41/03:53:56]     那好
[02:113:42/03:53:56]     接下来那个如果没有别的问题
[02:113:44/03:53:56]     我们开始进行下一个内容一个内容是什么内容呢
[02:113:47/03:53:56]     我们讲一下镜像的一个原理
[02:113:52/03:53:56]     就好像我们刚才说缓存的时候说
[02:113:56/03:53:56]     我们都说这个的是分层的
[02:113:58/03:53:56]     那这个分层是个什么概念呢
[02:114:02/03:53:56]     这涉及到一个特殊的文件系统
[02:114:07/03:53:56]     特殊的文件系统叫什么呢
[02:114:10/03:53:56]     叫联合文件系统
[02:114:14/03:53:56]     联合文件系统联合文件系统讲的是什么东西呢
[02:114:18/03:53:56]     联合文件系统讲的是什么东西呢
[02:114:21/03:53:56]     他讲的是
[02:114:23/03:53:56]     联合文件系统讲的是
[02:114:28/03:53:56]     如果我们现在有两个目录
[02:114:31/03:53:56]     X目录和Y目录
[02:114:39/03:53:56]     而在X目录和目录下呢
[02:114:42/03:53:56]     分别又有两个文件
[02:114:53/03:53:56]     文件a和文件
[02:114:56/03:53:56]     B
[02:114:58/03:53:56]     文件a和文件
[02:115:01/03:53:56]     B
[02:115:09/03:53:56]     那如果我们有一个系统的管理员
[02:115:14/03:53:56]     文件的管理员
[02:115:15/03:53:56]     他要管理这些这个系统里面的所有的文件
[02:115:19/03:53:56]     那他要想操作a文件或者B文件的话
[02:115:22/03:53:56]     势必就要切换到对应的目录和Y目录下
[02:115:26/03:53:56]     它会稍微有点麻烦
[02:115:27/03:53:56]     那当然了
[02:115:28/03:53:56]     如果现在我们只有两个目录的话
[02:115:30/03:53:56]     两个文件的话
[02:115:32/03:53:56]     两个文件对两个目录
[02:115:33/03:53:56]     所以说这样那还好
[02:115:35/03:53:56]     但是如果我有成千上万个文件和目录
[02:115:40/03:53:56]     或者说几十万个文件或者目录的话
[02:115:42/03:53:56]     那么维护这些文件就是一个噩梦了
[02:115:44/03:53:56]     所以我们有没有可能给用户提供一个新的视图呢
[02:115:49/03:53:56]     能够让在一个目录里面就能看到所有的文件呢
[02:115:54/03:53:56]     这个就是联合系统要干的事情
[02:115:56/03:53:56]     联合文件系统要干的事情
[02:115:57/03:53:56]     他呢把这些目录
[02:116:00/03:53:56]     通通的挂载到
[02:116:02/03:53:56]     就把这些文件
[02:116:03/03:53:56]     这些文件通通挂载到了同一个目录下面
[02:116:06/03:53:56]     这这这目录
[02:116:08/03:53:56]     这是我们的视图
[02:116:10/03:53:56]     那
[02:116:14/03:53:56]     复制错了
[02:116:16/03:53:56]     我们是可以在这个字目录这个视图下既能看到a文件
[02:116:20/03:53:56]     也能看到B文件的
[02:116:24/03:53:56]     你既能看到a文件也能看到B文件
[02:116:27/03:53:56]     那么
[02:116:30/03:53:56]     那么这个时候用户可以通过Z目录去管理这些文件
[02:116:36/03:53:56]     而没有必要再去切换到X目录录
[02:116:47/03:53:56]     这个时候如果你认真观察就会发现X目录下的a文件中也会追加一个单词叫hello
[02:116:55/03:53:56]     也就是说用户在视图这一层目录里面针对a文件的更改都会直接影响到他的原文件
[02:117:06/03:53:56]     这也就是为什么用户可以放心的在图层进行管理的原因
[02:117:12/03:53:56]     因为它会直接影响到它的原文件
[02:117:15/03:53:56]     那同理
[02:117:16/03:53:56]     如果我们像B文件也加了一单
[02:117:23/03:53:56]     叫word
[02:117:25/03:53:56]     那么它会在它的B的语言文件下也会追加一个叫word的单词吗
[02:117:32/03:53:56]     答案是不会的
[02:117:34/03:53:56]     相反是什么呢
[02:117:37/03:53:56]     相反它会在X目录下
[02:117:42/03:53:56]     添加一个文件
[02:117:43/03:53:56]     这个文件是干嘛的呢
[02:117:46/03:53:56]     记录着sorry sorry sorry
[02:117:50/03:53:56]     什么情况这是
[02:117:54/03:53:56]     记录的B的更改针对B的更改
[02:118:01/03:53:56]     也就是说
[02:118:03/03:53:56]     针对B文件的修改并没有直接影响到他的原文件
[02:118:06/03:53:56]     而是说在X目录下面
[02:118:08/03:53:56]     把这份修改记录在X目录下
[02:118:12/03:53:56]     然后但是从用户角度看
[02:118:15/03:53:56]     这个文件也已经被加了一个word这个单词
[02:118:19/03:53:56]     因为最终展现给用户是什么呢
[02:118:22/03:53:56]     是B的原文件和这个B的更改文件进行的制
[02:118:25/03:53:56]     制完了之后呈现给用户的
[02:118:28/03:53:56]     所以说虽然
[02:118:31/03:53:56]     虽然针对B文件的更改并没有像文件一样直接影响到文件
[02:118:35/03:53:56]     但是用户是不感知的
[02:118:37/03:53:56]     在用户的视角里面
[02:118:38/03:53:56]     A文件和B文件的行为是一样的
[02:118:40/03:53:56]     是一样的
[02:118:41/03:53:56]     用户是不感知底下的这层东西的
[02:118:45/03:53:56]     但它为什么会出现这个样子的行为呢
[02:118:48/03:53:56]     就是为什么我们不能让文件更改
[02:118:50/03:53:56]     直接影响到它的原文件呢
[02:118:53/03:53:56]     原因是
[02:118:55/03:53:56]     联合文件系统
[02:118:58/03:53:56]     它在这个
[02:119:01/03:53:56]     联合这些目录的时候是可以
[02:119:06/03:53:56]     是可以控制对应的权限的
[02:119:13/03:53:56]     读写权限的
[02:119:14/03:53:56]     而docker的做法是什么呢
[02:119:15/03:53:56]     只会在联合文件文件系统中的第一个目录里面给他读写权限
[02:119:22/03:53:56]     也就是说只有这个目录有读写权限
[02:119:25/03:53:56]     这个目录是只读的
[02:119:28/03:53:56]     是只读的
[02:119:29/03:53:56]     是只读权限
[02:119:31/03:53:56]     那么正因为它只有只读的
[02:119:33/03:53:56]     所以说针对于B的修改不可能影响到语言文件
[02:119:37/03:53:56]     就是它只能做的事情只能是
[02:119:40/03:53:56]     更改的内容记录在X目下来下面去
[02:119:44/03:53:56]     然后最终呈现给用户的时候
[02:119:46/03:53:56]     是把这个更改文件和它的原文件去进行一轮墨制
[02:119:50/03:53:56]     然后再去呈现给他
[02:119:52/03:53:56]     再去呈现给他这个就是联合文件系统
[02:119:57/03:53:56]     那经过这样的一个解释
[02:119:59/03:53:56]     大家是不是会能能不能联想到
[03:120:03/03:53:56]     就他跟我们的镜像系统有什么有什么关系吗
[03:120:10/03:53:56]     它跟我们的镜像系统有什么关系吗
[03:120:12/03:53:56]     答案是有的
[03:120:15/03:53:56]     这个只读层
[03:120:18/03:53:56]     就是我们的镜像层
[03:120:21/03:53:56]     而可读可写就是容器
[03:120:24/03:53:56]     而这个就是视图
[03:120:28/03:53:56]     大家想一下
[03:120:29/03:53:56]     大家能不能理解一下
[03:120:31/03:53:56]     也就是说我们登录到容器里面
[03:120:33/03:53:56]     我们看到的所有的目录是是docker给我们用联合文件系统给联合出来的
[03:120:41/03:53:56]     你看到所有的目录
[03:120:42/03:53:56]     所有的文件
[03:120:44/03:53:56]     它的底层都是这样的一个结构
[03:120:46/03:53:56]     你看到的视图层
[03:120:48/03:53:56]     它的底下是由容器层和镜像层目录去共同
[03:120:54/03:53:56]     维护的
[03:120:56/03:53:56]     共同维护的
[03:120:58/03:53:56]     这个大家能就能理解为啥镜像必须是只读了
[03:121:03/03:53:56]     那你不能改镜像
[03:121:04/03:53:56]     你不能因为起了一个容器就直接把镜像给改掉
[03:121:07/03:53:56]     那肯定是不能的
[03:121:08/03:53:56]     镜像一定是只读的
[03:121:12/03:53:56]     而容器层是可以写的
[03:121:14/03:53:56]     容器上是可以写的对吧
[03:121:19/03:53:56]     所以说
[03:121:22/03:53:56]     我们总说那什么嘛
[03:121:24/03:53:56]     就是容器到底是个什么东西嘛
[03:121:27/03:53:56]     然后我们真说容器就是个进程
[03:121:29/03:53:56]     然后只是它用的不同的名称空间
[03:121:31/03:53:56]     那对于目录来说
[03:121:35/03:53:56]     从镜像这个角度来看的话
[03:121:36/03:53:56]     容器在启动的时候其实是干了什么事呢
[03:121:40/03:53:56]     其实是把这一套联合文件系统的目录挂载到了
[03:121:45/03:53:56]     通过一个叫做mount namespace
[03:121:49/03:53:56]     就是挂载名生载到了哪呢
[03:121:54/03:53:56]     到了
[03:121:56/03:53:56]     容器的就是容器的
[03:121:58/03:53:56]     也确实就是容器的那个进程的root FS上
[03:122:02/03:53:56]     这样的话
[03:122:03/03:53:56]     你一登录了容器之后
[03:122:04/03:53:56]     你就看不到四主机的副主机的那些目录了
[03:122:07/03:53:56]     因为你现在挂载挂载的容器的这个进程的这个root FS的这个目录是什么呢
[03:122:15/03:53:56]     是你镜像
[03:122:16/03:53:56]     是你的第一堆镜像的目录
[03:122:18/03:53:56]     待着别
[03:122:21/03:53:56]     那明白for
[03:122:23/03:53:56]     这是我们上节课民生空间和我们
[03:122:29/03:53:56]     当前的这个这个联合文件系统的一个结合的一个知识点
[03:122:33/03:53:56]     结合的一个知识点
[03:122:34/03:53:56]     那么制作镜像是怎么回事呢
[03:122:37/03:53:56]     其实制作镜像比较简单
[03:122:38/03:53:56]     我把这些没用的删掉
[03:122:40/03:53:56]     这的镜像也很简单
[03:122:41/03:53:56]     当我们要制作一个镜像的时候
[03:122:45/03:53:56]     其实是什么呢
[03:122:46/03:53:56]     其实是把这个镜像的目录copy了一份
[03:122:49/03:53:56]     移动到这边
[03:122:51/03:53:56]     它就然后让它指向下一层镜像
[03:122:56/03:53:56]     它就变成了一个两层的镜像
[03:122:59/03:53:56]     用这个两层的镜像再去启动一个容器是什么呢
[03:123:04/03:53:56]     其实就是启动了一个空的一个容器层
[03:123:07/03:53:56]     空的一个容器什么都没有
[03:123:09/03:53:56]     容器层然后跟这边的镜像层进行联合
[03:123:13/03:53:56]     进行联合
[03:123:14/03:53:56]     那如果说我们在这边添加了一个C文件保存到了这里
[03:123:21/03:53:56]     我们再通过它制作一个镜像
[03:123:23/03:53:56]     也是把它COPY1份copy到这边来
[03:123:27/03:53:56]     然后指向下一层
[03:123:29/03:53:56]     它就变成了三层的容器
[03:123:36/03:53:56]     它是三层的形象
[03:123:39/03:53:56]     这样以此类推
[03:123:43/03:53:56]     这就是镜像制作的一个过程
[03:123:47/03:53:56]     这就是镜像制作的过程
[03:123:50/03:53:56]     讲到这儿
[03:123:51/03:53:56]     大家有不明白的吗
[03:124:15/03:53:56]     大家还有不明白的吗
[03:124:31/03:53:56]     好没有的话
[03:124:32/03:53:56]     我就接往下讲了
[03:124:33/03:53:56]     就继续往下讲了
[03:124:34/03:53:56]     那我问大家一个问题
[03:124:37/03:53:56]     这样去设计
[03:124:39/03:53:56]     它有什么优点吗
[03:124:40/03:53:56]     他为什么要这么搞
[03:124:42/03:53:56]     这么复杂
[03:124:44/03:53:56]     因为我们说
[03:124:46/03:53:56]     那么搞成这个样子
[03:124:48/03:53:56]     对于IO一定是有损耗的
[03:124:51/03:53:56]     我们刚才也说就缓缓存的时候不也说嘛
[03:124:54/03:53:56]     数太多的话是有损耗的
[03:124:59/03:53:56]     是有损耗的
[03:125:01/03:53:56]     它损耗在哪呢
[03:125:02/03:53:56]     损损耗在什么地方呢
[03:125:04/03:53:56]     它损耗在什么地方呢
[03:125:09/03:53:56]     我们的一个文件
[03:125:10/03:53:56]     它可能是有好多个文件出来的
[03:125:12/03:53:56]     你看到的是一个B
[03:125:13/03:53:56]     但可能是什么呢
[03:125:14/03:53:56]     它可能是
[03:125:18/03:53:56]     每一层都有一个针对于B文件的改
[03:125:21/03:53:56]     这是原文件
[03:125:22/03:53:56]     这是B文件的更改
[03:125:23/03:53:56]     这又是一个文件的更改
[03:125:24/03:53:56]     它是经过一轮末制以后
[03:125:27/03:53:56]     才给它呈现出来的
[03:125:30/03:53:56]     但每多墨这一层
[03:125:32/03:53:56]     它的IO一定会有损耗的
[03:125:35/03:53:56]     所说它的ioe是一定会有损耗
[03:125:36/03:53:56]     虽然损耗的很小
[03:125:38/03:53:56]     损耗的很小很小很小
[03:125:39/03:53:56]     但是它也是有损的
[03:125:41/03:53:56]     那你受多了
[03:125:42/03:53:56]     你肯定受不了
[03:125:44/03:53:56]     你层数多了就肯定受不了对吧
[03:125:48/03:53:56]     那么
[03:125:53/03:53:56]     既然如此
[03:125:54/03:53:56]     那他为什么还要这么设计呢
[03:125:55/03:53:56]     大家有没有想到的
[03:125:58/03:53:56]     有的话在见面回答我
[03:126:14/03:53:56]     有没有知道的
[03:126:15/03:53:56]     一个都没有吗
[03:126:16/03:53:56]     你们录播课是一点都没看吗
[03:126:18/03:53:56]     我录播我录播课里应该提到过一些的
[03:126:26/03:53:56]     有没有知道答案的
[03:126:38/03:53:56]     是方便管理吗
[03:126:41/03:53:56]     不对不对
[03:126:45/03:53:56]     再想想
[03:127:28/03:53:56]     就是大家往
[03:127:33/03:53:56]     那这样吧
[03:127:34/03:53:56]     我直接给他说吧
[03:127:35/03:53:56]     这是为了什么呢
[03:127:36/03:53:56]     为了节省磁盘空间
[03:127:38/03:53:56]     为了复用
[03:127:39/03:53:56]     为了性能
[03:127:40/03:53:56]     当然我性能不是说IO性能
[03:127:42/03:53:56]     大家可以想一下
[03:127:44/03:53:56]     就是这一层是一层依赖一层的
[03:127:47/03:53:56]     一层依赖一层的
[03:127:50/03:53:56]     但是谁告诉你说这一层只能被一个上层依赖呢
[03:127:54/03:53:56]     它完全是可以这样的
[03:127:57/03:53:56]     我完全是可以这样的
[03:128:01/03:53:56]     就是说我把这些名字删掉
[03:128:08/03:53:56]     你完全可以让很多层
[03:128:12/03:53:56]     就很很多个镜像都依赖于下边这一层
[03:128:19/03:53:56]     这样可以什么
[03:128:20/03:53:56]     这样是复用的
[03:128:24/03:53:56]     这是复用
[03:128:25/03:53:56]     还记得我们用这个do撇S杠S
[03:128:35/03:53:56]     这个命令我们刚才曾经看到过
[03:128:43/03:53:56]     这里边儿不是有握手吗
[03:128:46/03:53:56]     握是7000
[03:128:48/03:53:56]     你看这个握手是709兆
[03:128:50/03:53:56]     为什么他说握手是虚拟的呢
[03:128:52/03:53:56]     他计算不出精准的这个镜像大小的
[03:128:55/03:53:56]     就是没有任何人能计算清楚的
[03:128:58/03:53:56]     为什么
[03:128:59/03:53:56]     就是因为就是因为他可能是说你
[03:129:02/03:53:56]     这里面占的709兆兆兆
[03:129:04/03:53:56]     下一个可能还有一个709兆
[03:129:06/03:53:56]     他们用的可能都是同一个基础层
[03:129:10/03:53:56]     可能都是用的同一个基础层
[03:129:12/03:53:56]     这些磁盘空间不是它独占的
[03:129:16/03:53:56]     所以说它用一个来表示就就是意思就是告诉你
[03:129:19/03:53:56]     不要说以为这里边我标了个709兆
[03:129:22/03:53:56]     就这个镜像是7000兆
[03:129:23/03:53:56]     这个镜像是20226兆
[03:129:25/03:53:56]     这个镜像就190兆
[03:129:26/03:53:56]     你就把这些东西所有东西都累加一起
[03:129:28/03:53:56]     你就觉得这是这些所有镜像的这个磁盘空间的总和了
[03:129:32/03:53:56]     那肯定不是的
[03:129:35/03:53:56]     因为他们是当中是有用的
[03:129:38/03:53:56]     用在假如说这是一个基础的一个S镜
[03:129:43/03:53:56]     一个技术渗S镜像
[03:129:48/03:53:56]     假如他占了一点零两个G吧
[03:129:54/03:53:56]     假如说他占了两个G
[03:129:57/03:53:56]     这可能是一个
[03:129:59/03:53:56]     这是一个
[03:130:01/03:53:56]     这是一个javascript
[03:130:07/03:53:56]     操script
[03:130:12/03:53:56]     怎么老拼错script
[03:130:15/03:53:56]     他们都可以指向下面的那个S
[03:130:18/03:53:56]     对吧
[03:130:24/03:53:56]     然后他在上面呢
[03:130:26/03:53:56]     可能就是上面的具体的业务了
[03:130:28/03:53:56]     可能是这是APP
[03:130:36/03:53:56]     也可以服用Java这一层
[03:130:41/03:53:56]     假如说6S2个g Java这一层一个G代码
[03:130:45/03:53:56]     很小的代码
[03:130:46/03:53:56]     有个50到100兆
[03:130:47/03:53:56]     很不错了
[03:130:50/03:53:56]     那加起来它们的磁汉空间有多少呢
[03:130:53/03:53:56]     如果说我们不分层
[03:130:54/03:53:56]     每一个镜像都有一个独立的SX镜线里的一些目录
[03:130:59/03:53:56]     那你要加起来的话
[03:131:00/03:53:56]     比如说这个APP加起来就是3G3100兆
[03:131:03/03:53:56]     这个也是3100兆
[03:131:05/03:53:56]     那如果你有这种分层
[03:131:07/03:53:56]     你有这种复用
[03:131:08/03:53:56]     那么其实这三
[03:131:11/03:53:56]     这三剂是什么呢
[03:131:13/03:53:56]     是可以复用的我们算一下
[03:131:16/03:53:56]     假如说有分层
[03:131:17/03:53:56]     有分层有复用
[03:131:22/03:53:56]     那它是什么呢
[03:131:23/03:53:56]     就是1G
[03:131:24/03:53:56]     就是2G加1G加100兆再加100兆等于多少呢
[03:131:33/03:53:56]     等于3200兆
[03:131:37/03:53:56]     就这两个镜像加起来就是3200兆
[03:131:40/03:53:56]     那如果没有分层
[03:131:41/03:53:56]     没有分层和复用
[03:131:44/03:53:56]     它是什么呢
[03:131:46/03:53:56]     那你就是2G加1G再加
[03:131:51/03:53:56]     100兆
[03:131:53/03:53:56]     你是乘以二的
[03:131:57/03:53:56]     嗯
[03:132:02/03:53:56]     乘以二
[03:132:04/03:53:56]     这等于多少
[03:132:08/03:53:56]     6200兆它就变成了6200兆
[03:132:12/03:53:56]     为什么乘以二呢
[03:132:13/03:53:56]     因为它没有服用了
[03:132:15/03:53:56]     每一个它都得有一个底下的1G2G
[03:132:18/03:53:56]     就是加起来一共三个G的这个空间
[03:132:20/03:53:56]     所以说它的第一个好处是什么
[03:132:23/03:53:56]     节省磁盘空间
[03:132:25/03:53:56]     它一旦有复用了之后
[03:132:26/03:53:56]     就节省了磁盘空间
[03:132:29/03:53:56]     大家能理解吗
[03:132:51/03:53:56]     大家有不理解的吗这
[03:132:58/03:53:56]     有不理解的吗
[03:133:01/03:53:56]     不没有不理解
[03:133:04/03:53:56]     我接着往下说
[03:133:05/03:53:56]     这是它的第一个优点
[03:133:07/03:53:56]     是节省磁盘空间的
[03:133:10/03:53:56]     第二优点是什么呢
[03:133:13/03:53:56]     第二优点是什呢
[03:133:14/03:53:56]     第二优点是增加你的启动速度
[03:133:18/03:53:56]     就是就是提升你的启动的速度和系统的稳定性
[03:133:23/03:53:56]     可能有的同学问为什么会这样呢
[03:133:26/03:53:56]     就是说那个增加这个减少磁盘空间
[03:133:30/03:53:56]     这个我能理解
[03:133:32/03:53:56]     那跟系统的稳定性和启动速度有什么关系呢
[03:133:35/03:53:56]     大家想真正的企业产品
[03:133:39/03:53:56]     肯定不是裸刀了
[03:133:41/03:53:56]     它是什么
[03:133:42/03:53:56]     它是K8S集群
[03:133:43/03:53:56]     它是集群容器
[03:133:44/03:53:56]     集群的
[03:133:46/03:53:56]     就算不用K8S
[03:133:47/03:53:56]     可能是用的mes
[03:133:48/03:53:56]     也有可能是用docker SW
[03:133:49/03:53:56]     但是它是一个集群
[03:133:52/03:53:56]     它有好多个节点
[03:133:54/03:53:56]     然后它有对应的高可用的设计
[03:133:57/03:53:56]     比如说这里面我们是模块a
[03:134:04/03:53:56]     他是在这儿的
[03:134:06/03:53:56]     启动在a节点
[03:134:08/03:53:56]     那如果
[03:134:11/03:53:56]     假如说如果a节点挂了
[03:134:14/03:53:56]     爆炸了
[03:134:15/03:53:56]     原地爆炸了
[03:134:16/03:53:56]     那你要接下来要做一个什么操作呢
[03:134:19/03:53:56]     你接下来不管是自动的行为
[03:134:22/03:53:56]     还是说运维手动的为它都是什么呢
[03:134:24/03:53:56]     它都是要把a节点的这个a服务迁移到其他的可用节点
[03:134:29/03:53:56]     你要迁移过来
[03:134:31/03:53:56]     如果你用的是K8S的话
[03:134:32/03:53:56]     大部分情况下它能自动帮你迁移
[03:134:34/03:53:56]     因为只要a节点挂了
[03:134:37/03:53:56]     K8S检测到
[03:134:38/03:53:56]     那它就能自动把你的a迁移到B节点来
[03:134:40/03:53:56]     然后在B点上启动起来
[03:134:42/03:53:56]     继续提供服务
[03:134:43/03:53:56]     这是它有它的自动化的运维的能力
[03:134:45/03:53:56]     这也是它的高可用设计之一
[03:134:47/03:53:56]     叫做故障转移
[03:134:48/03:53:56]     一台机器故障了
[03:134:50/03:53:56]     那你需要转移
[03:134:51/03:53:56]     把服务转移到其他机器上
[03:134:53/03:53:56]     继续提供服务
[03:134:54/03:53:56]     对吧
[03:134:56/03:53:56]     这个大家能理解吧
[03:134:57/03:53:56]     就是常见的高可用设计那
[03:135:01/03:53:56]     这里问题就来了
[03:135:02/03:53:56]     你要把a进a服务到节点上面来
[03:135:07/03:53:56]     的前提是你要有这个B节点上有a节点的镜像是吧
[03:135:14/03:53:56]     所以说它第一件事情叫
[03:135:18/03:53:56]     你必须要一下
[03:135:19/03:53:56]     那么现在问题就来了
[03:135:21/03:53:56]     问题就分层
[03:135:25/03:53:56]     没有这种设计
[03:135:28/03:53:56]     没有分层
[03:135:29/03:53:56]     可能你这这里你看到了
[03:135:31/03:53:56]     这里面加起来你就会要
[03:135:32/03:53:56]     你只要下载一个镜像就是3200兆
[03:135:36/03:53:56]     那下来3200兆需要多久
[03:135:39/03:53:56]     其实很长时间的
[03:135:41/03:53:56]     需要很长时间
[03:135:42/03:53:56]     以分钟算
[03:135:45/03:53:56]     分
[03:135:51/03:53:56]     可能有些同学问你有有分层设计
[03:135:53/03:53:56]     你也还是要加3200兆不是的
[03:135:56/03:53:56]     因为这是一个集群
[03:135:57/03:53:56]     如果说这里面已经有一个服务
[03:136:02/03:53:56]     B和a服用的是同一个基础镜像
[03:136:06/03:53:56]     就是从这下面他们是复用的
[03:136:09/03:53:56]     他们用的是同样的基础镜像
[03:136:11/03:53:56]     那么它就基础镜像这这这一层
[03:136:14/03:53:56]     就是说这三个级就不用重复下载了
[03:136:16/03:53:56]     因为在B点已经有了
[03:136:17/03:53:56]     已经有这三层了
[03:136:20/03:53:56]     它只需要下这100兆的这一层即可
[03:136:22/03:53:56]     那原本可能需要十分钟才能启动起来的这个
[03:136:25/03:53:56]     你可能一分钟就启动起来了
[03:136:27/03:53:56]     它能够缩短你的服务的不可用时间
[03:136:30/03:53:56]     你的镜像越小是越好的
[03:136:32/03:53:56]     越小它就能够缩短你的服务的不可用时间
[03:136:38/03:53:56]     大家能明白否
[03:136:39/03:53:56]     因为你你要下载镜像
[03:136:41/03:53:56]     你要下载镜像它是要花很多时间的
[03:136:44/03:53:56]     有很多网络流量的
[03:136:45/03:53:56]     尤其是如果你的
[03:136:48/03:53:56]     如果你的整个节点崩溃了
[03:136:50/03:53:56]     假如你的整个节点崩溃了
[03:136:54/03:53:56]     节点上假如有100个伏
[03:136:56/03:53:56]     这100个伏你全往其他的节点上掉掉
[03:137:00/03:53:56]     届时如果你没有好的镜像分层的话
[03:137:03/03:53:56]     大量的IO会存在
[03:137:05/03:53:56]     大量的网络IO会存在于整个集群里面去
[03:137:08/03:53:56]     因为什么呢
[03:137:09/03:53:56]     100个服务全往这边调
[03:137:11/03:53:56]     那全要开始到科普
[03:137:13/03:53:56]     全要开始拉镜像
[03:137:15/03:53:56]     全部开始拉镜像
[03:137:16/03:53:56]     那么带来的结果是什么呢
[03:137:19/03:53:56]     带来的结果是什么呢
[03:137:21/03:53:56]     在那一瞬间
[03:137:22/03:53:56]     可能你的集群内部有大量的网络IO
[03:137:25/03:53:56]     这个大量的网络可能会把你整个集群给
[03:137:29/03:53:56]     搞垮
[03:137:31/03:53:56]     把整个机群都给搞垮
[03:137:32/03:53:56]     最后我们叫它雪崩效应
[03:137:34/03:53:56]     就是因为由于一台机器
[03:137:38/03:53:56]     引起的
[03:137:40/03:53:56]     由于一台机器引起的
[03:137:45/03:53:56]     就一台机器崩溃
[03:137:46/03:53:56]     引起了整个集群
[03:137:50/03:53:56]     都崩溃的这个情况我们就管它叫雪崩效应
[03:137:54/03:53:56]     我们管它叫雪崩效应
[03:137:56/03:53:56]     这个大家能明白否
[03:137:57/03:53:56]     所以说控制镜像的大小
[03:138:02/03:53:56]     是很重要的
[03:138:04/03:53:56]     是很重要
[03:138:05/03:53:56]     尽量能小就小
[03:138:07/03:53:56]     如果大家看到专业的这个研发人员去做镜像的时候
[03:138:10/03:53:56]     他镜像能小到什么程度
[03:138:12/03:53:56]     就比如说我做我
[03:138:13/03:53:56]     我用浪语言去编写工具的时候
[03:138:15/03:53:56]     我的镜像
[03:138:16/03:53:56]     我的镜像一般控制在100兆以内
[03:138:19/03:53:56]     一般可能50几兆都差不多
[03:138:22/03:53:56]     一般会空在100个兆以内
[03:138:23/03:53:56]     因为什么我机箱里什么都没有
[03:138:26/03:53:56]     我是购物源的交叉编译
[03:138:28/03:53:56]     编译成了一个二进制文件
[03:138:29/03:53:56]     这个二进进制文件是不依赖任何东西就能够跑起来的
[03:138:33/03:53:56]     就不需要像Java那样里装JDK
[03:138:36/03:53:56]     装一不需要
[03:138:38/03:53:56]     因为我编译出交叉编译出来的是一个可执行的二进制文件
[03:138:41/03:53:56]     它不依赖其他的环节
[03:138:44/03:53:56]     那研发也是这样的
[03:138:47/03:53:56]     研发也是这样的
[03:138:50/03:53:56]     极尽的追求镜像的精简化
[03:138:54/03:53:56]     所以说你看有时候有的有的容器里边啥也没有
[03:138:58/03:53:56]     你想用IP命令
[03:139:00/03:53:56]     你或者命令查看一下IP地址什么的
[03:139:03/03:53:56]     因为没这个命令
[03:139:06/03:53:56]     连这个命令都没有
[03:139:07/03:53:56]     这命令都不装
[03:139:10/03:53:56]     我我看我们这边的有的镜像连个shell环境都没有就登录上去
[03:139:15/03:53:56]     你想上面运行一个shell或者是SH的shell不行
[03:139:20/03:53:56]     你登都登不上去
[03:139:21/03:53:56]     这就是为什么要接近保持镜像的精简化
[03:139:25/03:53:56]     经典化
[03:139:27/03:53:56]     以及我们为什么要镜像
[03:139:29/03:53:56]     要分层
[03:139:30/03:53:56]     我们要进行这样的一个设计
[03:139:33/03:53:56]     运行这样的设计
[03:139:34/03:53:56]     一般来说你的镜像都是一个树形结构
[03:139:36/03:53:56]     当然我这是倒过来的数
[03:139:38/03:53:56]     就会有一个根基点
[03:139:39/03:53:56]     根基点你可以理解为它就是根镜像
[03:139:43/03:53:56]     最基础的一个镜像
[03:139:44/03:53:56]     然后上面扩展
[03:139:45/03:53:56]     比如说Java的镜像
[03:139:46/03:53:56]     Pant加va script
[03:139:47/03:53:56]     然后上面再继续扩展
[03:139:49/03:53:56]     根据你的业务需求
[03:139:51/03:53:56]     去扩展
[03:139:52/03:53:56]     那讲到这大家有不明白的吗
[03:140:36/03:53:56]     如果没有什么问题的话
[03:140:38/03:53:56]     那我们讲一点实操上的东西
[03:140:40/03:53:56]     那讲这种理论上的
[03:140:41/03:53:56]     这东西除了告诉大家要去怎么去设计镜像之外
[03:140:45/03:53:56]     那也要大家去有能力去判断研发的景象
[03:140:53/03:53:56]     研发的镜像它有没有
[03:140:56/03:53:56]     设计的比较合理
[03:140:59/03:53:56]     你怎么判断研发镜像设计合不合理呢
[03:141:01/03:53:56]     它有一些命令
[03:141:03/03:53:56]     有一个命令说有一个叫做do system
[03:141:09/03:53:56]     可以看到它的下面有DF有有有
[03:141:16/03:53:56]     那我们用DF看一下
[03:141:26/03:53:56]     那
[03:141:27/03:53:56]     他
[03:141:31/03:53:56]     他能够
[03:141:33/03:53:56]     能够列出当前你的容器和镜像的使用情况
[03:141:40/03:53:56]     大家可以看到image它一共占了多少磁盘空间
[03:141:47/03:53:56]     总量是七
[03:141:48/03:53:56]     这是可回收的
[03:141:50/03:53:56]     可回收有1055G
[03:141:52/03:53:56]     可回收就是没人用的
[03:141:53/03:53:56]     就是说没有容器在用它的
[03:141:55/03:53:56]     当然这个只是给你一个总览
[03:142:00/03:53:56]     只是给你一个总览
[03:142:01/03:53:56]     就是一个概括信息
[03:142:03/03:53:56]     你后面好像要加一个杠V这个参数
[03:142:06/03:53:56]     我记得好像是岗位好长时间没用这个命令了
[03:142:10/03:53:56]     对你用了这个参数
[03:142:11/03:53:56]     它会给你才给你列出详细的信息
[03:142:17/03:53:56]     详细的信息
[03:142:18/03:53:56]     比如说
[03:142:20/03:53:56]     这边就有这个东西
[03:142:30/03:53:56]     我的意思了
[03:142:44/03:53:56]     总空间是相当他共享
[03:142:54/03:53:56]     他们跟其他镜像共享的
[03:142:58/03:53:56]     而是什么呢
[03:143:00/03:53:56]     就是这个镜像独立的
[03:143:01/03:53:56]     就是说这部分空间就是我独自占的
[03:143:03/03:53:56]     我没有跟人共享过
[03:143:04/03:53:56]     就是说没有公共的镜像的一个
[03:143:08/03:53:56]     没有公共的这个这这一层就没有服用的这一层
[03:143:11/03:53:56]     就没有技术镜像
[03:143:12/03:53:56]     没有公用技镜像
[03:143:14/03:53:56]     那么通过这个大家应该能可以想到什么呢
[03:143:16/03:53:56]     想到share size越大
[03:143:24/03:53:56]     就说明什么呢
[03:143:25/03:53:56]     就说明他们是复用的程度就越高
[03:143:29/03:53:56]     复用的程度越高
[03:143:31/03:53:56]     而size越大
[03:143:33/03:53:56]     就证明它用的程度越低
[03:143:37/03:53:56]     大明白如果用那个size特别高
[03:143:41/03:53:56]     说明它没有利用到很好的基础镜像的这个这个设计
[03:143:46/03:53:56]     所以说你看就像这个不对
[03:143:49/03:53:56]     这个也也挺小的
[03:143:50/03:53:56]     我看有没有在这里面有没有特别大的
[03:143:52/03:53:56]     这个是你看这个这个G2的这个就是900兆
[03:143:56/03:53:56]     它就比较大
[03:143:58/03:53:56]     他用那个S有900兆
[03:144:01/03:53:56]     看还有没有
[03:144:03/03:53:56]     好像不太有
[03:144:04/03:53:56]     这有个700多兆的
[03:144:05/03:53:56]     700多兆的open g k8700多兆的
[03:144:09/03:53:56]     它本身就是基础影响呢
[03:144:11/03:53:56]     所以它它无所谓
[03:144:13/03:53:56]     所以说我们可以去分析研发的镜像
[03:144:19/03:53:56]     如果说它的这个UNI size太太大了
[03:144:22/03:53:56]     一般你可以就以UN size来为例
[03:144:25/03:53:56]     你去扫描一下你编写脚本
[03:144:27/03:53:56]     去扫描研发你的产品模块里的镜像
[03:144:30/03:53:56]     如果它的UN size太高了
[03:144:35/03:53:56]     赛太大了
[03:144:36/03:53:56]     就证明它的镜像的复用性不是很好
[03:144:39/03:53:56]     它有可能会出现什么情况呢
[03:144:41/03:53:56]     有可能出现它没有公共没有使用那些规定的那些基础定向
[03:144:47/03:53:56]     那这样就会导致什么呢
[03:144:49/03:53:56]     跟我们刚才说
[03:144:50/03:53:56]     我们刚才说了一系列的问题
[03:144:52/03:53:56]     磁盘空间占用太高了
[03:144:55/03:53:56]     以及它的这个服务的这个启动时间可能会很长
[03:145:00/03:53:56]     这是我们可以通过它去进行分析的
[03:145:03/03:53:56]     通过这个命令去进行分析的
[03:145:06/03:53:56]     这个大家能明白否
[03:145:13/03:53:56]     OK
[03:145:14/03:53:56]     都没有什么反馈
[03:145:15/03:53:56]     如果你们说没问题
[03:145:17/03:53:56]     那没问题吧
[03:145:18/03:53:56]     好
[03:145:22/03:53:56]     那通过这样的一个命令
[03:145:24/03:53:56]     我们可以知道这些事情
[03:145:25/03:53:56]     当然这是镜像的
[03:145:26/03:53:56]     下边还有容器的
[03:145:29/03:53:56]     容器一般用的会比较少而已
[03:145:31/03:53:56]     容器用的会比较少而已
[03:145:35/03:53:56]     好
[03:145:37/03:53:56]     那如果到这儿大家都没有什么问题的话
[03:145:41/03:53:56]     那我们这个今天的课程内容可能就要就讲完了
[03:145:46/03:53:56]     剩下的几分钟呢
[03:145:48/03:53:56]     就是留给大家一个答疑的一个时间
[03:145:50/03:53:56]     大家如果针对于docker或者说这个
[03:145:58/03:53:56]     针对于或者其他内容
[03:145:59/03:53:56]     都有问题都想问我的话
[03:146:01/03:53:56]     可以现在可以问
[03:146:02/03:53:56]     我都可以给大家解答
[03:146:03/03:53:56]     好吧
[03:146:04/03:53:56]     大家都在讨论区里留言可以
[03:146:40/03:53:56]     对测试来说
[03:146:41/03:53:56]     Docker的使用场景是什么有
[03:146:50/03:53:56]     怎么说呢
[03:146:51/03:53:56]     有两种场景
[03:146:52/03:53:56]     第一种是什么呢
[03:146:54/03:53:56]     第一种可能是对于大部分人员可能会遇到场景是你的产品当中使用到了
[03:147:00/03:53:56]     就是你的产品
[03:147:01/03:53:56]     就是ER和K8S就是你产品的一部分
[03:147:08/03:53:56]     就是说你的产品是部署在docker和KL上的
[03:147:12/03:53:56]     那么你的好多的因为
[03:147:15/03:53:56]     甚至有一些产品就是K
[03:147:17/03:53:56]     或者会成他们的一部分调度
[03:147:22/03:53:56]     他们的调度就是通过刀客来调度
[03:147:24/03:53:56]     通过KS来调度的
[03:147:26/03:53:56]     那就要求你什么呢
[03:147:27/03:53:56]     要求测试人员有两部分的能力
[03:147:30/03:53:56]     第一部分能力就是说它要有能跟打交道的
[03:147:34/03:53:56]     能力啊
[03:147:35/03:53:56]     比如说你要看日志
[03:147:37/03:53:56]     比如说你要分析一些问题
[03:147:41/03:53:56]     比如说K8S的调度不起来了
[03:147:42/03:53:56]     你要分析一下它为什么调不起来了
[03:147:45/03:53:56]     第二种是什么呢
[03:147:46/03:53:56]     第二种是第二种就是说你需要利用ER和K8S的能力去构建你自己的一些自动化的测试也好
[03:147:55/03:53:56]     测试工具也好
[03:147:57/03:53:56]     就像我上节课讲的这个故障注入一样
[03:148:00/03:53:56]     在doer里边进行故障注入和赛集里面是不一样的
[03:148:07/03:53:56]     你你你你你还在问
[03:148:08/03:53:56]     就是说你会问一些
[03:148:09/03:53:56]     就是你你问了这个一些自动化的东西
[03:148:13/03:53:56]     在刀客中运行跟脚本直接运行
[03:148:15/03:53:56]     感觉好像没有什么不同
[03:148:16/03:53:56]     就是说理论上区别确实不大
[03:148:19/03:53:56]     区别率确实不大
[03:148:20/03:53:56]     不是很大
[03:148:21/03:53:56]     你说不是很大
[03:148:22/03:53:56]     但是如果
[03:148:24/03:53:56]     你放到产品里面
[03:148:26/03:53:56]     比如说你的产品就是在dota里面跑的
[03:148:30/03:53:56]     然后它有一些就比如说在K里跑的
[03:148:33/03:53:56]     然后它有一些限制
[03:148:35/03:53:56]     你只能在集群内部访问他
[03:148:37/03:53:56]     比如说你到接口测试的时候
[03:148:39/03:53:56]     它可能没有暴露在你的测试网络环境里
[03:148:41/03:53:56]     你只能把你的程序放到KS里面去访问它
[03:148:47/03:53:56]     又或者说
[03:148:48/03:53:56]     又或者说你你你的这个自动化搞得比较大了已经
[03:148:52/03:53:56]     比如说不管是你的UI自动化
[03:148:55/03:53:56]     UI自动化的话
[03:148:56/03:53:56]     你要需要一个浏览器集群
[03:148:58/03:53:56]     那你浏览机群
[03:148:59/03:53:56]     你如果是部署在开发S里面
[03:149:01/03:53:56]     可能一个命令就完事了
[03:149:03/03:53:56]     但是如果说你要部署在虚拟机里面
[03:149:05/03:53:56]     那你你就麻烦了
[03:149:06/03:53:56]     你就要一个一个虚拟机上面去安装GDK
[03:149:09/03:53:56]     然后安装安装你的那个grade的node
[03:149:13/03:53:56]     然后再启动起来
[03:149:14/03:53:56]     如果挂了的话
[03:149:15/03:53:56]     你还要手动上去把它拉起来
[03:149:16/03:53:56]     那如果你是放在KS里面维护这个KS维护这个浏览器的话
[03:149:22/03:53:56]     那就会方便很多
[03:149:24/03:53:56]     这是我们说第一个维度的东西
[03:149:26/03:53:56]     第一个维度就是第一个维度就是说对于大部分测试员要面对的
[03:149:31/03:53:56]     就是产品是使用K8S部署的
[03:149:34/03:53:56]     你需要了解KS和docker的特性
[03:149:37/03:53:56]     才能去看日志
[03:149:39/03:53:56]     才能去分析一些问题
[03:149:41/03:53:56]     然后就是你需要利用KS和docker的一些特性呢
[03:149:44/03:53:56]     去优化一下你的测试工具
[03:149:47/03:53:56]     第二个维度是什么
[03:149:48/03:53:56]     第二维度就是说
[03:149:50/03:53:56]     你测试的本身就是和K
[03:149:52/03:53:56]     因为现在有很多云商
[03:149:55/03:53:56]     很多云厂商
[03:149:57/03:53:56]     比如说阿里云、腾讯云、华为云、百度云
[03:150:01/03:53:56]     现在还有个字节云
[03:150:04/03:53:56]     这些云业务里面
[03:150:08/03:53:56]     这些业务里面
[03:150:09/03:53:56]     Docker和KYS就是它的产品
[03:150:14/03:53:56]     你要测的就是那个东西
[03:150:15/03:53:56]     你像我现在所在的这个团队里面
[03:150:18/03:53:56]     我们使用的是公司内部研发的一个K的商业化产品
[03:150:25/03:53:56]     理论上就是说你在测K8S
[03:150:27/03:53:56]     那你要是不懂和K8S
[03:150:30/03:53:56]     你怎么测它呢
[03:150:31/03:53:56]     这是第二个维度
[03:150:33/03:53:56]     如果你要去定点的
[03:150:35/03:53:56]     去一些大厂的云厂商里面
[03:150:37/03:53:56]     就是大厂就是阿里
[03:150:38/03:53:56]     阿里什么自己这些公司里面
[03:150:41/03:53:56]     那其实我是比较推荐的
[03:150:43/03:53:56]     就这种向我是比较推荐
[03:150:45/03:53:56]     如果因为什么呢
[03:150:47/03:53:56]     就是假如说你苦恼于不知道怎么进大厂一个比较好一点的职位岗位里面
[03:150:52/03:53:56]     其实通过这种能力去进入会比较好进
[03:150:56/03:53:56]     这种专项能力
[03:150:58/03:53:56]     因为在测试领域里面懂懂KS的不多
[03:151:03/03:53:56]     懂KS不多
[03:151:04/03:53:56]     如果说懂号KS不多
[03:151:06/03:53:56]     如果说你这方面的比较好
[03:151:07/03:53:56]     你就通过能通过这个东西就为翘板
[03:151:11/03:53:56]     你能翘进大厂里面去
[03:151:15/03:53:56]     然后还有个同学说
[03:151:17/03:53:56]     感觉这套课程内容很多
[03:151:20/03:53:56]     一时半会消耗不了
[03:151:21/03:53:56]     针对目前如果想在短期内发挥课程的价值
[03:151:26/03:53:56]     在换工作的时候能长点薪资
[03:151:29/03:53:56]     老师有没有一些建议
[03:151:30/03:53:56]     建议是什么
[03:151:31/03:53:56]     就尽量往你自己的工作上靠
[03:151:32/03:53:56]     你学就是咱们这套课程内容确实很多
[03:151:37/03:53:56]     因其实讲道理
[03:151:38/03:53:56]     讲道理我们都是什么呢
[03:151:39/03:53:56]     我们都是工作了很多年了
[03:151:41/03:53:56]     以前我工作12年了
[03:151:42/03:53:56]     已经我已经工作12年了
[03:151:43/03:53:56]     我们工作很多年
[03:151:45/03:53:56]     我们是要把我们很多年的工作内容总结起来
[03:151:48/03:53:56]     精炼起来
[03:151:49/03:53:56]     然后一股脑的教给你们
[03:151:50/03:53:56]     所以说你会感觉东西特别多
[03:151:53/03:53:56]     就这我们还没教完呢
[03:151:54/03:53:56]     我们只是把我们觉得一些重要的和一些比较好理解的
[03:151:58/03:53:56]     就特别深入的内容
[03:151:59/03:53:56]     我都没给你
[03:152:00/03:53:56]     都没跟你讲
[03:152:01/03:53:56]     我觉得你们能理解的了的一些东西交给你们
[03:152:06/03:53:56]     肯定你们不是说都能理解的
[03:152:08/03:53:56]     因为我们是花十几年才能够学到
[03:152:11/03:53:56]     就是才能够学到现在这个程度的
[03:152:13/03:53:56]     你们想通过一门课程就想达到我跟我一样的水平
[03:152:17/03:53:56]     那是绝对不可能的
[03:152:19/03:53:56]     你们也有时候肯定也会这个比较迷茫
[03:152:22/03:53:56]     感觉一下子接受这么多知识
[03:152:23/03:53:56]     也不知道什么地方能用得了
[03:152:24/03:53:56]     什么不能用
[03:152:25/03:53:56]     这都很正常
[03:152:27/03:53:56]     关键是什么呢
[03:152:28/03:53:56]     关键是学了一套于
[03:152:37/03:53:56]     或者说你虽然用不到
[03:152:39/03:53:56]     但是你能往你现在的这个工作上能贴的东西
[03:152:46/03:53:56]     比如说就我说讲的课程里面
[03:152:47/03:53:56]     你假如说你就可以跟面试官说
[03:152:51/03:53:56]     你们的环境是用cker维护的
[03:152:53/03:53:56]     然后你是用docker部署测试环境的
[03:152:57/03:53:56]     你自己也写过doer file
[03:152:58/03:53:56]     然后你也可以说你你你你你比如说你是做UI自动化的
[03:153:03/03:53:56]     你可以说你你的浏览器群是浏览器是用这个这个sli部署在KS里的
[03:153:12/03:53:56]     你都可以往上靠对吧
[03:153:14/03:53:56]     你都可以往上靠
[03:153:15/03:53:56]     就是说你需要什么呢
[03:153:18/03:53:56]     你需要自己思考一下
[03:153:20/03:53:56]     你学到的这些东西有哪些是可以跟你的工作沾边的
[03:153:25/03:53:56]     这个东西你需要思考的
[03:153:29/03:53:56]     那短期内如果先把自动化或者某一个
[03:153:33/03:53:56]     米尔
[03:153:35/03:53:56]     先深究下会不会好
[03:153:37/03:53:56]     会不会好一点
[03:153:40/03:53:56]     有一个前提
[03:153:43/03:53:56]     就是你很清楚你要往哪个方向发展
[03:153:47/03:53:56]     这是前提
[03:153:48/03:53:56]     如果你现在比较迷茫呢
[03:153:52/03:53:56]     就是说你不知道自己未来想做什么事情
[03:153:55/03:53:56]     那其实你先先研究一个面
[03:153:57/03:53:56]     先深究一下会不会好一点就会很好
[03:154:01/03:53:56]     因为你还不知道你自己想干啥
[03:154:06/03:53:56]     所以说前提
[03:154:08/03:53:56]     前提是你已经明确了
[03:154:10/03:53:56]     你未来就要做一个
[03:154:11/03:53:56]     就做做这样的一个事情
[03:154:13/03:53:56]     你比如说我吧
[03:154:14/03:53:56]     老师
[03:154:15/03:53:56]     我现在给自己的职业定位
[03:154:18/03:53:56]     特别明确
[03:154:19/03:53:56]     我就是往容器化方向发展的
[03:154:22/03:53:56]     特别明确
[03:154:25/03:53:56]     对吧
[03:154:27/03:53:56]     好
[03:154:28/03:53:56]     还有什么其他问题吗
[03:154:57/03:53:56]     你应该比我小不了多少
[03:155:00/03:53:56]     我今年35
[03:155:01/03:53:56]     我正好35岁
[03:155:02/03:53:56]     八七年的
[03:155:08/03:53:56]     正好踏入到了事业的高危线上
[03:155:14/03:53:56]     但我还好
[03:155:15/03:53:56]     我还不会担心失业
[03:155:19/03:53:56]     因为我现在我我现在找工作还还算比较简单
[03:155:23/03:53:56]     就是我的年龄还没大到那种
[03:155:26/03:53:56]     会让我感到紧张的程度
[03:155:27/03:53:56]     可能40岁以后
[03:155:28/03:53:56]     40岁以后之后我可能会感觉感觉到压力
[03:155:33/03:53:56]     但是四岁之前的时候
[03:155:34/03:53:56]     以我现在的技术水平
[03:155:35/03:53:56]     应该应该不会有问题
[03:155:38/03:53:56]     应该不会有问题
[03:155:40/03:53:56]     因为我现在我去年面试的时候
[03:155:42/03:53:56]     我去年面试的时候
[03:155:44/03:53:56]     基本上各个大厂都面了
[03:155:46/03:53:56]     基本上拿的offer都是都是批八这个级别
[03:155:52/03:53:56]     都是P8这个级别的
[03:155:53/03:53:56]     那批八这个级别在40岁之前的时候都应该还OK的
[03:155:57/03:53:56]     那40岁以后的时候
[03:155:58/03:53:56]     那肯定会感受到压力
[03:155:59/03:53:56]     但40岁之前应该都还好
[03:156:02/03:53:56]     那行里是这样的
[03:156:03/03:53:56]     30岁以上的P6
[03:156:05/03:53:56]     35岁以上的P7都不好找
[03:156:10/03:53:56]     我之前我前两天推荐了一个人去给蚂蚁金服推一个人
[03:156:15/03:53:56]     推一个人
[03:156:16/03:53:56]     再然后对面
[03:156:18/03:53:56]     他很直白嘛
[03:156:19/03:53:56]     就我们俩很熟
[03:156:20/03:53:56]     就问我这这人多大岁数了
[03:156:24/03:53:56]     我说33岁差不多P6这个水平
[03:156:26/03:53:56]     他说那不聊了
[03:156:27/03:53:56]     30岁以上的P6就不不太聊了
[03:156:29/03:53:56]     就
[03:156:30/03:53:56]     然后如果你是30岁以上的
[03:156:32/03:53:56]     如果他是P7的水平
[03:156:35/03:53:56]     如果你35岁了
[03:156:37/03:53:56]     35岁以上了
[03:156:38/03:53:56]     如果你还是P7
[03:156:39/03:53:56]     那也不好聊
[03:156:41/03:53:56]     你得是P8才好聊
[03:156:43/03:53:56]     以此类推
[03:156:44/03:53:56]     你要40以上的话
[03:156:45/03:53:56]     批八也不好了
[03:156:48/03:53:56]     随着年龄的增长
[03:156:49/03:53:56]     那你的水平你也往上涨
[03:156:51/03:53:56]     要不然的话
[03:156:52/03:53:56]     在国内你是很难
[03:156:53/03:53:56]     你是很难的
[03:156:54/03:53:56]     除非你去外企
[03:156:55/03:53:56]     外企没有这个限制
[03:156:57/03:53:56]     你像我之前有一个下属
[03:157:00/03:53:56]     他都43岁了
[03:157:01/03:53:56]     去年换的工作
[03:157:02/03:53:56]     我们俩一块换的工作
[03:157:04/03:53:56]     他是43岁了
[03:157:06/03:53:56]     去年是43
[03:157:07/03:53:56]     今年44了
[03:157:08/03:53:56]     他去
[03:157:09/03:53:56]     结果他去了一家外企
[03:157:10/03:53:56]     那外企也不在乎这个年龄
[03:157:12/03:53:56]     不在乎这个年龄
[03:157:16/03:53:56]     这个外企的理念是什么呢
[03:157:18/03:53:56]     外企理念就是我这个岗位就值这些钱
[03:157:22/03:53:56]     就值这些钱我不管
[03:157:24/03:53:56]     就是只要你岁数别太大就行了
[03:157:26/03:53:56]     你就像四十来岁也没问题
[03:157:27/03:53:56]     反正我你这个你这个你这个能力到了
[03:157:31/03:53:56]     那我就不太会考虑你的年龄问题
[03:157:35/03:53:56]     那国内不是国内企业就是
[03:157:37/03:53:56]     我就是考虑你能不能加班的问题吧
[03:157:40/03:53:56]     就是你能不能加动班了
[03:157:41/03:53:56]     你还好不好管理了
[03:157:42/03:53:56]     就是这些事情
[03:157:43/03:53:56]     所以说他不愿意要岁数大的
[03:157:45/03:53:56]     很现实
[03:157:46/03:53:56]     国内的企业都很现实
[03:157:48/03:53:56]     所以说各位如果岁数大了以后
[03:157:52/03:53:56]     可以考虑考虑去外企练英语
[03:157:53/03:53:56]     考虑考虑去外企
[03:157:55/03:53:56]     然后有同学问IPC boss5链
[03:160:09/03:53:56]     刚才电脑没电了
[03:160:10/03:53:56]     不好意思
[03:160:11/03:53:56]     没注意
[03:160:12/03:53:56]     我们接着来吧
[03:160:16/03:53:56]     我们继续回答
[03:160:19/03:53:56]     刚才Y同学说IP tables5链各个链的柱故障柱一般都分别会有哪些车市场景
[03:160:29/03:53:56]     其实就是一般来说就是我上午就是不是我上午在就是下午给大家讲
[03:160:34/03:53:56]     就是往出口和入口两个口这块注入故障
[03:160:39/03:53:56]     那剩下的就都差不多都差不多
[03:160:42/03:53:56]     如果你往入口注入故障的话
[03:160:44/03:53:56]     那这个
[03:160:46/03:53:56]     那么这个你的这个进程就处理不到这个请求了
[03:160:49/03:53:56]     就会直接保证会丢掉
[03:160:51/03:53:56]     如果你往出口故障的话
[03:160:53/03:53:56]     那其实就是说你的进程已经处理的这个请求了
[03:160:57/03:53:56]     只是返回给客户端的时候会出
[03:161:00/03:53:56]     就是就会那什么会那个包就会丢掉了
[03:161:05/03:53:56]     返回不回去而已
[03:161:06/03:53:56]     其实就这两种故障
[03:161:07/03:53:56]     就这两种场景一般来说
[03:161:09/03:53:56]     更多的你可能就不是用IP table时候去去注入故障了
[03:161:15/03:53:56]     比如说你用的是TC命令
[03:161:16/03:53:56]     TC命令是什么呢
[03:161:18/03:53:56]     是我记得好像是traffic control traffic control它能控制网
[03:161:22/03:53:56]     也是控制网络流量的
[03:161:23/03:53:56]     就是它跟IP tables的IP tables一样
[03:161:27/03:53:56]     都是能控制网络
[03:161:28/03:53:56]     只不过它是用另外一种形式控制
[03:161:31/03:53:56]     然TC能控制的比较多
[03:161:32/03:53:56]     比如说你可以用一个命令
[03:161:36/03:53:56]     一些命令去那个用TC的命令去限制带宽
[03:161:40/03:53:56]     比如说你把假设你带宽是一个G的
[03:161:42/03:53:56]     你可以把带宽限制成只有200个兆
[03:161:45/03:53:56]     像我们之前测边缘计算的时候
[03:161:48/03:53:56]     测边缘计算的时候要模拟一个在第一关下
[03:161:51/03:53:56]     第关下
[03:161:52/03:53:56]     你的这个任务息是还还会不会稳定
[03:161:55/03:53:56]     所以说就要这种故障模拟一个
[03:161:58/03:53:56]     比如说200兆光的一个网络环境
[03:162:00/03:53:56]     看一看它是不是能够
[03:162:02/03:53:56]     还有你的功能是不是能够稳定
[03:162:08/03:53:56]     然后对
[03:162:10/03:53:56]     所以说你可以刚才那个Y同学你可以去看一下IPC boss命令和TC命令的一些文档
[03:162:16/03:53:56]     这样的话你就知道就是他们两个都能做些什么事了
[03:162:21/03:53:56]     然后手机尾号同学说行业上有一些注入故障的工具
[03:162:26/03:53:56]     比如说开slide
[03:162:28/03:53:56]     是阿里云的工具
[03:162:30/03:53:56]     是
[03:162:31/03:53:56]     那然后怎么了
[03:162:36/03:53:56]     怎么了
[03:162:38/03:53:56]     你好像问的不是问题
[03:162:40/03:53:56]     不不不不
[03:162:41/03:53:56]     你好像说的不是一个问题
[03:162:58/03:53:56]     就出了胜负
[03:163:04/03:53:56]     背景
[03:163:07/03:53:56]     讲实际来讲哪个用的更广泛一点
[03:163:12/03:53:56]     这个分场景
[03:163:14/03:53:56]     如果你不涉及到一些就果就是说你没有涉及到
[03:163:21/03:53:56]     就是如果你没有涉及到容器领域的一些故障注入的话
[03:163:25/03:53:56]     其实carespla的它会更好用一些
[03:163:30/03:53:56]     Carespla的会更好用一些
[03:163:33/03:53:56]     但是如果你涉及到了在K8S当中
[03:163:37/03:53:56]     在K8S当中去注入故障的话
[03:163:40/03:53:56]     那可能K麦是会更好一些
[03:163:43/03:53:56]     K麦是更好一些
[03:163:44/03:53:56]     然后你你要是要跟这个IP tables和TC比的话
[03:163:49/03:53:56]     就他们不是一个维度东西
[03:163:50/03:53:56]     就s play的底层是调IP table符合TC命令的
[03:163:54/03:53:56]     就是如果你没有什么任何的环境限制
[03:163:58/03:53:56]     你可能textpla可能是更好的
[03:164:00/03:53:56]     因为它底层也利用的也是IPS和TC命令
[03:164:04/03:53:56]     但是它分装了很多比较更好用的功能
[03:164:07/03:53:56]     它会比你这个直接用IPS命令会更方便
[03:164:12/03:53:56]     你你需要懂IP tables和TC呢
[03:164:15/03:53:56]     其实一个是因为他们
[03:164:16/03:53:56]     你懂了它之后
[03:164:17/03:53:56]     其实IP tables对于doer来说是非常重要的
[03:164:20/03:53:56]     Doer的网络转发都是通过的
[03:164:23/03:53:56]     这是一个
[03:164:24/03:53:56]     再一个是什么
[03:164:25/03:53:56]     就是有些时候环境有限制
[03:164:28/03:53:56]     你用不了cspla或者S的时候
[03:164:31/03:53:56]     那你就得用原生的IPS命令
[03:164:34/03:53:56]     就比如说你的进入到那个环境权限有限制权限
[03:164:40/03:53:56]     或者是网络有限制
[03:164:42/03:53:56]     让你没有办法去安装cosplay的
[03:164:45/03:53:56]     那怎么办
[03:164:46/03:53:56]     你只能用原生的IPC bos命令和TC命令去去去那什么了
[03:164:50/03:53:56]     去去去去去注入故障了
[03:164:52/03:53:56]     你就比如说我
[03:164:54/03:53:56]     我前些日子遇到了边缘计算的那个场景
[03:164:57/03:53:56]     边缘计算节点有权限限制
[03:164:59/03:53:56]     你装不了
[03:165:00/03:53:56]     就没有权限让你运行kspla的
[03:165:03/03:53:56]     你只能到
[03:165:04/03:53:56]     你只能按我今天和和之前上节课教给你的方式切换名称空间
[03:165:10/03:53:56]     用NSN命令切换名称空间
[03:165:13/03:53:56]     然后再用ipts和TC命令出入故障
[03:165:17/03:53:56]     太空
[03:165:20/03:53:56]     所以说
[03:165:21/03:53:56]     所以说这个其实没有没没有限制的时候
[03:165:24/03:53:56]     你就消消停停的用PLA就行了
[03:165:28/03:53:56]     如果你判断有限制的情况下
[03:165:30/03:53:56]     那你必须用PTS和TC出入故障
[03:165:33/03:53:56]     所以说我跟你说嘛
[03:165:34/03:53:56]     理解原理是很重要
[03:165:35/03:53:56]     理解原理是很重要的
[03:165:39/03:53:56]     还有什么其他问题吗
[03:165:45/03:53:56]     人生考试
[03:166:05/03:53:56]     如果大家没有什么问题的话
[03:166:07/03:53:56]     可能我们今天课程就真要到这了
[03:166:11/03:53:56]     大家还有什么其他问题吗
[03:166:13/03:53:56]     相当
[03:166:16/03:53:56]     好
[03:166:18/03:53:56]     发现同学们如果后期要深入刀ER领域
[03:166:22/03:53:56]     把当前课程消化吸收后
[03:166:24/03:53:56]     对于后期的学习径
[03:166:25/03:53:56]     老师可以结合你的咨询经历给些建议吗
[03:166:27/03:53:56]     首先这docker就是docker本身需要学的东西没有那么多吧
[03:166:33/03:53:56]     后面要学的是K8S
[03:166:37/03:53:56]     因为现在商业软件里不会用裸刀ER的
[03:166:40/03:53:56]     都是用容器集群的
[03:166:42/03:53:56]     一般都用K8S
[03:166:43/03:53:56]     所以说你要去学K8S
[03:166:45/03:53:56]     你要去学K8S
[03:166:47/03:53:56]     然后想办法呢
[03:166:48/03:53:56]     去跳到一个使用doer和K8S的团队里面去
[03:166:55/03:53:56]     你要想办法跳过去
[03:166:56/03:53:56]     因为你有真正的使用场景
[03:166:58/03:53:56]     你光因为你光自己练习是有一定的线局限性的
[03:167:02/03:53:56]     就是有很多说说兵嘛
[03:167:04/03:53:56]     就是说兵不是练出来的
[03:167:06/03:53:56]     兵是打出来的
[03:167:08/03:53:56]     打仗打出来的
[03:167:11/03:53:56]     对于你学技术也是一样的
[03:167:12/03:53:56]     你自学是可以的
[03:167:13/03:53:56]     但是你自学毕竟是有一定的局限性
[03:167:15/03:53:56]     你没有真实场景
[03:167:17/03:53:56]     你没有遇不到真实场景的那种复杂度
[03:167:19/03:53:56]     所以说你一定是有局限性的
[03:167:22/03:53:56]     一定个均缘线还不小
[03:167:23/03:53:56]     所以说你在学习完K8S之后
[03:167:27/03:53:56]     一定要想办法去跳到一个去使会用到这两个
[03:167:31/03:53:56]     就到和K8S的团队里面去去锻炼去
[03:167:34/03:53:56]     然后呢
[03:167:35/03:53:56]     你在之后你专门的去一些云工云做云的那些那些公司里面去
[03:167:45/03:53:56]     比如说如果是外企的话
[03:167:47/03:53:56]     比如说像是亚马逊
[03:167:50/03:53:56]     比如说这个外
[03:167:53/03:53:56]     如果是国内的企业的话
[03:167:55/03:53:56]     BATBAT都有自己的云业务
[03:167:57/03:53:56]     华为也有
[03:167:58/03:53:56]     你就这样的公司
[03:168:01/03:53:56]     这样的话你的工资就能提上去了
[03:168:02/03:53:56]     因为据我所知
[03:168:04/03:53:56]     专门测这个云领域的这个产品的QA人员
[03:168:08/03:53:56]     如果稍微稍微资深一点的
[03:168:11/03:53:56]     他的工资都是比较高的
[03:168:13/03:53:56]     都是比较高的
[03:168:15/03:53:56]     因为他们测试的门槛很高
[03:168:18/03:53:56]     就你你就这么想
[03:168:19/03:53:56]     你们就这么想
[03:168:20/03:53:56]     就是说如果你是测APP的手机APP就是给普通用户用的
[03:168:24/03:53:56]     谁都能操作的
[03:168:25/03:53:56]     你的工资必然是高不了
[03:168:27/03:53:56]     因为你的门槛低
[03:168:29/03:53:56]     就门槛越高的地方工资越高
[03:168:31/03:53:56]     因为你的竞争对手少
[03:168:35/03:53:56]     所以说你后期要往刀客领域里去深入的话
[03:168:37/03:53:56]     学刀客
[03:168:38/03:53:56]     然后赶紧跳到一个能用到这两个的地方
[03:168:41/03:53:56]     最终的目标一定是去哪呢
[03:168:43/03:53:56]     一定是去专门的云业务去
[03:168:46/03:53:56]     那个地方是最能发挥你价值的地方
[03:168:49/03:53:56]     好吧
[03:168:58/03:53:56]     还有其他问题吗
[03:169:00/03:53:56]     你的
[03:169:04/03:53:56]     你能变成一条的鱼
[03:169:08/03:53:56]     历于什么都行
[03:169:10/03:53:56]     我所有的
[03:169:21/03:53:56]     咱们这门课有K8S吗
[03:169:27/03:53:56]     这我不太清楚
[03:169:31/03:53:56]     咱们学院确实有KS的课程
[03:169:33/03:53:56]     而且也是我来上的
[03:169:34/03:53:56]     但我不知道你们这一系列的里面有没有
[03:169:38/03:53:56]     这我不清楚
[03:169:39/03:53:56]     你们得问一下朱院老师
[03:169:40/03:53:56]     你们有吗
[03:169:42/03:53:56]     我不太清楚
[03:169:44/03:53:56]     因为因为我对学院是了解的不多
[03:169:47/03:53:56]     学院好像分了好多种课程
[03:169:49/03:53:56]     好多系列的课程
[03:169:50/03:53:56]     有些系列里边就是课程的就是课
[03:169:53/03:53:56]     系列里面课程就会有一些微小的差别
[03:170:00/03:53:56]     所以说我不知道你们这有没有KS
[03:170:02/03:53:56]     如果有的话
[03:170:03/03:53:56]     周瑶老师会提前通知我
[03:170:05/03:53:56]     然后我会给你们上
[03:170:09/03:53:56]     就直播也会有
[03:170:12/03:53:56]     就是说如果真有KS课程的话
[03:170:14/03:53:56]     直播也会有
[03:170:15/03:53:56]     我也是由我来上这门课的
[03:170:18/03:53:56]     只是我不知道你们有没有
[03:170:20/03:53:56]     我不知道
[03:170:21/03:53:56]     因为好好像是因为KS的难度比较高
[03:170:24/03:53:56]     就K和cker就不是一个量级的东西
[03:170:27/03:53:56]     这这说实话
[03:170:28/03:53:56]     K确实很难
[03:170:30/03:53:56]     所以说一般可能是都是一些高级班里才有
[03:170:36/03:53:56]     因为可能基础不是特别好的同学
[03:170:39/03:53:56]     他他我讲KS他可能就听不懂
[03:170:41/03:53:56]     他根本就听不懂
[03:170:47/03:53:56]     所以说你们可以联系联系助教老师问一问你们这系列的课程里有没有
[03:170:53/03:53:56]     如果没有也没有关系
[03:170:54/03:53:56]     因为我记得是那什么
[03:170:55/03:53:56]     我记得是就算是那什么的
[03:170:58/03:53:56]     我也我我就是说我也录过KS的那个录播课的
[03:171:01/03:53:56]     就算是没有直播课的话
[03:171:03/03:53:56]     有一些课程里就是有一些班是没有直播的
[03:171:08/03:53:56]     KS课的话
[03:171:09/03:53:56]     但是录播应该也是会提供给你们的
[03:171:11/03:53:56]     当然录播基内容就很基础嘛
[03:171:14/03:53:56]     录播的内容就很基础
[03:171:15/03:53:56]     它不会像直播课里面
[03:171:17/03:53:56]     直播课里面会讲很多更深的东西
[03:171:28/03:53:56]     朱耀老师
[03:171:29/03:53:56]     朱老师跟我说了说下周是K8S
[03:171:32/03:53:56]     那你们下周是K8S
[03:171:33/03:53:56]     那下周还是我给你们讲
[03:171:35/03:53:56]     说刚才说说老师私信我了
[03:171:38/03:53:56]     私信我了
[03:171:39/03:53:56]     那就下周我给你们讲KS
[03:171:43/03:53:56]     晚上
[03:171:44/03:53:56]     我下定决心
[03:171:50/03:53:56]     好吧
[03:171:58/03:53:56]     还有什么其他问题吗
[03:172:12/03:53:56]     如果没什么其他问题的话
[03:172:15/03:53:56]     我们今天的课程就到这了
[03:172:16/03:53:56]     那我们可能就要下周见
[03:172:19/03:53:56]     这周大家回去呢
[03:172:20/03:53:56]     好好复习一下docker的内容
[03:172:21/03:53:56]     毕竟docker是K8S的基础
[03:172:25/03:53:56]     你号要是还没整明白呢
[03:172:26/03:53:56]     KS你就彻底蒙圈了
[03:172:28/03:53:56]     好吧行吧
[03:172:32/03:53:56]     那我们今天课程到这吧
[03:172:34/03:53:56]     已经给大家耽误大家半个小时时间了
[03:172:36/03:53:56]     已经那我点直接点结束了
[03:172:40/03:53:56]     大家拜拜
[03:172:41/03:53:56]     下周见
