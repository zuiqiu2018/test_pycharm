#  web自动化 视频文本录制



## 23. web自动化测试I



### 1、Web 自动化测试价值与体系
[00:03/15:26]     [以下字幕均由机器生成]各位同学大家好
[00:04/15:26]     [以下字幕均由机器生成]这一个章节呢
[00:05/15:26]     [以下字幕均由机器生成]是我们web自动化测试的第一个章节
[00:09/15:26]     那在第一个章节呢
[00:10/15:26]     我们不会涉及到具体技术的一个讲解
[00:12/15:26]     我更多的希望大家在第一个章节能够收获到web自动化测试是什么web的
[00:18/15:26]     为什么我们要做外部自动化测试
[00:20/15:26]     以及外部自动化测试应该在什么时候启动
[00:23/15:26]     还有最后就是web自动化测试应该如何去学习好
[00:29/15:26]     那这个是我们本节课的一个课程目标
[00:32/15:26]     首先我们先来看一下
**[00:33/15:26]     外部自动化测试它的一个价值体现在哪些方面**
[00:38/15:26]     也就是说我们为什么要做外部自动化测试
[00:42/15:26]     首先我们先来看一下
[00:43/15:26]     这个是一个功能测试的这样的一个场景

![image-20221211211113627](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211211113627.png)[00:45/15:26]     那在功能测试的过程当中呢
[00:48/15:26]     是由我们的测试工程师对我们的被测系统的页面做一些点击或者输入等等类型的一个操作
[00:56/15:26]     那这时候呢
[00:57/15:26]     系统的运行
[00:58/15:26]     会产生一定的这个响应
[01:00/15:26]     然后我们的测试工程师呢
[01:02/15:26]     要拿到这个系统运行的这个响应呢
[01:05/15:26]     也就是它的一个实际结果和我们测试用例当中编写的一个预习结果去做一个对比
[01:11/15:26]     那这个呢
[01:12/15:26]     是我们功能测试的一个场景
[01:14/15:26]     那接下来这个相信大家都很熟悉啦
[01:16/15:26]     那接下来我们来看一下UES的话
[01:18/15:26]     测试他是什么样的场景

![image-20221211211148248](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211211148248.png)[01:20/15:26]     那这时候我们来看一下UES的话
[01:21/15:26]     测试场景呢
[01:22/15:26]     是我们的测试工程师
[01:25/15:26]     通过这个编程语言去编写我们自动化测试的一个脚本
[01:29/15:26]     然后这个编程语言呢
[01:30/15:26]     会调用我们的Selina去执行我们自动化测试的一个脚本
[01:34/15:26]     然后这个selenium或者swear prize等等自动化测试的一个工具
[01:38/15:26]     它会在我们的被测系统上面
[01:40/15:26]     其实他就是
[01:42/15:26]     一些模拟点击或者输入等等类型操作
[01:45/15:26]     然后并会获取
[01:48/15:26]     自动化运行的一个响应结果
[01:50/15:26]     那我们的编程员拿到这个系统对应的响应结果之后呢
[01:53/15:26]     会与我们提前设定好的预习结果去做一个对比
[01:57/15:26]     如果对比一致的话呢
[02:00/15:26]     就证明我们的自动化测试用例通过了
[02:03/15:26]     那如果对比失败的话呢
[02:04/15:26]     代表的是我们自动化测试的用例也就失败了
[02:08/15:26]     是我们UI自动化测试的这样的一个场景
[02:12/15:26]     可能这时候有同学会说
[02:13/15:26]     老师
[02:14/15:26]     那这两个场景到底有什么异同吗
[02:17/15:26]     我们回到我们功能测试场景
[02:18/15:26]     我们把这张图截取下来好
[02:21/15:26]     然后这时候我们再回到我们UI自动化测试的一个场景
[02:24/15:26]     然后我们来对比一下这两张图
[02:26/15:26]     我们就会发现
[02:27/15:26]     首先我们先来看动作角色是发生了一些变化
[02:31/15:26]     添加编程语言和spinning这两个角色
[02:34/15:26]     那动作是什么
[02:36/15:26]     动作是以前是测试工程师在系统页面对做点击输入等等类型操作
[02:41/15:26]     那现在换成谁
[02:42/15:26]     现在换成了我们的编程语言在做这个事情
[02:47/15:26]     然后以前是测试工程师拿到实际结果和预期结果去做对比
[02:52/15:26]     那现在呢
[02:53/15:26]     也换成了编程语言去做这件事情
[02:55/15:26]     大家可以看到中间所有的操作
[02:58/15:26]     我们来总结一下US动画和功能自动化和这个和这个功能测试他的一个过程
[03:06/15:26]     其实都是一模一样的
[03:07/15:26]     都是在对系统页面做点击输入等操作
[03:13/15:26]     拿到实际结果和预期结果去做对比
[03:15/15:26]     对吧
[03:16/15:26]     那这一部分呢
[03:17/15:26]     是他们一样的地方
[03:19/15:26]     那我们来看他们不一样的地方是什么
[03:20/15:26]     以前是由测试公式
[03:24/15:26]     由测试工程师直接去对系统发起操作
[03:27/15:26]     换成了编程语言
[03:29/15:26]     所以说其实UI自动化测试和功能自动化测试
[03:32/15:26]     从本质上来说他们是一样的
[03:34/15:26]     只是说操作的角色从测试工程师换成了编程语言和selenium OK
[03:42/15:26]     那这个呢
[03:43/15:26]     就是UI自动化测试他的一个场景
[03:45/15:26]     以及他和功能测试的一个对比
[03:49/15:26]     那这时候可能有同学会问了
[03:50/15:26]     说老师
[03:51/15:26]     那什么时候我们可以去做这个UES的话测试呢
[03:54/15:26]     那在这儿呢
[03:55/15:26]     我给大家贴了一张图

![image-20221211211353701](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211211353701.png)[03:56/15:26]     左边这张图非常经典
[04:00/15:26]     我们先来看这两个坐标
[04:01/15:26]     左边这个坐标呢
[04:03/15:26]     左边这个纵坐标呢
[04:04/15:26]     代表是从下往上
[04:06/15:26]     执行效率越来越低
[04:08/15:26]     然后右边这个坐标代表是从下往上
[04:11/15:26]     成本越来越高
[04:12/15:26]     OK
[04:14/15:26]     那这时候我们就会发现一个问题
[04:15/15:26]     就是UI自动化测试
[04:17/15:26]     他是不是执行效率又低
[04:19/15:26]     然后成本又高
[04:21/15:26]     那这时候可能有同学说了
[04:22/15:26]     说老师
[04:23/15:26]     那我们是不是可以不用去做S通话测试啦
[04:26/15:26]     既然他效率又低
[04:27/15:26]     成本又高
[04:28/15:26]     那在这儿我给大家说的是
[04:31/15:26]     那这一部分呢
[04:32/15:26]     是UI和我们这个接口测试还有单元测试一个对比
[04:36/15:26]     那其实只是说对比他们两个
[04:38/15:26]     他是效率又低
[04:39/15:26]     成本又高
[04:40/15:26]     但是对比人工
[04:41/15:26]     对比人力
[04:42/15:26]     那肯定还是要一这个自动化测试
[04:45/15:26]     它的一个执行效率和成本要更加的的的所以说呢
[04:50/15:26]     但是呢
[04:51/15:26]     所以说这个就会导致一个问题
[04:53/15:26]     就是我们一定要慎重的去选择哪一些用例适合去做UI
[04:59/15:26]     动画测试
[05:00/15:26]     哪一些用力不要去做UI自动化测试
[05:03/15:26]     在这个图里面透露给我们的讯息
[05:06/15:26]     是不是说不要去做UI自动化测试
[05:08/15:26]     而是去有选择的去做UI自动化测试
[05:12/15:26]     我们一定要明白这个场景
[05:14/15:26]     那这时候我们抛出来一个问题
[05:16/15:26]     抛出来一个观点
[05:17/15:26]     叫做有选择的去做UI自动化测试
[05:20/15:26]     那什么叫做选择
[05:23/15:26]     那我们哪一些部分可以选择去做UI自动化测试呢
[05:27/15:26]     那我在这儿给大家列举了四种场景
[05:29/15:26]     基本上也是所有的大厂所对于这个哪些用力适合去做UI自动化测试的一个共识吧
[05:37/15:26]     那第一条呢
[05:39/15:26]     就是业务的流程不要频繁的改动
[05:42/15:26]     如果说你业务的流程
[05:43/15:26]     今天和明天都不一样
[05:45/15:26]     这个上个迭代和这个迭代都不一样
[05:47/15:26]     那这部分不要去做UI自动化测试
[05:49/15:26]     因为你脚本刚写好
[05:51/15:26]     那下个版本就用不上了
[05:53/15:26]     就是UI的元素不要频繁的变动
[05:57/15:26]     比如说你们的前端
[05:58/15:26]     老师这个动不动就改这
[06:00/15:26]     一个元素的一个布局
[06:01/15:26]     那这种情况也不适合去做UI自动化测试
[06:04/15:26]     那第三种呢
[06:05/15:26]     就是需要频繁回归的一些场景
[06:07/15:26]     举个例子
[06:08/15:26]     其实这个平凡回归的场景
[06:10/15:26]     也就是通常也指的是我们的一个核心场景
[06:15/15:26]     比如说举个例子
[06:16/15:26]     比如说登录注册呢
[06:18/15:26]     登录注册这种功能呢
[06:19/15:26]     通常开发出来
[06:20/15:26]     1万年都不会变
[06:21/15:26]     但是这部分功能又永远的存在
[06:23/15:26]     那这部分功能呢
[06:24/15:26]     就叫做平凡回归的场景
[06:26/15:26]     我们每个版本可能都得需要去进行测试
[06:30/15:26]     那这部分呢
[06:31/15:26]     它又不会又要频繁回归
[06:33/15:26]     但是又不怎么变动的
[06:34/15:26]     厂里呢
[06:35/15:26]     我们这种登陆注册
[06:36/15:26]     我们就很适合去做这个UI自动化测试
[06:39/15:26]     那还有第四种呢
[06:40/15:26]     叫做这个核心产品
[06:42/15:26]     比如说我们的一个产品呢
[06:43/15:26]     是一个商城这样的一个产品
[06:45/15:26]     那对于我们这个商城产品来说
[06:48/15:26]     用户的从下单到支付这个过程是不是就是我们的核心场景
[06:53/15:26]     那这种核心场景
[06:54/15:26]     适合你的业务息息相关的
[06:57/15:26]     那如果说你是抖音
[06:58/15:26]     如果说你是这个我们的被测产品是抖音或者B站这样的一个视频呢
[07:04/15:26]     它的一个这个
[07:05/15:26]     比如说我们看视频
[07:06/15:26]     切换视频
[07:07/15:26]     就是我们的核心场景
[07:08/15:26]     那针对于这些核心场景
[07:10/15:26]     我们全部都应该去对它做一些自动化测试
[07:13/15:26]     那一些非核心
[07:14/15:26]     就比如说一些不重要的功能
[07:16/15:26]     或者说这个用例级别比较低的一个功能
[07:19/15:26]     我们就可以选择性的去做US号测试
[07:23/15:26]     OK
[07:24/15:26]     就是叫做什么时候可以做UI自动化测试
[07:29/15:26]     那这个呢
[07:30/15:26]     UES的话
[07:31/15:26]     测试我们了解完成之后呢
[07:32/15:26]     我们在我们的接下来这个大章节
[07:35/15:26]     我们主要学习的是web自动化测试的
**[07:39/15:26]     web自动化测试他有哪些相关技术呢**

![image-20221211211602421](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211211602421.png)[07:42/15:26]     在我们本次的学习的过程当中呢
[07:44/15:26]     主要涉及到的是这个selenium
[07:46/15:26]     然后如果是单元测试
[07:48/15:26]     并并且会结合我们的一个单元测试框架
[07:50/15:26]     就是我们的pad或者我们的Java net5
[07:53/15:26]     然后使用这个单元测试框架呢
[07:56/15:26]     可以协助我们更好地去做自动化测试
[07:58/15:26]     比如说一些参数化的一些场景
[08:01/15:26]     或者说一些或者说一些这个断言的场景
[08:04/15:26]     使用相关的框架就会方便很多
[08:06/15:26]     然后他第三个呢
[08:07/15:26]     就是相关的一个测试报告J
[08:09/15:26]     像这个测试框架还有测试报告
[08:12/15:26]     在我们前面都已经学习过了
[08:15/15:26]     那这个就是我们这一个大章节主要所需所使用到的相关的一些技术
[08:22/15:26]     那接下来我们再来看
[08:24/15:26]     那可能很多同学说
[08:26/15:26]     老师这个听说外部自动化测试或者说UI自动化测试在企业当中其实是这个很多企业都不会去做的一个事情
[08:35/15:26]     那在这儿可以给大家说的是
[08:37/15:26]     那如在这个人力或者说条件允许的情况下
[08:40/15:26]     1万自动化测试
[08:41/15:26]     他当然不算优先级最高
[08:42/15:26]     优先级最高的一定是接口还有单元
[08:47/15:26]     UI自动化测试他也是非常重要的
[08:50/15:26]     因为UI自动化测试它涉及到了很多的这个用户体验相关的一些问题
[08:55/15:26]     比如说你是一个C端产品
[08:57/15:26]     你非常的看重用户体验
[08:59/15:26]     那这时候你就非常的有必要去做这样的一个UI自动化测试
[09:05/15:26]     那接下来给大家看几个这个UI自动化测试在企业当中的一个实践吧
[09:09/15:26]     其实这个有赞

![image-20221211211721810](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211211721810.png)[09:11/15:26]     在这儿包括阿里
[09:13/15:26]     百度啊
[09:15/15:26]     只要是大公司或者说稍微有一点规模的公司
[09:17/15:26]     基本都会去做UI自动化测试的
[09:21/15:26]     我在这儿给大家举一个例子
[09:22/15:26]     就是有赞的一个例子
[09:23/15:26]     大家可以点开PPT自己去看
[09:26/15:26]     在这儿就可以看到有赞他是怎么样去做UI自动化测试的
[09:29/15:26]     他们的一个测试方案是什么
[09:32/15:26]     那大家简单了解一下就OK了
[09:34/15:26]     那我们前面了解完这个什么叫做US动画测试
[09:39/15:26]     然后什么时候去做UI自动化测试
[09:41/15:26]     那我们在本次大章节学习外部自动化测试的时候又会用到哪些知识
[09:46/15:26]     那接下来我们就来看一下在外部自动化测试这一块儿
[09:50/15:26]     我们应该如何去学习
**[09:53/15:26]     其实有一个清晰的学习路线**

![image-20221211211740897](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211211740897.png)[09:55/15:26]     能够提高大家的一个学习效率
[09:56/15:26]     然后也让大家的这个学习的成果也是要比一个没有学习路线一个情况下要学的更好
[10:05/15:26]     希望给大家介绍这个学习路线
[10:06/15:26]     让大家知道该怎么样去学习
[10:09/15:26]     哪一些是重要的
[10:11/15:26]     哪一些是哪一些是相对来说没那么重要的
[10:14/15:26]     然后哪一些是必须要学的
[10:16/15:26]     哪一些是需要先学的
[10:17/15:26]     哪一些是可以后学的
[10:19/15:26]     我们在这个学习路线讲解当中
[10:21/15:26]     一定会给大家讲清楚的
[10:22/15:26]     那整个学习路线呢
[10:24/15:26]     它有三个核心思想
[10:25/15:26]     第一个核心思想是由浅入深
[10:27/15:26]     就是我们在一开始的时候
[10:30/15:26]     尤其是小白的同学
[10:31/15:26]     我们在一开始的时候呢
[10:32/15:26]     一定要把自己的这个基础打扎实了
[10:35/15:26]     所以说我们会从简单的这个内容开始给大家讲解起来
[10:38/15:26]     然后呢
[10:39/15:26]     第二个
[10:41/15:26]     第二个第二个要注意的点呢
[10:42/15:26]     就是我们要学会掌握什么是核心
[10:46/15:26]     什么是重点
[10:47/15:26]     等一下也会给大家说
[10:48/15:26]     究竟什么是核心
[10:49/15:26]     什么是重点
[10:50/15:26]     然后第三个部分呢
[10:51/15:26]     就是理论要结合实践
[10:53/15:26]     我们的录播课程呢
[10:57/15:26]     是这样的一个模式
[10:58/15:26]     然后前面呢
[10:59/15:26]     会给大家介绍
[11:01/15:26]     比如说steam的一些基础API使用
[11:03/15:26]     那等大家掌握了steam的基础API使用之后呢
[11:07/15:26]     我们会结合一次的这个实战的这样的一个练习
[11:11/15:26]     然后让大家去
[11:12/15:26]     然后让大家去进行学习
[11:14/15:26]     然后首先我们先来看
[11:16/15:26]     我们看右边这个思维导图
[11:17/15:26]     我们把这个学习的这个路线呢
[11:21/15:26]     分为了五个层级
[11:22/15:26]     然后大家只是重点关注初级中级和高级
[11:26/15:26]     然后出除了初级中级和高级之外呢
[11:28/15:26]     还有这个资深和拓展
[11:30/15:26]     还有常见的一些面试题
[11:32/15:26]     针对于这两个模块
[11:33/15:26]     为什么把这两个模块弱化
[11:36/15:26]     前面的强化呢
[11:37/15:26]     这个原因就是因为大家可能看到
[11:38/15:26]     哎呀面试题
[11:39/15:26]     那我先去看面试题
[11:40/15:26]     不要这样不要这样
[11:41/15:26]     一定要先去把你前面该学的知识点学好了
[11:46/15:26]     把基础夯实了
[11:47/15:26]     你这时候再去看面试题
[11:48/15:26]     你才能够更好的去理解
[11:50/15:26]     如果说你前面学不好
[11:53/15:26]     你后面去看面试题的时候
[11:54/15:26]     你一定是理解不了的
[11:56/15:26]     好
[11:57/15:26]     那包括自身和拓展也是一样
[11:58/15:26]     一定要把前面的这些内容学扎实了
[12:01/15:26]     再去学一些资深和拓展的一些内容
[12:04/15:26]     那在初级里面呢
[12:06/15:26]     对于大家一个学习目标
[12:07/15:26]     就是我们要学会selenium常见方法的基本使用
[12:11/15:26]     然后在这一块儿实战呢
[12:13/15:26]     会给大家带来这个基本的一个web自动化测试用例的编写
[12:17/15:26]     一个web测测试用力
[12:19/15:26]     它应该是什么样的一个用力结构
[12:20/15:26]     它应该有哪些要素
[12:22/15:26]     那学完初级还不够
[12:24/15:26]     学完初级还不够
[12:25/15:26]     只是说你在学完初级之后呢
[12:28/15:26]     你基本对steam有了一个基础的了解了
[12:31/15:26]     那接下来中级呢
[12:32/15:26]     就是一些外部自动化测试的技巧的一些进阶的使用
[12:36/15:26]     那在这一块儿呢
[12:37/15:26]     我们会教给大家
[12:38/15:26]     比如说你的这个用力在执行过程当中如何截图
[12:42/15:26]     如何加入日志
[12:44/15:26]     如何打印报告
[12:46/15:26]     然后包括会教大家一些高级定位知识
[12:49/15:26]     高级定位只是在UI自动化非常有用
[12:52/15:26]     强调一遍非常有用
[12:54/15:26]     包括显示等待
[12:55/15:26]     然后都会在这个终结部分给大家去进行讲解
[13:00/15:26]     那在高级的部分呢
[13:01/15:26]     我们更专注的就是我们设计模式的一个部分
[13:04/15:26]     怎么样去编写这个合理的一个web自动化测试的一个代码
[13:08/15:26]     让它更有可读性
[13:09/15:26]     让他的可维护性更高
[13:10/15:26]     可读性更高
[13:11/15:26]     那就在我们的高级部分去教给大家
[13:14/15:26]     首先在高级会教大家这个配配置object设计模式的一些基本概念
[13:20/15:26]     然后他的一些基本原则
[13:21/15:26]     那在基于这个配置ABS的设计模式之上呢
[13:24/15:26]     我们会给大家带来一次这个基于配置object的一个测试用例编写的一个实战
[13:30/15:26]     那这一部分呢
[13:31/15:26]     就是简单的给大家说一下我们的学习路线
[13:35/15:26]     那在后面呢
[13:36/15:26]     有每一个章节具体的我们要学习的一个内容
[13:39/15:26]     那我在这儿给大家标出来哪些是必修
[13:41/15:26]     哪一些是这个资深和拓展
[13:44/15:26]     那我们还是简单的
[13:46/15:26]     那在初级阶段呢

![image-20221211212016296](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212016296.png)

![image-20221211212042020](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212042020.png)

![image-20221211212100970](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212100970.png)![image-20221211212117357](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212117357.png)![image-20221211212124263](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212124263.png)[13:48/15:26]     还是一句话
[13:49/15:26]     大家可以看到所学习的内容整体来说难度不会特别大
[13:54/15:26]     在这块儿更希望大家是掌握steam的一些基本使用
[13:59/15:26]     然后并且能够完成一次实战练习
[14:01/15:26]     然后在中级呢
[14:02/15:26]     我们就需要学一些更进阶一些知识了
[14:06/15:26]     比如说一些高级定位
[14:09/15:26]     然后比如说然后比如说一些这个异常情况的
[14:13/15:26]     就是自动化测试
[14:14/15:26]     UI自动化测试
[14:16/15:26]     Web自动化测试过程当中常见的一些情况的处理
[14:20/15:26]     比如说frame切换
[14:21/15:26]     窗口切换
[14:22/15:26]     文件上传
[14:23/15:26]     一些弹框
[14:25/15:26]     包括一些自动化关键数据记录
[14:27/15:26]     然后帮我们去分析问题
[14:30/15:26]     然后也会给大家带来一次实战
[14:32/15:26]     然后并且还有对应的这个直播的训练营
[14:34/15:26]     然后再高级的部分呢
[14:36/15:26]     前面给大家说了
[14:37/15:26]     最主要的就是我们的一个屏
[14:39/15:26]     然后以及这个关于截图的一些封装好
[14:43/15:26]     然后也会给大家带来实战
[14:45/15:26]     每一个级别我们都会给大家带来一次实战
[14:47/15:26]     然后这个实战这个录播
[14:50/15:26]     这个整体来说时常不会特别长
[14:52/15:26]     大家每一周都要把握好时间仔细去看
[14:55/15:26]     然后在最后呢
[14:56/15:26]     就是这个自身和拓展是属于大家选修的部分
[15:00/15:26]     大家如果想学的话
[15:02/15:26]     这个基础打得比较好的话
[15:03/15:26]     可以这个去了解一下
[15:05/15:26]     然后这个是相关的面试题
[15:07/15:26]     那这个面试题呢
[15:08/15:26]     是持续更新的一个状态
[15:09/15:26]     目前已经录制的是这样的一些内容
[15:13/15:26]     那这个这个第一个章节
[15:16/15:26]     就不给大家讲那么多了
[15:18/15:26]     就不做那么多的一个废话了
[15:20/15:26]     那最重最最重要的是
[15:22/15:26]     我们一定要按照老师给大家提供的这样的一个学习路线去进行学习



### 2、环境安装与使用
[00:00/33:04]     [以下字幕均由机器生成]我们要学习的是外部自动化测试的一个环境安装与使用
[00:03/33:04]     [以下字幕均由机器生成]我们今天呢
**[00:04/33:04]     主要是分成三个部分去给大家进行讲解**

![image-20221211212208816](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212208816.png)[00:06/33:04]     那第一个部分呢
[00:07/33:04]     会给大家简单的介绍一下我们的这个Selenium
[00:11/33:04]     那第二部分呢
[00:12/33:04]     会教大家如何去安装配置我们seen him的这样的一个环境
[00:17/33:04]     那第三个部分呢
[00:18/33:04]     就是我们具体浏览器驱动
[00:21/33:04]     也就是我们driver的一个配置
[00:23/33:04]     然后driver配置这一块儿呢
[00:24/33:04]     我们会分为麦克和Windows分开给大家去进行介绍
[00:28/33:04]     然后大家可以根据自己的操作系统选择不同的一个专业配置
[00:34/33:04]     那前面的selenium的安装还有介绍呢
[00:37/33:04]     不管是Mac还是Windows都是一样的
[00:39/33:04]     所以这块儿没有什么差别
[00:41/33:04]     我们先来看一下
[00:42/33:04]     先给大家简单介绍一下selenium
[00:45/33:04]     然后上面的这一部分是Celine的这样的一个官方网站
[00:51/33:04]     Celine的这个官方网站大家可以看到有非常全的一个信息
[00:55/33:04]     然后有下载的部分
[00:56/33:04]     然后有文档的部分
[00:57/33:04]     然后以及它的一些介绍等等的一个内容
[01:01/33:04]     那selenium它是一个什么样的工具呢

![image-20221211212230536](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212230536.png)[01:03/33:04]     它是一个用于做web浏览器测试这样的一个工具
[01:08/33:04]     那它支持浏览器
[01:09/33:04]     包括我们的IE firefox Safari Chrome edge等等
[01:13/33:04]     所以它是一个支持多浏览器的web浏览器
[01:17/33:04]     外部浏览器测试的一个工具
[01:20/33:04]     那它有第二个优点呢
[01:21/33:04]     就是它可以它是支持多语言的
[01:25/33:04]     它使用起来非常简单
[01:26/33:04]     可以使用Java Python等多种语言去编写我们的一个用例脚本
[01:31/33:04]     那selenium呢
[01:32/33:04]     他其实主要由三大三个部分构成
[01:36/33:04]     那这三大块儿呢
[01:37/33:04]     分别就是我们的一个web driver idea he great的web driver呢
[01:42/33:04]     会在我们后面写web自动化测试脚本的时候
[01:45/33:04]     大量的用不
[01:46/33:04]     然后还有idea呢
[01:48/33:04]     是这个slim用来录制的这样的一个工具
[01:51/33:04]     还有我们的司机name great
[01:53/33:04]     它是用来做分布式的这样的一个工具
[01:57/33:04]     那c LIM我们了解完c LIM的一些基础信息之后
**[02:01/33:04]     我们再来简单看一下c name的这样的一个结构**

![image-20221211212306869](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212306869.png)[02:04/33:04]     那详细的说明呢
[02:05/33:04]     会在斯丽妮姆阿原理介绍这个录播里面会给大家进行详细介绍
[02:10/33:04]     我们在这儿简单给大家带一下
[02:14/33:04]     那这张图是什么意思呢
[02:15/33:04]     我们从左往右看
[02:17/33:04]     这个意思就是说他弟slim的这样的一个工作原理
[02:20/33:04]     它使用多种这个编程语言
[02:22/33:04]     然后去调用我们selenium的这样的一个服务
[02:25/33:04]     然后这个selenium收到变成圆的请求之后
[02:29/33:04]     他就会去调用我们浏览器对应的一个驱动
[02:33/33:04]     比如说这个驱动呢
[02:35/33:04]     比如说就是我们的Chrome driver IE driver和driver等等
[02:39/33:04]     多利其他包括这个Safari
[02:42/33:04]     他们每个浏览器呢
[02:43/33:04]     都有自己的一个driver
[02:45/33:04]     那这个不同的driver呢
[02:46/33:04]     它就会调用不同的这个浏览器
[02:49/33:04]     比如说Chrome driver
[02:50/33:04]     它就是专门用来调用谷歌浏览器的这样的一个驱动去进行使用的
[02:57/33:04]     了解完那个架构之后呢
**[02:58/33:04]     我们再来看这个web自动化测试环境它的一个配置步骤有哪些**
[03:03/33:04]     首先第一个呢

![image-20221211212351820](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212351820.png)[03:04/33:04]     我们需要先去安装我们的一个拍摄环境
[03:08/33:04]     我们要保证我们的拍摄环境是已经安装完成的
[03:10/33:04]     然后第二个部分呢
[03:12/33:04]     就是需要去安装一下我们c LIM的这样的一个依赖
[03:15/33:04]     然后第三个部分呢
[03:17/33:04]     我们需要去进行这个浏览器驱动的一个下载与配置
[03:23/33:04]     那在那它这个操作系统
[03:25/33:04]     比如说Mac和Windows
[03:27/33:04]     它不同的地方
[03:28/33:04]     主要就是在于这个第三个步骤
[03:30/33:04]     前两个步骤其实都是一模一样的
[03:32/33:04]     那在这里呢
[03:33/33:04]     尤其是刚开始学习的同学
[03:34/33:04]     需要注意的是谷歌浏览器和火狐浏览器
[03:37/33:04]     我们选择一个去进行配置就可以
[03:42/33:04]     在这里更建议大家使用我们的一个谷歌浏览器
[03:47/33:04]     那斯利姆他的依赖是如何安装的呢
[03:50/33:04]     在这里他有两个前提

![image-20221211212424110](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212424110.png)[03:52/33:04]     是要准备好我们的Python环境和我们的一个pad工具
[03:56/33:04]     那在这里呢
[03:57/33:04]     因为我就不做过多的一个介绍啦
[03:59/33:04]     这部分在我们的Python录播里面是有的
[04:01/33:04]     那第二个部分呢
[04:02/33:04]     就需要去安装一下我们的这个随你们的一个环境
[04:05/33:04]     那安装也非常简单
[04:07/33:04]     直接使用pop in stores Linux即可
[04:09/33:04]     然后现在呢
[04:10/33:04]     进入我们的一个
[04:12/33:04]     这个是拍唱
[04:14/33:04]     然后进入拍场之后
[04:15/33:04]     它有两种安装方式
[04:16/33:04]     第一种是直接通过派Tom去进行安装
[04:19/33:04]     我们进入我们的settings
[04:21/33:04]     找到这个past inter pre ter
[04:23/33:04]     然后在这个地方呢
[04:24/33:04]     我们设置好这个pass inter pre ter之后呢
[04:26/33:04]     在这个地方我们就可以看到它这个Python解释器对应的一个依赖
[04:32/33:04]     那在这我们就可以点这个小加号
[04:34/33:04]     然后输入Xu Li Ning
[04:36/33:04]     然后再点击一下音色
[04:39/33:04]     就可以成功安装了
[04:41/33:04]     然后在这当它提示有这个绿色条子
[04:43/33:04]     说package thing installed successfully呢
[04:48/33:04]     就证明我们已经安装成功了
[04:50/33:04]     然后如果说不习惯使用这个idea
[04:54/33:04]     或者说你用的是Vs code
[04:55/33:04]     那你也可以直接打开你们的命令行
[04:58/33:04]     然后输入pap in stores in
[05:02/33:04]     这样也是可以的OK
[05:05/33:04]     然后这样子它也提示我们安装成功了
[05:07/33:04]     然后我们输入一下pap list检查一下看看有没有安装成功
[05:11/33:04]     那在这我们看到我们第一猛证明
[05:13/33:04]     我们的这个CM的这个依赖库呢
[05:16/33:04]     就安装好了
[05:19/33:04]     先发我们的PPT
**[05:23/33:04]     接下来我们来看一下driver的下载与配置**

![image-20221211212509384](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212509384.png)[05:26/33:04]     那这个driver的下载与配置呢
[05:27/33:04]     是我们刚开始学习web自动化测试必不可少的一个步骤
[05:31/33:04]     同时也是刚开始学习的同学比较容易踩坑的一个步骤
**[05:35/33:04]     我们先来看一下它有哪几个步骤**

![image-20221211212530885](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211212530885.png)[05:37/33:04]     那第一个步骤呢
[05:39/33:04]     我们需要下载浏览器对应的一个driver
[05:42/33:04]     那谷歌浏览器和火狐浏览器
[05:44/33:04]     其实我们选择一个就可以了
[05:46/33:04]     然后第二个步骤呢
[05:47/33:04]     我们需要去配置我们driver对应的一个环境变量
[05:51/33:04]     那第三个步骤呢
[05:52/33:04]     我们需要去重启一下我们的命令行工具
[05:55/33:04]     验证是否配置成功
[05:57/33:04]     那这几个步骤
[05:58/33:04]     都会带着大家一一去进行练习
[06:01/33:04]     然后这个链接呢
[06:02/33:04]     其实就是我们CMCM官网的一个链接
[06:06/33:04]     它里面写了这个对应的这个浏览器
[06:09/33:04]     还有它支持操作系统以及它对应的下载链接
[06:13/33:04]     然后这个的话
[06:14/33:04]     因为他一些网站
[06:16/33:04]     由于这个网络限制一个原因
[06:17/33:04]     是不能看的
[06:18/33:04]     所以说大家可以直接用我们PPT里面对应的网站就OK了
[06:22/33:04]     好
[06:23/33:04]     我们首先先来看一下Windows的配置步骤
[06:26/33:04]     那如果想看Mac的配置步骤的同学
[06:29/33:04]     大家可以把进度条往后拉
[06:31/33:04]     后面有Mac配置步骤的一个教学
[06:34/33:04]     那我们看一下Windows详细配置的有一个步骤参考
[06:38/33:04]     关于这个步骤参考写了一个帖子
[06:40/33:04]     然后大家可以自行点我们PPT里面的这个帖子去看
[06:46/33:04]     那如果说觉得帖子看不太明白的同学
[06:49/33:04]     可以跟着我们的这个视频
[06:50/33:04]     然后一步一步的
[06:52/33:04]     一步一步的跟着老师一起去配置好
[06:55/33:04]     那我们Windows的第一个步骤呢
[06:56/33:04]     就是我们前面说了就是driver的一个下载
[06:59/33:04]     那首先我们先来看谷歌浏览器的这样的一个配置
[07:03/33:04]     那第一个步骤呢
[07:04/33:04]     就是下载我们的一个Chrome driver
[07:06/33:04]     那Chrome driver他下载需要注意什么呢
[07:09/33:04]     那首先呢
[07:10/33:04]     需要注意的第一个细节就是需要确定和浏览器匹配的这样的一个Java版本
[07:15/33:04]     需根据使用的操作系统下载相应的一个Chrome driver
[07:20/33:04]     然后在这个地方呢
[07:22/33:04]     就是我们在这个右边呢
[07:23/33:04]     就是我们对应的一个淘宝镜像的这样的一个地址
[07:26/33:04]     然后在这儿大家可以看到有这么多的一个版本
[07:29/33:04]     那哪一个版本和我们的浏览器是一致的呢
[07:32/33:04]     我们怎么样去看呢
[07:33/33:04]     首先我们点开右上角
[07:34/33:04]     这里有个三个点
[07:35/33:04]     我们点一下它
[07:36/33:04]     然后在这儿有一个设置
[07:38/33:04]     我们点击一下
[07:39/33:04]     然后在设置里面呢
[07:40/33:04]     有个叫做关于Chrome
[07:42/33:04]     我们点一下
[07:43/33:04]     然后在这儿
[07:44/33:04]     我们就可以看到我们crew
[07:46/33:04]     Driver的一个对应的版本是98.0.4758.102OK
[07:50/33:04]     我们找一下在我们刚刚打开的淘宝镜像找一下有没有98.0.4758.102OK
[07:59/33:04]     我们看一下102OK
[08:00/33:04]     没有任何问题
[08:01/33:04]     然后点一下这个102这个链接
[08:03/33:04]     然后我们进来之后呢
[08:05/33:04]     我们现在就已经知道这个版本适合我们的浏览器是匹配的版本
[08:09/33:04]     那接下来我们就要选择对应的操作系统了
[08:13/33:04]     我这个我现在给大家演示的呢
[08:15/33:04]     是Windows的版本
[08:16/33:04]     所以说我们就直接下载这个N32
[08:18/33:04]     然后在这里大家需要注意的是
[08:20/33:04]     不管你是64位的操作系统还是32位的
[08:22/33:04]     你都下这个就OK了
[08:24/33:04]     然后我们点击一下
[08:25/33:04]     然后我们给他下载到我们的一个桌面
[08:29/33:04]     OK
[08:30/33:04]     我们这个压缩包
[08:31/33:04]     我们就下载完成了
[08:34/33:04]     那这个是我们的第一个步骤
[08:36/33:04]     就是Chrome driver的这样的一个下载
[08:38/33:04]     那下载好之后呢
[08:40/33:04]     我们可不可以直接去进行使用
[08:42/33:04]     那我们第一步肯定首先还是要给他解压一下的
[08:46/33:04]     那我们尝试给他先做一个解压
[08:49/33:04]     下载刚刚是这个一对吧
[08:51/33:04]     你解压一下
[09:02/33:04]     我们在这儿
[09:03/33:04]     可以看到有一个叫做chromedriver.x这样的一个文件
[09:07/33:04]     那这时候打开我们的品牌Tom
[09:09/33:04]     我们这时候新建一个文件
[09:11/33:04]     叫做first
[09:13/33:04]     我们的第一个
[09:16/33:04]     我们的第一个web自动化脚本
[09:19/33:04]     那我们在这儿呢
[09:20/33:04]     做事也非常简单
[09:21/33:04]     我们直接from swimming import
[09:25/33:04]     Web driver就可以啦
[09:27/33:04]     然后我们做一个什么事儿呢
[09:28/33:04]     我们只做第一个操作
[09:29/33:04]     就是打开一个网站这样的一个操作
[09:33/33:04]     然后我们怎么做呢
[09:34/33:04]     我们在这儿首先第一个变量叫做driver driver等于什么呢
[09:39/33:04]     等于我们的一个web driver点
[09:42/33:04]     这儿有一个Chrome
[09:44/33:04]     然后点Chrome还不行
[09:45/33:04]     我们一定要在Chrome后面加一个括号
[09:51/33:04]     一定要在
[09:55/33:04]     Cool
[09:56/33:04]     后面添加括号
[09:59/33:04]     代表实例化这个类
[10:05/33:04]     好
[10:06/33:04]     我们可以调用这个driver.get方法
[10:09/33:04]     然后在这里呢
[10:11/33:04]     输入我们想打开网址的URL
[10:14/33:04]     比如说我们以这个测试人为例吧
[10:16/33:04]     我们打开这个测试人
[10:21/33:04]     然后这个时候呢
[10:22/33:04]     我们执行一下我们的脚本润一下
[10:24/33:04]     好
[10:25/33:04]     这是我们发现脚本报错了对不对
[10:28/33:04]     报什么错误
[10:29/33:04]     我们仔细看一下
[10:30/33:04]     他说Chrome driver execute ble needs tobe in pass
[10:35/33:04]     然后在这儿呢
[10:36/33:04]     这个问题
[10:37/33:04]     是新手非常容易常见的一个问题
[10:40/33:04]     为什么我们这样子调用就会有问题呢
[10:42/33:04]     这是因为这是因为他在寻找的过程当中
[10:46/33:04]     如果你没有把这个Chrome Java配到环境变量里面
[10:50/33:04]     你就必须要通过关键字去指定它的路径
[10:53/33:04]     所以说
[10:54/33:04]     建议大家下载好科目二之后就直接配套环境变量
[10:58/33:04]     你一旦发现了这个错误
[11:01/33:04]     一般就是由环境变量所导致的
[11:03/33:04]     所以接下来呢
[11:04/33:04]     我们就进行下面的这个步骤的一个操作
[11:07/33:04]     就是配置环境变量的这样的一个操作
[11:10/33:04]     然后怎么去配置呢
[11:11/33:04]     Windows的同学注意
[11:12/33:04]     首先我们先点击这个放大镜
[11:14/33:04]     输入一个环境变量
[11:18/33:04]     我们点一下这个环境变量
[11:21/33:04]     点了之后
[11:22/33:04]     我们在下面的系统变量这里
[11:24/33:04]     我们找到这个pass
[11:25/33:04]     然后我们在这儿呢
[11:27/33:04]     需要给他新加这样的一个路径进去
[11:30/33:04]     好
[11:31/33:04]     我们刚刚我们看一下我们刚刚下载好的这个Chrome driver
[11:35/33:04]     对吧
[11:36/33:04]     我们是下载这个Chrome driver
[11:38/33:04]     我就尽量
[11:40/33:04]     不要让他直接去练到我们的一个桌面
[11:43/33:04]     建议大家是放在你们的地盘的某个文件当中
[11:46/33:04]     比如说我们在的盘这里新建一个叫做driver
[11:53/33:04]     我们把这个对应的这个Chrome driver先给他丢进去
[12:01/33:04]     我们现在就把这个Chrome driver这个路径就丢进来了
[12:04/33:04]     对吧
[12:05/33:04]     然后我们现在来看一下
[12:06/33:04]     那它对应的一个路径是什么呢
[12:10/33:04]     对应的路径就是这个路径大家看好了
[12:13/33:04]     那然后呢
[12:14/33:04]     打开我们的环境变量
[12:17/33:04]     环境变量
[12:18/33:04]     然后系统变量对吧
[12:19/33:04]     前面都说过了
[12:20/33:04]     然后我们在这儿找到我们的pass
[12:22/33:04]     然后在这儿新增一个新建
[12:24/33:04]     然后叫做这个我们刚刚在这个里面看到的这条路径
[12:29/33:04]     我们复制一下
[12:31/33:04]     新建粘贴过来
[12:33/33:04]     然后点击确定
[12:34/33:04]     确定
[12:35/33:04]     一定要全部确定确定
[12:36/33:04]     一路确定下来之后呢
[12:38/33:04]     我们要干嘛
[12:39/33:04]     我们要重新关掉我们的CMD
[12:44/33:04]     关掉我们CMD
[12:45/33:04]     然后打开
[12:46/33:04]     重新打开我的命令行
[12:47/33:04]     然后输入输入一个Chrome driver
[12:56/33:04]     我们说一下
[12:57/33:04]     我们发现是不是就这个有对应的一个提示信息
[13:01/33:04]     并且告诉我们你的Chrome driver的版本是多少
[13:05/33:04]     那这样子就说明什么
[13:06/33:04]     就说明你的这个Chrome driver就配置成功了配置成功了
[13:12/33:04]     现在回到我们的PPT
[13:14/33:04]     我们继续往后看
[13:15/33:04]     那我们前面说了
[13:16/33:04]     那当我们在Windows里面输入Chrome driver
[13:20/33:04]     然后或者输入这个Chrome driver杠杠version也是OK的
[13:23/33:04]     我现在也可以输入一下看看
[13:30/33:04]     不是说一下我们发现有这个内容就说明配置成功了
[13:35/33:04]     而这个第三个步骤验质Chrome driver是否成功
[13:39/33:04]     大家需要注意的是
[13:40/33:04]     一定要重启你们的CMD才可以
[13:44/33:04]     那我们继续往后看
[13:45/33:04]     那我们前面说的这个Chrome driver之外呢
[13:47/33:04]     如果说有的同学他可能不想配置这个Chrome driver
[13:52/33:04]     只想使用我们的一个火狐浏览器
[13:55/33:04]     那也是可以的
[13:56/33:04]     那这个火狐浏览器的配置呢
[13:58/33:04]     需要注意的是
[14:00/33:04]     首先是下载
[14:02/33:04]     他是没有这个Chrome Java类似一个对应关系的
[14:05/33:04]     它需要下载最新的一个Java版本就OK了
[14:09/33:04]     然后根据使用的操作系统去下一下载相应的这个driver
[14:13/33:04]     然后同样的我们在这儿提供了一个地址给大家
[14:16/33:04]     大家直接打开就OK了
[14:18/33:04]     我们把这些其他的链接观一观
[14:21/33:04]     你直接打开
[14:22/33:04]     打开之后
[14:23/33:04]     我们在这儿发现就有这么多的一个版本
[14:26/33:04]     我们直接下载它最新的这样的一个版本
[14:30/33:04]     我们找一下他最新的一个版本是多少找一下时间
[14:34/33:04]     就是这个V30这个版本吧
[14:36/33:04]     我们下载一下
[14:37/33:04]     然后在这儿呢
[14:38/33:04]     我们可以看到
[14:39/33:04]     它这里就是分了这个36位和64位的一个操作系统了
[14:45/33:04]     所以说我们直接选择跟自己操作系统匹配的这样的一个版本呢
[14:49/33:04]     我是64位
[14:50/33:04]     所以我就直接下载64了
[14:54/33:04]     我们的这个这个driver就下载成功啦
[14:57/33:04]     那接下来呢
[15:00/33:04]     还需要去配置一下这个环境变量
[15:02/33:04]     和我们的这个Chrome driver是一致的
[15:05/33:04]     那我们只需要在我们的这个D盘里面
[15:07/33:04]     我们再添加一个路径好了
[15:09/33:04]     比如说在这个driver这里我们再加一个
[15:14/33:04]     再新建一个文件夹叫做
[15:17/33:04]     或者说我们可以直接把所有的这个driver
[15:21/33:04]     全部丢到我们的这个
[15:23/33:04]     丢到我们刚刚和Chrome driver配置的同一个浏览器
[15:26/33:04]     那这样子的话呢
[15:27/33:04]     我们就不需要再重复的去进行环境变量的一个配置了
[15:33/33:04]     那我们直接把刚刚下载这个证儿丢进来
[15:36/33:04]     解压一下
[15:41/33:04]     我们现在解压成功了
[15:42/33:04]     那我们把它丢到我们刚刚已经配置好环境变量的这个driver的这个路径下面
[15:47/33:04]     我们已经把这个Java路径配置过了丢进来OK
[15:52/33:04]     丢进来之后呢
[15:54/33:04]     接下来我们只需要这个打开我们的CMD
[15:59/33:04]     然后输入一个Jack driver
[16:05/33:04]     OK
[16:07/33:04]     我们加一个杠纹身
[16:12/33:04]     好
[16:13/33:04]     他这个版本有显示出来它对应的一个0.30
[16:17/33:04]     就是我们刚刚配置一个内容
[16:19/33:04]     证明我们的这个这个driver也配置成功了那如果说你的这个环境变量没有配置过的话
[16:27/33:04]     还需要再重复的去给它进行一下配置
[16:29/33:04]     OK
[16:30/33:04]     那这一部分呢
[16:31/33:04]     就是我们这个巩固火狐浏览器的一个驱动的这样的一个配置的一个流程
[16:38/33:04]     和我们的这个谷歌的这个驱动是一模一样的
[16:43/33:04]     接下来呢
[16:44/33:04]     我们来看一下在Mac系统上面它的这个driver driver的一个下载与配置
[16:50/33:04]     那我们来看一下在Mac上面呢
[16:52/33:04]     Java的下载与配置步骤
[16:54/33:04]     其实和我们前面学的Windows是一致的
[16:56/33:04]     首先第一个步骤呢
[16:59/33:04]     需要去下载浏览器对应的一个driver
[17:02/33:04]     那谷歌浏览器和火狐浏览器
[17:04/33:04]     我们选一个就可以了
[17:05/33:04]     然后这个呢
[17:07/33:04]     是我们官方文档对应的一个链接
[17:09/33:04]     然后在这儿我们可以看到浏览器支持的系统
[17:11/33:04]     然后下载的路径等等
[17:15/33:04]     然后第二个步骤呢
[17:16/33:04]     需要我们去配置一下Java的一个环境变量
[17:19/33:04]     然后第三个步骤
[17:20/33:04]     配置完成之后
[17:21/33:04]     住的注意
[17:22/33:04]     一定要去重启你们的命令行工具
[17:26/33:04]     包括你们的拍场
[17:27/33:04]     包括你们的idea
[17:28/33:04]     尽量都去重启一次
[17:29/33:04]     然后重启完成之后呢
[17:32/33:04]     我们再去验证一下是否配置成功
[17:35/33:04]     在这里给大家说一下
[17:36/33:04]     就是这个环境变量的配置呢
[17:37/33:04]     如果不去配的话
[17:39/33:04]     需要我们在后面写代码的时候给他去指定路径是非常麻烦的
[17:43/33:04]     所以建议大家一开始就直接配好是最省事儿的
[17:49/33:04]     OK
[17:50/33:04]     那接下来我们继续往后看它具体的一个操作
[17:54/33:04]     首先我们先来看
[17:55/33:04]     就是第一个步骤呢
[17:57/33:04]     在Mac系统上面
[17:58/33:04]     我们需要先去下载一下我们的Chrome driver
[18:02/33:04]     然后在下载过程当中呢
[18:04/33:04]     第一个步骤我们需要先确定和浏览器匹配的这样的一个jar版本是多少
[18:10/33:04]     然后第二个步骤呢
[18:11/33:04]     根据使用的操作系统去下载相应的一个Chrome driver
[18:17/33:04]     然后这个是需要注意的两个细节
[18:19/33:04]     我们现在打开我们的淘宝镜像
[18:23/33:04]     其实看官网也是可以的
[18:24/33:04]     但是如果没有那个翻墙软件的话
[18:27/33:04]     因为它是谷歌的链接
[18:28/33:04]     所以可能不好访问
[18:30/33:04]     建议大家直接去看我们的淘宝镜像就OK了
[18:33/33:04]     然后进入淘宝镜像之后呢
[18:35/33:04]     我们看到这么多个版本
[18:36/33:04]     那我们具体下载哪一个呢
[18:39/33:04]     不要直接去找下载哪个版本儿
[18:42/33:04]     是看和哪个和你的浏览器是匹配的
[18:45/33:04]     右边有三个点
[18:46/33:04]     我们点一下这儿有一个设置
[18:48/33:04]     进入谷歌浏览器设置之后呢
[18:50/33:04]     我们点一下关于Chrome在这儿
[18:52/33:04]     它有一个版本的一个提示
[18:54/33:04]     98.0.4758.102的一个版本
[18:58/33:04]     对吧
[18:59/33:04]     那接下来呢
[19:00/33:04]     我们就找一下有没有这个98这个版本
[19:05/33:04]     找一下98.0.4752.102 OK
[19:08/33:04]     就是这个版本
[19:09/33:04]     我们点进去我们发现
[19:11/33:04]     光这个Mac版本呢
[19:13/33:04]     他就有两个
[19:14/33:04]     一个是非M1的
[19:16/33:04]     大家根据自己的操作系统去进行选择
[19:18/33:04]     因为我是非M1
[19:19/33:04]     所以我就选择这个了
[19:20/33:04]     如果是M1的同学
[19:21/33:04]     一定要去选择M1
[19:23/33:04]     然后现在呢
[19:24/33:04]     我就下载成功了
[19:27/33:04]     然后现在呢
[19:28/33:04]     我就把它下载到了我的这个桌面上面
[19:33/33:04]     是这个一
[19:34/33:04]     是这个意
[19:35/33:04]     OK
[19:36/33:04]     然后这个时候呢
[19:37/33:04]     它是一个zip文件
[19:38/33:04]     这时候还不行
[19:39/33:04]     我们需要给他做一个解压
[19:40/33:04]     直接双击解压
[19:41/33:04]     解压完成之后出来一个这个Chrome driver
[19:44/33:04]     这个是我们所需要的那个Chrome driver啊
[19:48/33:04]     然后那个假压缩包可以给他删掉了
[19:51/33:04]     好
[19:52/33:04]     那这个时候
[19:53/33:04]     我们下载完成之后
[19:54/33:04]     我们再来看我们的第二个步骤
[19:56/33:04]     那第二个步骤呢
[19:57/33:04]     就需要我们去进行环境变量的一个配置
[20:00/33:04]     内环境变量配置呢
[20:02/33:04]     一共有这几个步骤
[20:04/33:04]     每一个步骤都需要注意
[20:06/33:04]     每个步骤都有它自己的一个细节
[20:08/33:04]     然后第一个步骤呢
[20:09/33:04]     是需要进入我们的一个终端
[20:12/33:04]     然后确认当前的一个shell环境
[20:15/33:04]     那使用的命令呢
[20:16/33:04]     是这个echo share
[20:17/33:04]     然后第二个步骤呢
[20:18/33:04]     是根据自己的shell环境去选择执行命令
[20:22/33:04]     如果是病
[20:24/33:04]     那么就选择vim.bash profile
[20:27/33:04]     如果是BSH
[20:29/33:04]     则VMZHRC
[20:30/33:04]     因为你使用不同的shell环境
[20:33/33:04]     去读取的这个环境变量
[20:34/33:04]     环境变量配置文件是不一样的
[20:37/33:04]     注意这一点
[20:39/33:04]     然后第三个步骤呢
[20:40/33:04]     我们需要在文件当中去添加这样的一个语句
[20:43/33:04]     然后把这个路径呢
[20:44/33:04]     替换成我们Chrome driver所在的一个路径
[20:47/33:04]     然后第四个步骤呢
[20:48/33:04]     就是重启我们的命令行工具
[20:52/33:04]     我们来一个一个实践一下
[20:53/33:04]     我们先完成第一个步骤和第二个步骤
[20:57/33:04]     我们打开我们的一个终端
[20:59/33:04]     然后这个时候呢
[21:01/33:04]     我给大家把我我给大家把前面的部分清一下
[21:08/33:04]     那这个时候呢
[21:09/33:04]     我们看一下我们当前的一个shell环境echo
[21:19/33:04]     这时候我们就可以看到我们使用的是兵败时这样的一个这样的一个这个这样的一个shell环境
[21:26/33:04]     那我们直接根据我们的PPT进行选择拜兵败势对吧
[21:31/33:04]     我们直接VM直接复制就完事了然后复制一下进去之后呢
[21:35/33:04]     我们发现
[21:36/33:04]     这个就是我们的一个环境变量的一个配置文件
[21:40/33:04]     然后这个是我之前
[21:42/33:04]     之前这个配置的一些
[21:43/33:04]     我给它删掉
[21:47/33:04]     然后接下来呢
[21:48/33:04]     我们就需要把我们的
[21:51/33:04]     我们就需要把我们的这个Chrome driver配置文件
[21:54/33:04]     然后给他的把它这个路径给他配置进来
[21:57/33:04]     那我们首先先看一下
[21:59/33:04]     首先我们现在空Java给他放在市桌面对吧
[22:03/33:04]     那放在桌面肯定是不行的
[22:05/33:04]     就是这样子不太好维护
[22:07/33:04]     那怎么办呢
[22:08/33:04]     我们可以进入我们的家目录
[22:10/33:04]     然后可以新建一个文件夹
[22:13/33:04]     比如说就叫做这个
[22:16/33:04]     比如说叫做歪不
[22:18/33:04]     Driver
[22:23/33:04]     我们名字长一点
[22:24/33:04]     Web driver Chrome
[22:26/33:04]     那这时候我们进入这样的一个路径
[22:28/33:04]     然后接下来我们把我们的Chrome driver给他拖进去
[22:31/33:04]     拖进去之后
[22:32/33:04]     我们一定要记得我们这个所在路径是什么
[22:35/33:04]     首先是在我们的家目录下面的一个叫做web driver Chrome这样的一个文件夹
[22:41/33:04]     那我们在终端里面
[22:43/33:04]     我们找到这样的一个路径
[22:45/33:04]     我们先给他退出出来
[22:48/33:04]     重新重新打开
[22:50/33:04]     重新进入
[22:54/33:04]     然后这时候我输入这个Chrome driver
[22:56/33:04]     大家可以看到
[22:57/33:04]     是没有任何的一个反应的
[22:58/33:04]     那这时候呢
[22:59/33:04]     我需要进入我们刚刚的一个配置文件的一个路径
[23:08/33:04]     找到我们的Chrome driver的地方
[23:12/33:04]     这时候我们在为了好方方便我们粘贴路径
[23:16/33:04]     我们可以再开
[23:17/33:04]     再开一个窗口
[23:18/33:04]     在这儿share这个新的窗口
[23:19/33:04]     然后然后这时候找到我们的一个
[23:23/33:04]     找到我们的一个那个QQ Java的一个所在路径
[23:26/33:04]     是不是我们的家目录
[23:28/33:04]     家目录就是这个波浪线线
[23:31/33:04]     我们就在家目录下面
[23:32/33:04]     我们LS一下
[23:33/33:04]     我们发现有这个web work room对吧
[23:35/33:04]     我们CD进去
[23:37/33:04]     这时候呢
[23:38/33:04]     我们LS一下
[23:39/33:04]     我们发现就有一个可执行文件Chrome driver对吧
[23:42/33:04]     那接下来我们就要把现在这个路径给他配入到我们的环境变量当中
[23:47/33:04]     然后我们PWD一下
[23:49/33:04]     这个就是我们现在的一个路径
[23:50/33:04]     我们给他
[23:51/33:04]     我们等一下就给他复制一下
[23:53/33:04]     然后这时候呢
[23:54/33:04]     我们需要先把我们的那个格式PPT里面这个export这个格式给它复制过来
[24:02/33:04]     复制过来之后呢
[24:03/33:04]     我们在这个地方
[24:05/33:04]     我给大家前面前后加个空行
[24:09/33:04]     复制过来之后呢
[24:10/33:04]     我们还需要把中括号儿这个地方替换成我们刚刚所生成的那个路径
[24:19/33:04]     注意别别删多了
[24:22/33:04]     一定要有冒号儿
[24:23/33:04]     就是你的这个pass后面一定是有冒号儿的
[24:26/33:04]     而且一定要这个Dollar pass
[24:27/33:04]     然后这个时候呢
[24:28/33:04]     我们就给它复制进来
[24:30/33:04]     复制进来之后我们摁退出键
[24:32/33:04]     然后冒号儿WQ保存一下环境变量配置文件
[24:36/33:04]     对吧
[24:37/33:04]     然后这时候呢
[24:38/33:04]     如果说我们输入Chrome driver
[24:41/33:04]     我们就会发现是是这个不能使用的
[24:44/33:04]     那这时候我们再把它关掉
[24:46/33:04]     这时候就则需要重启一下我们的终端
[24:50/33:04]     然后我们重新打开
[24:51/33:04]     然后输入
[24:56/33:04]     这儿这时候我们发现
[24:57/33:04]     我们是不是就给他配置成功了
[24:59/33:04]     那这个呢
[25:00/33:04]     就是我们Chrome driver在Mac上面的一个配置
[25:03/33:04]     然后回到我们的PPT
[25:05/33:04]     那最后一个步骤就是去验证一下我们的Chrome driver
[25:08/33:04]     如你在验证的这个过程当中呢
[25:11/33:04]     如果说没有出现截图这样的结果
[25:14/33:04]     或者跟刚刚演示一个结果
[25:16/33:04]     它提示的可能是不是命令或者什么之类的
[25:19/33:04]     那这个时候怎么去解决呢
[25:22/33:04]     那这个时候我们就要去检查一下是不是我们的这个环境变量配错了
[25:27/33:04]     或者说是不是我们忘记重启我们的一个终端啦
[25:33/33:04]     那我们看完这个Chrome driver的一个配置之后呢
[25:36/33:04]     我们再来看我们的这个这个driver
[25:39/33:04]     这个driver就是火狐浏览器的一个驱动的一个配置
[25:44/33:04]     它的步骤和我们前面都是一模一样的
[25:46/33:04]     第一步永远都是下载
[25:47/33:04]     第二步然后也是配置
[25:49/33:04]     然后第三步验证是否配置成功
[25:51/33:04]     那在这儿呢
[25:52/33:04]     只需要注意一点
[25:53/33:04]     就是这个这个这个driver呢
[25:56/33:04]     它是没有和Chrome driver类似的对应关系的
[25:59/33:04]     我们直接下载最新的就OK了
[26:01/33:04]     然后我们在新标签中打开
[26:04/33:04]     打开之后我们找到这个最新的
[26:05/33:04]     我们直接下
[26:06/33:04]     然后找到Mac版本
[26:08/33:04]     点一下Mac版本
[26:10/33:04]     然后桌面存储
[26:13/33:04]     和刚刚所有的操作都是一模一样的
[26:15/33:04]     然后下载完成之后
[26:17/33:04]     然后我们给他做一个解压
[26:24/33:04]     解压双击解压
[26:25/33:04]     解压之后我们要这个黑色的这个执行文件
[26:28/33:04]     然后同理
[26:30/33:04]     我们可以在这儿新建一个文件
[26:38/33:04]     叫做这个web driver
[26:44/33:04]     火狐firefox
[26:48/33:04]     然后呢
[26:49/33:04]     我们把这个driver给他丢进去
[26:53/33:04]     丢进去之后呢
[26:54/33:04]     我们统理
[26:55/33:04]     我们找到我们这个firefox这个文件夹
[26:59/33:04]     Web firefox
[27:01/33:04]     然后我们PWD一下
[27:03/33:04]     然后同理
[27:04/33:04]     我们现在给他去编辑一下
[27:06/33:04]     我们把这个路径先copy一下
[27:12/33:04]     我们还是新建一个窗口吧
[27:13/33:04]     这样好弄一点
[27:19/33:04]     这样子搞起来方便一点
[27:20/33:04]     然后现在呢
[27:21/33:04]     我们进入我们的一个flash profile环境
[27:26/33:04]     变量配置文件
[27:37/33:04]     我们给它加一个Chrome driver
[27:39/33:04]     然后同理
[27:40/33:04]     我们只需要把上面的这个部分给他复制一下
[27:44/33:04]     复制之后呢
[27:45/33:04]     注意啊
[27:46/33:04]     要改一下
[27:47/33:04]     要把后面这个改成这个firefox
[27:50/33:04]     那我们还是粘贴吧
[27:51/33:04]     它这个手动手敲还是比较容易出错的
[27:55/33:04]     直接粘贴
[28:02/33:04]     关掉关掉
[28:04/33:04]     正如我们输入
[28:07/33:04]     j Co driver杠杠version
[28:11/33:04]     输入这个信息
[28:12/33:04]     然后他这儿显示版本
[28:14/33:04]     就证明你已经配置成功了
[28:17/33:04]     那在这儿呢
[28:18/33:04]     其实我们不需要这么麻烦
[28:20/33:04]     不需要每一个刚刚呢
[28:22/33:04]     是为了让大家好理解
[28:24/33:04]     就是我们的这个
[28:26/33:04]     我们的这个driver的一个配置
[28:28/33:04]     是必须配置给他配置到这个环境变量文件当中去的
[28:31/33:04]     那其实我们需不需要每一个driver都给他配置一个文件呢
[28:36/33:04]     其实是不需要的
[28:37/33:04]     我们可以直接建一个叫做web driver的这样的一个文件
[28:40/33:04]     然后把它的这个这两个都给它挪过去
[28:44/33:04]     我们先拖到这里
[28:47/33:04]     然后这个可以删掉了
[28:51/33:04]     那这个也拖到桌面
[28:53/33:04]     然后它的这个文件夹也可以删掉了
[28:56/33:04]     然后我们直接两个全部放过来
[28:58/33:04]     然后放过来之后
[29:00/33:04]     注意一个细节
[29:01/33:04]     就是我们这时候还是要去改一下我们的环境变量配置文件
[29:04/33:04]     因为它们的路径变了嘛
[29:06/33:04]     所以说我们改一下
[29:10/33:04]     Perfect然后在这个地方呢
[29:13/33:04]     因为我们这两个路径已经全部删除了
[29:15/33:04]     我们只留一个就好了
[29:17/33:04]     只留一个
[29:18/33:04]     只要留一个路径出来
[29:20/33:04]     那其他的这个就是它这里面的配置
[29:23/33:04]     都会给它加载进去的
[29:24/33:04]     这个文件夹的名字叫做web driver好
[29:28/33:04]     然后这时候我们WQ一下
[29:30/33:04]     然后退出
[29:33/33:04]     这是我们直接输入数目指纹
[29:36/33:04]     然后发现没有问题
[29:37/33:04]     然后输入这个driver
[29:40/33:04]     你直接输这个driver
[29:42/33:04]     他是白的
[29:43/33:04]     你要加一个杠儿水
[29:46/33:04]     这个是他们这个两个driver之间不同的一个设置吧
[29:49/33:04]     然后在这儿呢
[29:50/33:04]     我们可以看到这个driver和Chrome driver就都配置成功了
[29:56/33:04]     在所有的环境都准备好之后
[30:00/33:04]     比如说我们的steam依赖
[30:01/33:04]     比如说我们的所有的浏览器驱动
[30:04/33:04]     我们的driver都配置好之后呢
[30:06/33:04]     我们来看一下它是如何和我们的Python代码结合起来去进行使用的
[30:10/33:04]     那我们的第一个步骤呢
[30:12/33:04]     就是先导入一下我们的C1拧包
[30:16/33:04]     然后后面会引用到
[30:17/33:04]     然后导入之后呢
[30:19/33:04]     我们会创建一个driver的一个实例
[30:22/33:04]     然后创建完成这个实力之后
[30:24/33:04]     我们可以使用java.get打开我们的这个网址
[30:27/33:04]     那最后一步呢
[30:28/33:04]     我们会关闭这个driver这个进程
[30:31/33:04]     然后浏览器也就会跟着关闭了
[30:34/33:04]     我们来尝试编写一下
[30:35/33:04]     那前面的步骤呢
[30:37/33:04]     我们都已经已经写过一遍了
[30:39/33:04]     所以说这个都没什么问题
[30:40/33:04]     那钱第一个步骤先打包
[30:42/33:04]     打完包之后呢
[30:44/33:04]     这个创建一个专业实力
[30:45/33:04]     然后打开浏览器
[30:46/33:04]     那最后我们再给他加一个quit的一个操作
[30:50/33:04]     那打开之后呢
[30:51/33:04]     它打开之后执行完上面的代码
[30:53/33:04]     它就会关掉浏览器了
[30:55/33:04]     好
[30:56/33:04]     那这时候我们来执行一下右键
[30:58/33:04]     运行
[31:02/33:04]     好
[31:03/33:04]     大家可以看到一闪而过
[31:06/33:04]     这是因为他在打开之后呢
[31:09/33:04]     很快就退出了
[31:10/33:04]     我们的这个Python脚本
[31:12/33:04]     是没有任何的一个问题的
[31:14/33:04]     中间没有任何的报错
[31:15/33:04]     对吧
[31:16/33:04]     那这个是我们在Chrome浏览器的一个应用
[31:20/33:04]     那我们接下来来看一下它和这个火狐浏览器的一个演示一个应用
[31:26/33:04]     那其实大家可以看到
[31:28/33:04]     所有的代码基本上都是一样的
[31:29/33:04]     只有这里有一点区别
[31:31/33:04]     就是这个位置
[31:32/33:04]     那之前呢
[31:33/33:04]     我们实例化的是一个Chrome的一个对象
[31:35/33:04]     那现在呢
[31:36/33:04]     我们要实例化的是一个firefox的这样的一个对象
[31:39/33:04]     我们来给大家做一个事例
[31:42/33:04]     我们在这里又见你
[31:45/33:04]     叫做
[31:47/33:04]     这个比如说我们叫他firefox
[31:53/33:04]     然后我们在这里统统里
[31:55/33:04]     我们第一个步骤先from swimming import driver
[32:00/33:04]     然后第二个步骤呢
[32:01/33:04]     创建一个a driver的一个实例
[32:03/33:04]     然后等于什么呢
[32:04/33:04]     等于我们的这个web driver点
[32:07/33:04]     然后firefox注意
[32:08/33:04]     一定要加括号儿
[32:10/33:04]     然后接下来呢
[32:11/33:04]     就是直接这个driver.get
[32:16/33:04]     我就直接复制前面这个测试人的这一行了
[32:19/33:04]     这一行是一模一样的
[32:20/33:04]     那这次我就不做quit操作了
[32:22/33:04]     就让他展示的久一点
[32:24/33:04]     然后我们右键运行一下
[32:26/33:04]     那这个时候按理来说
[32:28/33:04]     它就会掉起我们的一个火狐浏览器
[32:32/33:04]     并且进入到我们的一个测试的页面
[32:35/33:04]     这时候大家可以看到
[32:36/33:04]     是不是吊起我们的火狐浏览器
[32:38/33:04]     并且成功的进入到了我们的测试页面
[32:42/33:04]     那这一部分呢
[32:43/33:04]     就是我们后面的这个代码的一个演示的部分
[32:48/33:04]     那只要你能够成功的调起浏览器
[32:50/33:04]     并且打开网页
[32:51/33:04]     就证明
[32:52/33:04]     你的Chrome driver
[32:54/33:04]     你所有的这个web自动化应该要准备的环境就准备好了



### 2、自动化用例录制
[00:00/16:24]     [以下字幕均由机器生成]我们要学习的内容是selenium IDE的用力录制
[00:05/16:24]     在自动化测试的过程当中
[00:06/16:24]     阿斯蒂尼姆提供给我们的一种方式是非常适用于刚开始学习自动化测试以及对于没有任何代码基础的一个同学
[00:16/16:24]     它可以通过录制回放的一个方式呢
[00:19/16:24]     自动生成UI自动化测试脚本
[00:22/16:24]     那我们点击一下这个selenium IDE
[00:26/16:24]     然后这个呢
[00:27/16:24]     就是我们这个steam ID的一个样子
[00:30/16:24]     那后面会给大家去进行一个具体的一个实操
[00:34/16:24]     那就是我们的一个录制工具
[00:37/16:24]     那我们接下来看一下斯利姆埃地用力录制的一个使用场景是什么
[00:41/16:24]     那既然这个工具听上去很很感觉很万能
[00:44/16:24]     对吧
[00:45/16:24]     感觉很厉害很强
[00:47/16:24]     那他的一个局限信用是什么
[00:50/16:24]     首先我们先来说一下它适用的地方
[00:52/16:24]     所以你们ID呢
[00:54/16:24]     它适用于谁呢
[00:55/16:24]     它适用于一些刚开始入门UES的话
[00:57/16:24]     测试的一些同学
[00:59/16:24]     还有第二个呢
[01:00/16:24]     它是适用
[01:01/16:24]     适用的一个场景是
[01:02/16:24]     比如说你们的团队现在要去构建这个UES的话
[01:07/16:24]     那你们整个团队的一个代码基础又比较差
[01:10/16:24]     这时候从头开始学会比较麻烦
[01:12/16:24]     那这时候也可以去借助这个CMID去进行一个用例录制
[01:17/16:24]     然后脚本的一个维护等等
[01:19/16:24]     但是呢
[01:20/16:24]     与此同时啊
[01:21/16:24]     它也具有它的一个局限性
[01:24/16:24]     就是比如说我们的这个USB动画测试
[01:27/16:24]     它最大的一个问题呢
[01:28/16:24]     就是它的这个代码的一个变化比较快
[01:31/16:24]     然后脚本比较难以维护
[01:33/16:24]     那其实selenium IDE呢
[01:34/16:24]     他也并不能很好的去解决这个问题
[01:38/16:24]     在大家技术成长了之后
[01:41/16:24]     他的一个学习价值
[01:43/16:24]     就没有那么高了
[01:44/16:24]     他倒出来的脚本可能塑性其实不是很强
[01:50/16:24]     但是呢
[01:51/16:24]     对于一些刚开始入门去学习UI自动化测试呢
[01:54/16:24]     可能会帮助一些刚开始入门的同学更好地去理解USB文化形式
[02:01/16:24]     OK
[02:02/16:24]     就是斯蒂姆ID的一个使用场景吧
[02:07/16:24]     好
[02:08/16:24]     那我们看完使用场景之后
[02:09/16:24]     我们接下来看一下它是如何去进行安装的
[02:12/16:24]     那安装呢
[02:14/16:24]     在这儿给大家讲两种方式
[02:15/16:24]     其实CINEID他就是浏览器上面的一个插件
[02:19/16:24]     我们就使用插件安装的方式去进行安装就可以了
[02:23/16:24]     那谷歌浏览器呢
[02:24/16:24]     大家可以打开这个链接
[02:31/16:24]     我这是已经安装了
[02:32/16:24]     我先把它卸载掉
[02:35/16:24]     OK
[02:36/16:24]     然后我现在已经卸载成功了
[02:37/16:24]     那大家正常如果进来的话呢
[02:39/16:24]     是这个页面
[02:40/16:24]     然后我们点击一下ADD to prove
[02:42/16:24]     然后点击添加扩展程序
[02:45/16:24]     但是在这里大家需要注意的是
[02:49/16:24]     大家一定是要可以翻墙
[02:51/16:24]     然后有代理工具
[02:53/16:24]     你们才可以访问到Chrome的一个web store的一个页面的如果说没有代理工具的话呢
[02:59/16:24]     可以后面去使用这个服务去进行练习
[03:02/16:24]     然后这样子呢
[03:03/16:24]     我们的这个插件呢
[03:04/16:24]     就安装好是不是非常简单
[03:08/16:24]     那我们再来看一下这个火狐
[03:10/16:24]     那火狐他对网络就没有任何的一个限制啦
[03:13/16:24]     大家也可以是安装这个火狐的插件也是OK的
[03:18/16:24]     然后我们在这里呢
[03:19/16:24]     进入来之后呢
[03:20/16:24]     我们选择download
[03:31/16:24]     我们直接进入它的一个插件的一个地址就OK了
[03:34/16:24]     进入我们的火狐浏览器
[03:42/16:24]     然后复制这个链接进来
[03:43/16:24]     然后在这儿呢
[03:44/16:24]     我们也是直接点击这个ADD to firefox就安装好了
[03:49/16:24]     ADD to firefox
[03:54/16:24]     然后在这儿它有一个弹窗
[03:57/16:24]     我们点击添加
[03:58/16:24]     点击好的
[03:59/16:24]     那这时候我们就可以看到右上角有一个C开头的这样的一个浏览器
[04:04/16:24]     对不对
[04:05/16:24]     那这时候我们点一下它
[04:07/16:24]     点一下它呢
[04:08/16:24]     这个就是我们c LIM ID的一个插件的一个使用
[04:14/16:24]     OK
[04:15/16:24]     那我们现在呢
[04:16/16:24]     这个下载安装非常简单
[04:18/16:24]     然后大家就使用这个插件的方式
[04:21/16:24]     那可能有一些同学还有其他浏览器的需求
[04:24/16:24]     然后大家可以自行在这个PPT查找
[04:27/16:24]     好
[04:28/16:24]     那接下来我们来看一下它是如何去进行启动
[04:32/16:24]     它如何去进行启动
[04:34/16:24]     那在安装完成之后呢
[04:35/16:24]     大家可以通过浏览器的菜单栏点击它的图标来启动它
[04:40/16:24]     如果说你的图标没有自动显示出来了
[04:42/16:24]     你在这儿点一个
[04:44/16:24]     这儿有一个叫做扩展程序的地方
[04:46/16:24]     你点一下它
[04:48/16:24]     点一下它之后呢
[04:49/16:24]     在这儿你们就可以找到这个steam的ID
[04:52/16:24]     然后我们点击一下
[04:54/16:24]     这时候我们就可以看到
[04:56/16:24]     我们就成功地启动了
[04:57/16:24]     那如果说大家就是在这个地方以及你们点开这儿都没有看到这个skinny麦迪的图标呢
[05:04/16:24]     那你们就需要去确保一下是否安装了这个插件那这个那这个谷歌呢
[05:11/16:24]     他就可以通过这个更多工具
[05:13/16:24]     点击扩展程序这里看到你所安装的一些插件信息
[05:18/16:24]     大家可以看到我们这的司机
[05:20/16:24]     你ID是已经成功安装上去了
[05:24/16:24]     好
[05:25/16:24]     那接下来我们成功的启动之后呢
[05:27/16:24]     我们来看一下死鱼你ID有哪些常用功能呢
[05:31/16:24]     首先第一个呢
[05:32/16:24]     就是它的这个新建保存和打开
[05:34/16:24]     在我们的图片上面也有一个对应的一个关系
[05:38/16:24]     然后第二个呢
[05:39/16:24]     是他比较核心的一个功能
[05:40/16:24]     就是开始和停止录制
[05:42/16:24]     然后第三个是运行这个吧
[05:45/16:24]     这个列表里面当中所有的一个用力的
[05:48/16:24]     然后四呢
[05:49/16:24]     就是这个三旁边的这个按钮是运行单个的一个用力的
[05:54/16:24]     第五个是调试模式
[05:55/16:24]     第六个第七个
[05:57/16:24]     然后在这里我们重点需要关注的是这个
[06:01/16:24]     第七个往后吧
[06:02/16:24]     就是比如说第七个是你要录制的网址是什么
[06:05/16:24]     然后第八个是实力的一个列表
[06:08/16:24]     第九个是动作目标的值
[06:12/16:24]     第十个是对单条命令的一个解释
[06:15/16:24]     第11就是日志的一个运行
[06:21/16:24]     那接下来我们来看一下它是如何去进行使用的
[06:24/16:24]     我们打开我们的这个C0ID
[06:30/16:24]     我们首先呢
[06:31/16:24]     先去选择这个create就OK了
[06:34/16:24]     比如说我们给的叫做DEMO
[06:37/16:24]     好
[06:38/16:24]     那这时候呢
[06:39/16:24]     我们点击一下这个X老师开始录制
[06:42/16:24]     那我们录制的对象呢
[06:43/16:24]     就是我们自己的一个测试论坛
[06:50/16:24]     找到我们的IDE
[06:53/16:24]     输入进去
[06:54/16:24]     点击start recording
[06:56/16:24]     这时候我们可以看到右下角有一个selenium IDE is reporting是不是大家可以看到
[07:01/16:24]     在右下角这里鼠标放回去就消失了然后在这里呢
[07:07/16:24]     我们是不是可以这个随便点一个帖子
[07:10/16:24]     比如说我们点击热门
[07:12/16:24]     随便切换一下
[07:13/16:24]     点击一下热门
[07:15/16:24]     然后这时候呢
[07:16/16:24]     我们再打开我们的这个selenium IDE
[07:22/16:24]     直接给他放上面
[07:23/16:24]     然后这时候呢
[07:24/16:24]     我们点击一下停止
[07:27/16:24]     然后给它取个名字
[07:28/16:24]     比如说叫测试人
[07:30/16:24]     好
[07:31/16:24]     那这个时候呢
[07:32/16:24]     我们给他做一个回放
[07:34/16:24]     那怎么回放呢
[07:35/16:24]     我们直接run current test就OK了
[07:44/16:24]     大家可以看到它从这个日志上面我们是可以看到每一个步骤都是成功的
[07:49/16:24]     但是他可能比较快
[07:50/16:24]     大家看得没那么清楚
[07:53/16:24]     那在这里呢
[07:54/16:24]     我除叻通过录制之外呢
[07:56/16:24]     我们还可以在录制脚本当中插入一些这个恶插入手动插入一些别的信息
[08:02/16:24]     比如说我们想给他加等待
[08:04/16:24]     你就选择这个pass
[08:05/16:24]     然后我们给他等待五千五千就是五秒的意思五秒的意思
[08:11/16:24]     这时候我们再执行一下
[08:18/16:24]     这时候我们就可以看到它是不是切换到我们热门的这样的一个标签去了
[08:23/16:24]     然后这个呢
[08:24/16:24]     就是我们的单个用力的一个使用
[08:26/16:24]     那我们可以再去新建一个用力
[08:29/16:24]     比如说就是测试二
[08:30/16:24]     请添加一下
[08:32/16:24]     然后在这个时候呢
[08:33/16:24]     我们还是通过录制的方式去获得
[08:37/16:24]     然后我们选择去到这个精华帖吧
[08:43/16:24]     OK
[08:46/16:24]     现在就录制完成了
[08:47/16:24]     然后同样
[08:48/16:24]     打开我们in ID
[08:50/16:24]     选择这个stop
[08:51/16:24]     然后之后我们是不是录制了两条用力
[08:54/16:24]     是不是录制了两条用力
[08:55/16:24]     然后呢
[08:56/16:24]     我们可以选择这个给他去做一个批量的一个执行
[09:03/16:24]     那为了能够让大家看到我们俩条用力比较清晰的一个执行过程
[09:08/16:24]     我们同样在第二条用力这里给它加一个加一个pass
[09:12/16:24]     那也是挣到5000
[09:15/16:24]     然后这个时候呢
[09:18/16:24]     我们这两条用力
[09:19/16:24]     我们就都可以给他一块儿执行
[09:22/16:24]     然后这个最左边这里有一个run all tests就是执行所有的用力
[09:27/16:24]     我们点击它
[09:29/16:24]     现在它就会执行我们的第一条
[09:31/16:24]     用力应该是进入我们的热门
[09:38/16:24]     等待秒
[09:39/16:24]     OK好
[09:41/16:24]     现在执行我们的第二条
[09:44/16:24]     这时候大家就可以看到
[09:45/16:24]     他去点击了我们的精华帖对吧
[09:50/16:24]     这个时候呢
[09:51/16:24]     我们就可以看到它整个的一个执行过程
[09:54/16:24]     执行完成之后呢
[09:56/16:24]     它就会自动的这个给我们显示出来这个插件
[10:00/16:24]     然后在这个地方呢
[10:01/16:24]     我们也可以看到每个步骤它都有它的一个这个日志
[10:05/16:24]     然后我们可以看到刚刚我们运行了两条用力对不对
[10:10/16:24]     然后rein CE是人软测试人二
[10:13/16:24]     那这个呢
[10:14/16:24]     就是selenium IDE的一个录制的一个使用
[10:20/16:24]     那除此之外呢
[10:21/16:24]     我们除了添加test之外呢
[10:23/16:24]     我们还可以去给他添加这个test SE ti
[10:29/16:24]     我们还可以切换到这个台词suki
[10:31/16:24]     那这个酥的呢
[10:32/16:24]     它其实就是用立即的意思
[10:35/16:24]     那比如说我们进入到我们的city
[10:37/16:24]     然后在这儿有一个default
[10:38/16:24]     然后我们可以在这个地方呢
[10:40/16:24]     给它选择这个添加
[10:42/16:24]     然后我们把两条用力都给它添加进来
[10:45/16:24]     都给它添加进来
[10:47/16:24]     然后这时候我们整个苏体就添加成功了
[10:50/16:24]     然后这个呢
[10:51/16:24]     就是我们苏体的一个使用
[10:53/16:24]     然后也也是可以执行这个run all test in实体就是当前这个suki下面就是当前这个用例集下面的一个所有的一个用力
[11:05/16:24]     那执行这个过程
[11:06/16:24]     和我们刚刚的那个过程是差不多的
[11:25/16:24]     那大家现在可以看到和我们刚刚那条
[11:27/16:24]     因为都是两条同样的用力嘛
[11:29/16:24]     所以它执行起来肯定是一样的
[11:31/16:24]     那这个素体呢
[11:32/16:24]     它可以更好的帮助我们去管理我们的一个用例文件
[11:38/16:24]     就是这个司令你们ID的一些基本的一些使用
[11:43/16:24]     包括一些保存等等
[11:45/16:24]     就不会讲那么细啦
[11:46/16:24]     因为这个东西建议大家不要投入太多的时间
[11:50/16:24]     简单了解一下就OK了
[11:52/16:24]     简单跟着我实操一下就行
[11:55/16:24]     然后除了这些功能之外呢
[11:57/16:24]     他还有这个导出为脚本的一个功能
[12:00/16:24]     然后我们在这里呢
[12:01/16:24]     可以选择这个ex ports
[12:03/16:24]     点击export
[12:05/16:24]     然后这时候我们就可以看到什么
[12:06/16:24]     就可以看到选择语言
[12:10/16:24]     然后有peasant有Java对不对
[12:13/16:24]     这个是他的export
[12:16/16:24]     那同样
[12:17/16:24]     除了我们单个的用力可以导出之外呢
[12:20/16:24]     我们的用例集也是可以导出的
[12:22/16:24]     比如说我现在切换的素体模式
[12:25/16:24]     然后我在这儿选择ex ports
[12:27/16:24]     然后也是可以选择语言的
[12:29/16:24]     和刚刚都是差不多的
[12:31/16:24]     这一部分呢
[12:32/16:24]     就是selenium IDE在界面操作上的一些使用
[12:36/16:24]     那接下来我们看一下这个steam ID啊
[12:42/16:24]     他导出脚本应该是什么样子比如说我们现在使用这个taxi
[12:46/16:24]     我们给它导出成这个Python的一个脚本
[12:50/16:24]     在这儿选择这个导出ex ports
[12:53/16:24]     导出成这个Python脚本
[12:59/16:24]     导出到你的桌面
[13:03/16:24]     大家可以看到
[13:04/16:24]     导出的呢
[13:05/16:24]     就是一个PY文件
[13:07/16:24]     那现在呢
[13:08/16:24]     我们把这个PY文件打开
[13:11/16:24]     嗯
[13:40/16:24]     现在打开之后呢
[13:41/16:24]     我们就可以看到
[13:42/16:24]     如果前面有学习过这个
[13:45/16:24]     有学习过这个
[13:47/16:24]     Python这个同学应该都可以看到
[13:49/16:24]     直接导出来一个测试类
[13:52/16:24]     然后测试类里面有这个初始化的一些方法
[13:55/16:24]     然后有其他的一些用力的一个执行
[13:58/16:24]     然后他这个time to sleep pass5在那边是5000
[14:02/16:24]     他直接在这儿也换成5000啦
[14:03/16:24]     我们改一下改成
[14:08/16:24]     然后这时候呢
[14:09/16:24]     我们执行一下这个用力
[14:11/16:24]     看看能不能够跑得通
[14:13/16:24]     前提是您的本地都已经配置好这个steam的一些相关的环境啦
[14:18/16:24]     这些包都在我的本地
[14:19/16:24]     Python都已经配置好了
[14:20/16:24]     包括这个com driver也已经配置好了
[14:41/16:24]     这时候我们执行一下我们的用力
[15:01/16:24]     他是不是就点到了热门
[15:05/16:24]     OK
[15:06/16:24]     第一个用力已经执行完成了
[15:27/16:24]     第二个用力呢
[15:28/16:24]     我们也执行完成了
[15:29/16:24]     这两个用力呢
[15:30/16:24]     就全部都执行成功了
[15:33/16:24]     从这儿我们就可以看出来
[15:35/16:24]     阿斯蒂你IDE它可以很方便的和我们相关的一些编程语言做一个关联
[15:41/16:24]     可以和我们的Python
[15:43/16:24]     可以和我们的Java
[15:44/16:24]     可以很顺畅的导出我们的这个脚本
[15:47/16:24]     那以上呢
[15:48/16:24]     就是selenium IDE的一些常用的一个用法
[15:52/16:24]     那我们回顾一下
[15:53/16:24]     我们回顾一下
[16:03/16:24]     那我们在这个章节学习哪些知识点呢
[16:04/16:24]     学习了steam ID的一些基础的界面上的一些操作
[16:10/16:24]     以及如何去导出脚本
[16:11/16:24]     对吧
[16:12/16:24]     那其实这两个呢
[16:13/16:24]     就是selenium最核心的两个功能
[16:15/16:24]     大家只要跟着我去演示一遍就OK了
[16:19/16:24]     好
[16:20/16:24]     那我们这节课就到这里啦



### 4、自动化测试用例结构分析
[00:00/14:34]     [以下字幕均由机器生成]在这一章节呢
[00:01/14:34]     [以下字幕均由机器生成]我们要学习的内容
**[00:03/14:34]     就是自动化测试用例结构分析**
[00:06/14:34]     好
[00:07/14:34]     我们本科章节呢
[00:08/14:34]     会分为三个部分给大家进行讲解

![image-20221211213018389](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211213018389.png)[00:10/14:34]     我们先来分析
[00:11/14:34]     我们先来看一下一个标准的用力

![image-20221211213047590](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211213047590.png)[00:13/14:34]     它应该有它的结构
[00:14/14:34]     应该有哪些内容
[00:16/14:34]     就是我们一句我们前面所录制的这样的一个用例呢
[00:21/14:34]     我们对这个录制的用例进行一个简单的分析
[00:24/14:34]     那分析完成之后呢
[00:25/14:34]     我们会发现
[00:26/14:34]     这个用力录制的用力
[00:27/14:34]     它还存在一些结构上的问题
[00:30/14:34]     那我们再针对这些结构上的问题给他做一定的优化
[00:36/14:34]     我们先来看一个标准的功能测试用例的这样的一个结构是什么
[00:40/14:34]     那我在右边呢
[00:41/14:34]     写了一个简单的这样的一个功能测试用例
[00:44/14:34]     它对应过来的呢
[00:45/14:34]     就是一个搜狗的搜索功能
[00:47/14:34]     对吧
[00:48/14:34]     那它这个这条用例呢
[00:50/14:34]     比如说他会有什么
[00:52/14:34]     他会有类型
[00:53/14:34]     比如说他是一个正立还是一个返利
[00:55/14:34]     那他会有什么呢
[00:56/14:34]     还会有前提条件
[00:58/14:34]     那它对应的前提条件可能是我们首先呢
[01:00/14:34]     要先进入到我们搜狗的首页
[01:02/14:34]     那它对应的用例步骤呢
[01:03/14:34]     第一个步骤就是输入搜索的这样的一个关键词
[01:06/14:34]     第二个步骤呢
[01:07/14:34]     就是需要按一下我们的回车键
[01:10/14:34]     或者点击搜索的一个按钮
[01:12/14:34]     那用例步骤就是我们在实际测试过程当中
[01:16/14:34]     对于这个用例场景的执行的每一个具体的步骤
[01:20/14:34]     那除了这个之外呢
[01:21/14:34]     还有一个叫做预期结果
[01:22/14:34]     就是说我们执行完成这个用例之后呢
[01:25/14:34]     我们希望他达成一个什么样子
[01:28/14:34]     还有最后一个叫做实际结果
[01:30/14:34]     那实际结果就是我们实际在测试的过程当中
[01:33/14:34]     真实获取到的结果是什
[01:35/14:34]     然后OK
[01:37/14:34]     那如果说预期结果和实际结果不一致
[01:39/14:34]     那很明显
[01:40/14:34]     这条用例就是相当于测出bug来了
[01:42/14:34]     对吧
[01:44/14:34]     那从这儿呢
[01:46/14:34]     这条用例具体他做了什么
[01:48/14:34]     这不是我们关注的重点
[01:50/14:34]     而是我们要从这条用例里面反推出来
[01:53/14:34]     我们一个标准的用力结构
[01:54/14:34]     至少要包含几大要素
[01:56/14:34]     那从这我们可以看出来
[01:57/14:34]     我们这个标准用力结构至少要包含比如有用力标题
[02:03/14:34]     前提条件
[02:04/14:34]     用例步骤
[02:05/14:34]     预习结果和实际结果这五大要素
[02:07/14:34]     对吧
[02:08/14:34]     那这五大要素呢
[02:09/14:34]     大家可以看到少一个类型
[02:11/14:34]     这个原因是因为类型就是在整个的用力结构里面呢
[02:15/14:34]     它不属于一个
[02:16/14:34]     它不属于一个必须要有的这样的一个元素
[02:20/14:34]     我有没有都可以
[02:22/14:34]     好
[02:23/14:34]     那接下来我们再来看一下前面我们看到的这个功能用力之后
[02:27/14:34]     我们再来看一下自动化测试用例

![image-20221211213138168](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211213138168.png)[02:29/14:34]     那自动化测试用例呢
[02:30/14:34]     基本和我们的功功能测试用例这个结构是一致的
[02:35/14:34]     它也有用力标题
[02:36/14:34]     前提条件
[02:37/14:34]     用例步骤
[02:38/14:34]     实际结果
[02:39/14:34]     他和这个功能用例里阿比起来呢
[02:42/14:34]     他还体现出来一点
[02:43/14:34]     就是它需要有一个这样的一个后置动作
[02:46/14:34]     我们再来看一下在自动化测试用例里面
[02:49/14:34]     它的对应的这些要素
[02:52/14:34]     然后它对应的具体的内容是什么
[02:54/14:34]     以及它的作用是什么
[02:56/14:34]     首先我们先来看用力标题
[02:58/14:34]     用力标题是什么呢
[02:59/14:34]     比如说我的这条用例
[03:01/14:34]     我所在的测试的package在哪
[03:03/14:34]     文件对应的是什么类对应的是什么方法名称对应的是什么
[03:07/14:34]     通过这几项
[03:09/14:34]     我们加起来就可以构成一个这个独一无二的一个用例标题就是他的一个唯一标示吗
[03:15/14:34]     但它的作用呢
[03:16/14:34]     就是我们用力的一个唯一标识
[03:18/14:34]     比如说我们在搜索用力的过程当中
[03:20/14:34]     我们就可以通过这些
[03:22/14:34]     素给他搜索出来
[03:23/14:34]     然后还有前提条件
[03:26/14:34]     那在自动化测试用例里面的前提条件呢
[03:28/14:34]     它通常是会放在比如说在setup setup class
[03:33/14:34]     这个叫做拍text里面
[03:35/14:34]     他叫setup setup class
[03:37/14:34]     那在职油腻型里面呢
[03:38/14:34]     他可能是叫before each before all对吧
[03:43/14:34]     那这一部分呢
[03:44/14:34]     就是它的一个前提条件
[03:45/14:34]     那这一部分它对应的一个作用
[03:47/14:34]     就是一个测试用例
[03:48/14:34]     测试用例执行前的一些准备动作
[03:51/14:34]     比如说我们在执行自动化测试用例的时候
[03:54/14:34]     需要先进行数据的读取
[03:56/14:34]     或者进行一个driver初始化等等
[03:58/14:34]     然后第三个部分呢
[04:01/14:34]     就是我们用力的一个具体的一个步骤
[04:03/14:34]     那它对应的过来对应我们自动化测试用例的一个模块呢
[04:07/14:34]     其实就是我们测试方法里面的代码逻辑
[04:10/14:34]     比如说套用在我们的接口自动化里面
[04:12/14:34]     他可能就是
[04:13/14:34]     你调了哪一些接口
[04:14/14:34]     那阿汤在我们US动画里面呢
[04:18/14:34]     可能就是你在哪个页面
[04:19/14:34]     然后做了哪些点击
[04:20/14:34]     做了哪些输入
[04:21/14:34]     对吧
[04:22/14:34]     那他做了
[04:23/14:34]     就是我们其实和我们的功能测试试用用例是一样的
[04:27/14:34]     就是我们这一整条测试用例
[04:29/14:34]     它对应具体的一个步骤行为有哪一些
[04:32/14:34]     然后接下来还有是什么呢
[04:35/14:34]     就是它的一个预期结果和实际结果
[04:38/14:34]     在自动化测试里面呢
[04:39/14:34]     这个预期结果和实际结果
[04:41/14:34]     通常都是绑定在一起的
[04:42/14:34]     为什么
[04:43/14:34]     因为他要去写一个断言信息
[04:47/14:34]     那比如说他的一个assert可能就是去判断实际结果是否等
[04:52/14:34]     是否等于等于这儿写
[04:54/14:34]     这儿应该再写一个等于等于
[04:56/14:34]     就是双等于号是否和这个预习结构相等
[05:00/14:34]     那它的一个作用呢
[05:01/14:34]     就是去印证我们的这个自动化测试用例是否执行成功
[05:05/14:34]     然后除了这些之外呢
[05:08/14:34]     还有我们的一个后置动作
[05:09/14:34]     比如说对应在我们拍它里面就是tear down he tear down class
[05:13/14:34]     然后在结构类型里面呢
[05:14/14:34]     就可能有after each after all等等
[05:16/14:34]     然后这个后置动作
[05:18/14:34]     通常对应在自动化测试里面
[05:21/14:34]     他会做一些脏数据的清理
[05:22/14:34]     或者说关闭一些进程等等的一系列的操作
[05:27/14:34]     其实就是我们自动化测试用例它的一个通常来说的几大要素
[05:32/14:34]     也就是我们常说的一个标准结构
[05:34/14:34]     大家可以看到
[05:35/14:34]     那其实自动化测试用例和我们的功能测试用例
[05:38/14:34]     基本上是如出一辙的
[05:42/14:34]     没有什么太大的一个区别
[05:44/14:34]     好
[05:45/14:34]     那这时候我们了解完这个自动化测试用例他弟几大要素之后
[05:49/14:34]     用力标题前提条件用例步骤断言
[05:53/14:34]     那我这时候说断言呢
[05:54/14:34]     就代表的是预习结果加实际结果的一个对比
[05:57/14:34]     我们叫做他断言
[06:00/14:34]     还有我们的一个后置动作
[06:01/14:34]     那这时候呢
[06:03/14:34]     我们以一个真实的脚本来做一个分析
[06:06/14:34]     那这个真实的脚本呢
[06:07/14:34]     就是我们在上一节课使用idea去录制的这样的一个脚本
[06:10/14:34]     好
[06:11/14:34]     那我们来看一下他的一个代码对应的是什么
[06:14/14:34]     那这个脚本我当时录制的一个步骤呢
[06:17/14:34]     是首先先访问这个搜狗的一个首页
[06:20/14:34]     然后在搜狗输入框输入霍格沃兹测试开发
[06:23/14:34]     然后点击搜索按钮
[06:25/14:34]     那他整个的这个idea录制的这个过程我就不做演示了
[06:28/14:34]     我直接把他这个脚本吧
[06:30/14:34]     下来我们来看一下它这个脚本
[06:33/14:34]     是否符合
[06:35/14:34]     我们前面所说的自动化测试用例的几大要素
[06:39/14:34]     那首先呢
[06:40/14:34]     他是不是有它独特的一个这个类名
[06:42/14:34]     然后它还有它独特的
[06:44/14:34]     这样的一个方法名
[06:46/14:34]     所以说我们的这个用例标题是不是就有了
[06:50/14:34]     我把这个几大要素直接这个放到我们的旁边来
[06:59/14:34]     好
[07:00/14:34]     从刚刚我们可以看到
[07:01/14:34]     这个用例标题我们是有的
[07:03/14:34]     那接下来我们先来看一下它是否包含对应的一个前提条件
[07:09/14:34]     那我们来看
[07:10/14:34]     我们常说的这个前提条件
[07:12/14:34]     可能就是我们setup里面的一个内容
[07:18/14:34]     那在这个setup当中呢
[07:19/14:34]     我们就可以看到他做了一个driver的一个初始化
[07:24/14:34]     所以他的这个idea录制这个脚本呢
[07:26/14:34]     他也是包含我们的一个用力的一个前置动作的
[07:30/14:34]     那除了前提条件之外呢
[07:32/14:34]     它有没有体现出来我们的用例步骤
[07:34/14:34]     就比如说我们这个测试用例里面具体的一些行为步骤
[07:37/14:34]     那它对应的呢
[07:38/14:34]     就是我们测试方法代码类的逻辑
[07:41/14:34]     我们来看一下
[07:42/14:34]     这是它的一个测试方法
[07:44/14:34]     是不是有打开网页
[07:45/14:34]     输入搜索信息
[07:46/14:34]     点击搜索等等的一系列步骤
[07:48/14:34]     这个也是有的OK
[07:49/14:34]     那这时候我们可以看到
[07:50/14:34]     那是否有预习结果呢
[07:52/14:34]     我们这时候看一下预习结果和实际结果
[07:55/14:34]     也就是我们断言的一个体现
[07:58/14:34]     我们发现是不是这个用力
[08:00/14:34]     他还缺少我们的一个断言的一个信息好
[08:04/14:34]     那这个呢
[08:05/14:34]     后面我们会给他去做一个优化
[08:07/14:34]     我们继续往后看来一个一个去做验证
[08:09/14:34]     这是我们再来看它是否具有这个后置动作
[08:14/14:34]     这个后置动作就是会做一些招ER进程的关闭
[08:17/14:34]     或者数据清理等操作
[08:19/14:34]     我们来看录制出来的OK也是有的
[08:22/14:34]     我们现在这个idea录制这个脚本
[08:25/14:34]     他的整个的这个用力的元素是有的有有的没有
[08:29/14:34]     那我们来看一下在这个脚本基础之上
[08:32/14:34]     我们可以怎么样去对它进行优化
[08:35/14:34]     那这时候呢
[08:36/14:34]     回到我们的这个脚本这个页面
[08:39/14:34]     我就是刚刚把PPT这个脚本coffee在这里
[08:41/14:34]     然后大家也可以跟我一样
[08:43/14:34]     直接扣费我们PPT里面的脚本
[08:45/14:34]     好
[08:46/14:34]     那这时候我们先来运行一下这个脚本
[08:49/14:34]     看看能不能够成功的运行
[08:51/14:34]     我们发现能够成功的运行对吧
[08:53/14:34]     那这时候我们会发现有这样的一个问题
[08:55/14:34]     就是我们其实并不知道
[08:57/14:34]     就是它的就是这个断言对吧
[09:00/14:34]     我们并我不我们并不能知道这条用例是执行成功还是执行失败
[09:07/14:34]     来我们先说一下问题
[09:09/14:34]     问题无法确定
[09:13/14:34]     用例执行成功或失败
[09:17/14:34]     那解决方案是什么呢
[09:19/14:34]     解决方案添加断言信息好
[09:24/14:34]     那接下来我们来看一下我们应该如何去添加这样的一段信息
[09:28/14:34]     那这时候她是所做的一个操作呢
[09:30/14:34]     就是输入或郭子测试开发
[09:33/14:34]     那我们要做的一个这个判断就是
[09:37/14:34]     判断搜索
[09:41/14:34]     列表中是否含有
[09:46/14:34]     这个
[09:48/14:34]     霍格沃斯测试开发好的
[09:51/14:34]     那这时候呢
[09:52/14:34]     我们进入到我们那个搜狗的这样的一个页面
[10:04/14:34]     我们就以这个全部为以这个为例
[10:07/14:34]     我们输入霍格沃兹测试开发
[10:11/14:34]     然后接下来我们要判断这个列表里面
[10:15/14:34]     是否有我们搜索的这个对应的一个关键词
[10:18/14:34]     好
[10:19/14:34]     那这时候我们来找一下
[10:20/14:34]     我们发现好像是正好呢
[10:23/14:34]     它有一个叫做M的这样的一个标签
[10:27/14:34]     然后我们就可以定位到他对应的一个关键字
[10:32/14:34]     那这时候我们来怎么样去做判断呢
[10:34/14:34]     比如说我们来找第一条里面的所有的一个这个文本信息吧
[10:40/14:34]     我们来找一下它的一个a标签
[10:43/14:34]     我们直接尝试复制一下吧
[10:45/14:34]     Copy
[10:48/14:34]     Copy element
[10:51/14:34]     那这时候呢
[10:53/14:34]     我们直接这个让这个result element就等于一个self店driver典范element
[11:00/14:34]     然后我们这里使用的是一个
[11:05/14:34]     我刚忘记了我怎么copy的
[11:07/14:34]     Copy
[11:09/14:34]     我们在这儿应该是选择一个定位方法
[11:12/14:34]     具体定位方法我们后面讲
[11:13/14:34]     大家只要跟着我操作型
[11:15/14:34]     比如说我们copy exact or
[11:18/14:34]     然后我们用CS
[11:19/14:34]     大家前面先照猫画虎
[11:22/14:34]     我们后面会大家去做详细的这样的一个讲解
[11:26/14:34]     好那这时候呢
[11:27/14:34]     我们怎么样拿到它一个文本信息呢
[11:30/14:34]     获取到定位
[11:32/14:34]     这个后面也都会给大家去做每一个详细讲解
[11:40/14:34]     我们先尝试把这个用力跑通
[11:42/14:34]     点
[11:44/14:34]     好
[11:45/14:34]     我们就能够获取到这个定位的一个文本信息了
[11:48/14:34]     接下来呢
[11:49/14:34]     我们做一个断言
[11:50/14:34]     Assert
[11:52/14:34]     这个文本
[11:56/14:34]     是不是等于等于等于等于什么呢
[11:59/14:34]     霍格沃兹测试开发
[12:03/14:34]     那添加这个之后呢
[12:05/14:34]     我们在这儿就可以看到这个断言判断
[12:09/14:34]     实际获取到的
[12:18/14:34]     搜索
[12:20/14:34]     展示的列表和预期的是否一致
[12:29/14:34]     我们给他换一个位置吧
[12:31/14:34]     前面是前面是这个11结果
[12:34/14:34]     后面是我们的预期结果
[12:36/14:34]     相当于这个xxelement.txt是我们的实际结果
[12:41/14:34]     后面这不是我们的预期结果OK
[12:43/14:34]     现在让我们来执行一下这条用例
[12:48/14:34]     OK
[12:49/14:34]     这是我们发现执行成功了
[12:50/14:34]     对不对
[12:51/14:34]     那添加完成这一个完整的这样的一个用例之后呢
[12:53/14:34]     才能够代表
[12:55/14:34]     我们的用力是完整的
[12:56/14:34]     那我们也可以测试一下
[12:58/14:34]     我们在后侧开发后面随便加点儿
[13:00/14:34]     那这时候他一定是找不到的
[13:03/14:34]     因为和它上面输入的内容是不一致的
[13:05/14:34]     这是我们执行一下
[13:06/14:34]     看他会不会报错
[13:09/14:34]     OK
[13:10/14:34]     他报错了
[13:11/14:34]     我们看一下报错信息是什么
[13:13/14:34]     我给报错信息说
[13:14/14:34]     他的一个预期结果是什么
[13:16/14:34]     霍格沃兹后面带一串数字
[13:18/14:34]     而他实际获取到的是霍格沃兹测试开发
[13:21/14:34]     那通过这样一个方式
[13:23/14:34]     我们就可以把我们的一个最最简单的一个外部自动化测试用例写完整
[13:28/14:34]     那在这章节
[13:30/14:34]     希望大家能够了解到的这样的一个信息是什么呢
[13:33/14:34]     就是我们的一个自动化测试用例结构
[13:37/14:34]     它应该有什么
[13:39/14:34]     我们再复习一遍
[13:40/14:34]     首先要我们的用例标题
[13:41/14:34]     通过我们的包
[13:43/14:34]     通过我们的文件名
[13:44/14:34]     类名和我们的方法名包名在一起
[13:46/14:34]     是我们用力的唯一标识
[13:48/14:34]     那第二个是什么呢
[13:50/14:34]     第二个是我们的一个前提条件
[13:51/14:34]     比如说driver的一些初始化
[13:55/14:34]     那这个对应的就是我们的前提条件
[13:59/14:34]     那还有我们这个测试用例的一个步骤
[14:03/14:34]     那这个对应在就是我们的测试方法里面的代码对吧
[14:08/14:34]     那还有除测试用例步骤之外呢
[14:10/14:34]     还有比如说我们的实际结果和预期结果
[14:14/14:34]     就是我们这个断言里面的这样的一个内容
[14:17/14:34]     那除了这部分之外还有什么呢
[14:19/14:34]     是不是还有我们的一个后置动作
[14:21/14:34]     比如说退出driver的一个进程
[14:23/14:34]     那这个呢
[14:24/14:34]     是我们的一个后置动作
[14:26/14:34]     OK
[14:28/14:34]     其实通常来说
[14:29/14:34]     就是一个自动化测试用例的一个标准的结构



### 5、web 浏览器控制
[00:00/10:05]     [以下字幕均由机器生成]同学们大家好
[00:00/10:05]     [以下字幕均由机器生成]在这一章节呢
[00:01/10:05]     我们要学习的
**[00:03/10:05]     是web浏览器的一个控制**

![image-20221211214114936](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211214114936.png)[00:06/10:05]     那在我们手动手手工测试的这个过程当中
[00:09/10:05]     比如说我们经常会碰到
[00:11/10:05]     比如说这个田径
[00:13/10:05]     刷新等等的一系列跟浏览器相关的操作
[00:17/10:05]     那对应在自动化测试的这个操作当中
[00:21/10:05]     其实也是这个selenium呢
[00:23/10:05]     也是提供了我们一个对应的API的一个支持的
[00:27/10:05]     那我们今天主要学习的有这样的几个操作
[00:30/10:05]     那对应的浏览器呢
[00:31/10:05]     首先就是打开
[00:32/10:05]     然后还有包括浏览器的一个刷新回退
[00:35/10:05]     还有浏览器的最大化最小化等等的这个常用的一些浏览器的操作
[00:43/10:05]     我们一个一个来看
[00:44/10:05]     首先我们先来看这个
[00:46/10:05]     首先我们先来看这个打开浏览器

![image-20221211214125072](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211214125072.png)[00:48/10:05]     那打开浏览器呢
[00:49/10:05]     它对应的这个API呢
[00:51/10:05]     叫做get
[00:52/10:05]     那操作呢
[00:53/10:05]     其实就是打开浏览器它使用场景
[00:57/10:05]     就是我们web自动化测试当中的第
[00:59/10:05]     一个步骤
[01:00/10:05]     那还有第二个API呢
[01:01/10:05]     叫做refresh
[01:02/10:05]     就是浏览器的一个刷新模拟的
[01:05/10:05]     就是浏览器的一个刷新操作
[01:06/10:05]     那back就是对应的浏览器的一个退回
[01:09/10:05]     那最大化窗口呢
[01:10/10:05]     就是同理
[01:12/10:05]     就是比如说像我们现在就是最大化的一个状态
[01:15/10:05]     那最小化对吧
[01:16/10:05]     最小化就是这样的一个状态
[01:18/10:05]     好
[01:19/10:05]     那我们继续往回看
[01:20/10:05]     那这这些呢
[01:22/10:05]     其实都是我们在测试的过程当中
[01:24/10:05]     可能会用到的浏览器的一些控制的操作
[01:28/10:05]     好
[01:29/10:05]     我们一个也来实践一下
[01:30/10:05]     首先我们先来看第一个就是网页的一个打开
[01:34/10:05]     那网页的一个打开呢
[01:35/10:05]     我们在这里也封装了一个方法
[01:37/10:05]     然后他所做的一个事儿呢
[01:38/10:05]     一共其实也就两行
[01:40/10:05]     第一步
[01:41/10:05]     这个实例化Chrome driver
[01:45/10:05]     其实所有的步骤
[01:46/10:05]     它都是需要去实例化这个web driver的
[01:49/10:05]     然后实例化之后呢
[01:50/10:05]     调用这个对应的我们前面表格所说的一个get方法
[01:54/10:05]     然后就然后调用这个方法就可以进行启动
[01:57/10:05]     我们来尝试一下吧
[01:59/10:05]     我们进入我们的一个idea
[02:03/10:05]     然后在这个地方呢
[02:04/10:05]     有一个叫做这个
[02:07/10:05]     那我们直接新建一个吧
[02:08/10:05]     比如说
[02:17/10:05]     好
[02:18/10:05]     那我们接下来在这里面
[02:20/10:05]     我们把我们对应的要写一个方法
[02:23/10:05]     第一个是打开浏览器
[02:25/10:05]     然后第二个是刷新浏览器
[02:28/10:05]     然后第三个对应的可能是我们的一个这个打开刷新
[02:33/10:05]     然后还有退回
[02:34/10:05]     退回操作
[02:35/10:05]     然后第四个是可能有一个最大化
[02:41/10:05]     然后第五个对应的就是我们的最小化的一个操作
[02:43/10:05]     好
[02:44/10:05]     那这个所有的步骤
[02:45/10:05]     都在我们的PPT上面
[02:46/10:05]     PPT上面给大家去做演示
[02:48/10:05]     我们一个一个来
[02:49/10:05]     那首先呢
[02:50/10:05]     我们先定一个这个打开浏览器的这样一个方法
[02:53/10:05]     比如说我们叫做open
[02:56/10:05]     Brother
[02:58/10:05]     好
[02:59/10:05]     我们在open brother里呢
[03:01/10:05]     首先先实例化一下我们的追问
[03:15/10:05]     然后使用这个driver.get然后再get时候呢
[03:18/10:05]     我们需要传递浏览器的URL好
[03:21/10:05]     我再写一下
[03:23/10:05]     调用get方法时需要传递
[03:30/10:05]     传递浏览器的URL
[03:34/10:05]     那比如说我们现在打开我们的一个测试页面吧
[03:37/10:05]     我们看一下我们的测试人
[03:41/10:05]     我们把这个URL copy一下
[03:45/10:05]     然后切换到我们的代码页面
[03:48/10:05]     那这时候呢
[03:49/10:05]     我们就定义好了这样的一个方法
[03:51/10:05]     我们在这里写一个main方法测试一下
[03:55/10:05]     我们调用一下这个方法
[03:57/10:05]     比如说叫做open brother的这样的一个方法
[04:00/10:05]     我们执行一下
[04:05/10:05]     大家可以看到我们现在刚刚一闪而过
[04:08/10:05]     我们家一个等待
[04:11/10:05]     这个是一个强制等待的一个操作
[04:13/10:05]     我们后面会有详细学习
[04:19/10:05]     OK
[04:20/10:05]     我们现在这个浏览器就成功的打开了
[04:23/10:05]     那这个对应过来就是我们的打开浏览器操作
[04:29/10:05]     打开浏览器
[04:31/10:05]     好
[04:32/10:05]     那我们没必要每一个都定一个方法
[04:35/10:05]     我们就全部在这个方法里面去做就好了
[04:38/10:05]     那第一个是我们的get方法打开浏览器
[04:41/10:05]     那第二个是我们的刷新浏览器
[04:43/10:05]     比如说我们现在在这儿需要对我们的浏览器进行一个刷新的操作
[04:47/10:05]     我们在这儿只要使用这个driver.refresh直接去调用
[04:52/10:05]     注意调用的时候它是一个方法
[04:54/10:05]     所以一定要加括号给这个步骤
[04:56/10:05]     对应过来的就是我们的浏览器的一个刷新操作
[05:02/10:05]     把这个注释给他粘贴到上面来
[05:06/10:05]     好
[05:07/10:05]     那我们来尝试一下
[05:10/10:05]     我们执行一下
[05:12/10:05]     第一个步骤打开浏览器
[05:14/10:05]     好等两秒OK
[05:16/10:05]     大家可以看到有中间有一个刷新的步骤对吧
[05:19/10:05]     我把这个注释给它
[05:20/10:05]     给它放到上面
[05:22/10:05]     它的一个操作对应的是打开浏览器
[05:30/10:05]     刷新元气
[05:35/10:05]     那我们来继续往后看
[05:36/10:05]     那接下来我们再退回
[05:37/10:05]     退回的话
[05:39/10:05]     比如说我们在这个地方呢
[05:40/10:05]     什么什么呢
[05:43/10:05]     退回上一步
[05:51/10:05]     那就是driver点这个back
[05:55/10:05]     我们找一下有没有这个bug方法好
[05:58/10:05]     那这个back呢
[06:00/10:05]     就是代表我们退回到我们的上一个步骤
[06:03/10:05]     我们来执行一下
[06:05/10:05]     我们在打开之前
[06:06/10:05]     我们在打开这个网页之前
[06:08/10:05]     我们是不是打开了一个空浏览器
[06:10/10:05]     就是没有输入任何网页的
[06:12/10:05]     那它的一个
[06:13/10:05]     那他退回上一步就会怎么样呢
[06:14/10:05]     首先先会他先打开测试人
[06:18/10:05]     打开测试人之后刷新
[06:19/10:05]     刷新之后再退回到这个非测试人的
[06:22/10:05]     就是我们一开始打开的那个页面我们来看一下
[06:25/10:05]     首先第一步
[06:28/10:05]     等两秒刷新
[06:29/10:05]     刷新完成之后退回OK
[06:31/10:05]     它整个步骤太快了
[06:34/10:05]     比如说我们在退回之前
[06:36/10:05]     我们重新打开一个页面
[06:37/10:05]     比如说get一个这个换一个页面
[06:40/10:05]     比如说换一个这个学员系统的一个页面
[06:44/10:05]     或者换一个百度的百度的
[06:49/10:05]     百度的好copy
[06:54/10:05]     我们所做的操作就是打开
[06:59/10:05]     从这个
[07:01/10:05]     测试人
[07:05/10:05]     通过get方法
[07:14/10:05]     通过get跳转到
[07:19/10:05]     然而这时候她所做的一个是返回
[07:22/10:05]     百度
[07:25/10:05]     之前的页面也就是测试人里面
[07:29/10:05]     好我们来看一下整个过程执行一下
[07:32/10:05]     第一步
[07:33/10:05]     先进入测试人
[07:36/10:05]     然后进入百度
[07:37/10:05]     进入百度之后
[07:38/10:05]     大家可以看到一闪而过
[07:39/10:05]     他退回了我们的测试页面
[07:46/10:05]     那这个对应的呢
[07:47/10:05]     就是我们的退回的一个操作
[07:49/10:05]     我把前面的都先出仕掉
[07:51/10:05]     要不然感觉会有一点干扰
[07:53/10:05]     那这个呢
[07:54/10:05]     就是我们的一个这个退回的这样的一个操作
[07:57/10:05]     那除了退回之外呢
[07:58/10:05]     还有我们的最大化最小化
[08:00/10:05]     我们在这儿有一个driver点
[08:05/10:05]     就是这个叫做最大化浏览器的这样的一个操作
[08:09/10:05]     来看一下
[08:11/10:05]     最大化对不对题
[08:16/10:05]     好我们执行一下
[08:23/10:05]     他这个太快了
[08:24/10:05]     我们还是同样给它加一个等待时间
[08:28/10:05]     就是它这个速度实在太快了
[08:33/10:05]     OK
[08:34/10:05]     等两秒最大化浏览器
[08:36/10:05]     等两秒关闭好
[08:37/10:05]     那这个呢
[08:38/10:05]     就是我们的这个
[08:41/10:05]     最大化浏览器的一个操作
[08:43/10:05]     那接下来我们再来一个最小化
[08:51/10:05]     这对应的这个Mac Smith有一个有一个叫做mini MIS window OK
[08:57/10:05]     大家应该可以看到
[08:58/10:05]     同样最大化之后
[08:59/10:05]     我们来做最小化的操作
[09:02/10:05]     也等两秒
[09:03/10:05]     然后我们执行一下
[09:09/10:05]     最大化等两秒12OK
[09:11/10:05]     最小化
[09:12/10:05]     大家可以看到刚刚这个也是一闪而过
[09:14/10:05]     非常快
[09:16/10:05]     以上呢
[09:17/10:05]     就是我们常用的一些浏览器的一个操作
[09:21/10:05]     让我们回到我们的PPT来复习一下
[09:24/10:05]     我们会通过get方法去打开我们这个浏览器
[09:27/10:05]     那它主要的核心代码
[09:28/10:05]     就是这个get
[09:29/10:05]     然后接下来呢
[09:31/10:05]     我们还会通过我们的这个refresh可以去刷新我们的方法
[09:36/10:05]     那这个refresh呢
[09:37/10:05]     不需要传任何的一个参数
[09:38/10:05]     它是一个方法
[09:39/10:05]     可以直接调用在这一行
[09:44/10:05]     就是我们第一个refresh
[09:45/10:05]     那除了refresh之外呢
[09:47/10:05]     还可以回退
[09:48/10:05]     也非常好用
[09:49/10:05]     就是直接用这个driver.back就可以回退到我们的上一个界面
[09:54/10:05]     那除了回退之外
[09:56/10:05]     还有我们的一个最大化
[09:57/10:05]     那最大化呢
[09:58/10:05]     就是使用这个Mac Smith window这样的一个方式
[10:01/10:05]     就可以把我们的窗口最大化
[10:17/10:05]     那最小化也是一样
[10:20/10:05]     就是使用这个mini Miss这样的一个方法就可以最小化我们窗口OK
[10:25/10:05]     那这一部分呢
[10:26/10:05]     就是我们针对于刘
[10:28/10:05]     暖气常用的一些常用的一些操作



### 6、常见控件定位方法
[00:00/23:17]     [以下字幕均由机器生成]在这一章节呢
[00:01/23:17]     [以下字幕均由机器生成]我们要学习的这个内容呢
[00:02/23:17]     就是常见控件的一些定位方法
[00:05/23:17]     那这个定位方法它的一个目的是什么
[00:08/23:17]     首先我们在自动化测试的过程当中
[00:10/23:17]     我们是不是要先查找到某一个button
[00:12/23:17]     或者查找到某一个输入框
[00:15/23:17]     然后再对他进行一些操作
[00:17/23:17]     对吧
[00:18/23:17]     比如说点击
[00:19/23:17]     比如说输入等等类似这个操作
[00:21/23:17]     那在查找这个过程当中
[00:23/23:17]     我们会使用多种的一个定位方式
[00:26/23:17]     那我们接下来看一下今天的内容分为哪几个部分
[00:30/23:17]     我们今天的内容呢

![image-20221211214449951](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211214449951.png)[00:31/23:17]     会分为三三个部分给大家进行讲解
[00:35/23:17]     会给大家做一些HTML知识的一些铺垫
[00:39/23:17]     那第二个部分呢
[00:40/23:17]     就是会给大家科普一下selenium的八大定位方式
[00:44/23:17]     那第三部分呢
[00:45/23:17]     就是这八大定位方式
[00:46/23:17]     其实我们需要掌握其中最最常用的几种定位方式
[00:52/23:17]     那这最最常用的几种定位方式呢
[00:54/23:17]     我们会给大家来一个练习的这样的一个过程
[00:58/23:17]     好那这时候呢
[00:59/23:17]     首先我们先来看第一个部分
[01:01/23:17]     就是HTML的一个知识的铺垫
[01:03/23:17]     OK
[01:04/23:17]     那左边的这一部分呢
[01:07/23:17]     其实就是我们就是一个非常简单的一个HTML的HTML知识点呢
[01:12/23:17]     其实说多不多
[01:13/23:17]     说少不少
[01:14/23:17]     要学起来它也是有一定的这个时间成本的
[01:17/23:17]     但是HTML知识其实我们不需要全部都去掌握
[01:20/23:17]     我们只需要掌握一些其中和我们自动化测试相关的一些核心知识就足够了
[01:26/23:17]     所以在这儿给大家做一些简单的铺垫
[01:29/23:17]     那首先呢
[01:31/23:17]     首先第一个我们要知道HTML里面的标签意味着什么
[01:35/23:17]     标签的一个英文名叫做踏歌
[01:38/23:17]     那这个标签代表的就是
[01:40/23:17]     比如说我们在这个里面
[01:42/23:17]     就是使用尖括号包起来的这个东西呢
[01:44/23:17]     我们常常给他叫做标签
[01:46/23:17]     那标签又分为很多种类型
[01:48/23:17]     那怎么样去判断他是什么类型的一个标签呢
[01:51/23:17]     那我们注意
[01:52/23:17]     就是这个左尖括号里面的第一个单词就是它对应的一个类型
[01:57/23:17]     比如说这个标签它的一个标签类型就是HTML
[02:00/23:17]     那这个标签它对应的就是抬头
[02:02/23:17]     那这个标签它对应的就是AOK
[02:05/23:17]     那这个是我们要了解到的第一个知识
[02:06/23:17]     就是标签的一个知识点
[02:08/23:17]     怎么样去看他是什么类型的一个标签
[02:11/23:17]     就是通过这样的一个方式
[02:13/23:17]     那第二个呢
[02:15/23:17]     那这个标签里面大家可以看到它还有属性
[02:17/23:17]     那什么叫做属性
[02:18/23:17]     像这种a等于B的这样的一个格式
[02:21/23:17]     什么叫a等于B
[02:22/23:17]     比如说这个是her fur等于一个URL
[02:24/23:17]     那这个我们叫做他a等于B
[02:26/23:17]     那这个所有的a等于B的
[02:28/23:17]     这个代表的呢
[02:29/23:17]     就是这个标签里面的一些属性好
[02:34/23:17]     那举个例子
[02:35/23:17]     比如说这个half呢
[02:36/23:17]     它就是这个a标签里面的某一个属性
[02:39/23:17]     那这个属性代表的就是链接的一个意思OK
[02:43/23:17]     那这个属性呢
[02:44/23:17]     这个属性通常它是一个KV结构
[02:46/23:17]     这个等号的左边代表的是这个属性的一个名称
[02:50/23:17]     等号的右边代表的是这个属性对应的一个值
[02:54/23:17]     那我们这个是第二个知识点
[02:56/23:17]     叫做属性
[02:57/23:17]     那我们再来看什么叫类属性
[02:59/23:17]     那类属性其实也是属性的一种
[03:01/23:17]     只是说我们在后面在自动化测试过程当中
[03:04/23:17]     这个类属性用的会非常多
[03:06/23:17]     所以我这儿把它单拎出来了
[03:08/23:17]     类属性呢
[03:09/23:17]     就是说他这个属性的这个名称叫做class
[03:13/23:17]     我们就把它叫做类属性
[03:15/23:17]     这个对应过来好
[03:16/23:17]     就给大家做一个HTML的一个简单的一个铺垫好
[03:20/23:17]     那我们继续往后看
[03:21/23:17]     那接下来我们再来看一下Selina母对应的有哪几种定位方式呢
[03:26/23:17]     我们在这儿
[03:27/23:17]     首先我们要记住第一点
[03:29/23:17]     Selenium官方是提供了八大定位方式
[03:32/23:17]     这个其实也写在了他的一个官方
[03:34/23:17]     到里面大家可以看到
[03:35/23:17]     在这儿写着selenium provide support for this
[03:40/23:17]     注意这个是个数字
[03:42/23:17]     EIGHT8种定位方式
[03:44/23:17]     那具体是哪八种定位方式呢
[03:45/23:17]     其实它下面给你列举出来了
[03:47/23:17]     OK
[03:48/23:17]     这时候回到我们的PPT
[03:49/23:17]     我在这儿放了一个中文版本呢
[03:51/23:17]     那第一种方式呢
[03:52/23:17]     就是这个class name就代表的是这个class我们前面所说的类属性

![image-20221211214709304](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211214709304.png)[03:56/23:17]     它对应的一个值
[03:58/23:17]     然后第二个是CS ss a lecture是我们的一个重点
[04:01/23:17]     要后面重点要学习这个
[04:03/23:17]     叫做CSS表达式
[04:05/23:17]     还有ID name
[04:06/23:17]     然后这个代表的就是这个ID和name代表的都是他们的一个属性
[04:10/23:17]     比如说ID属性对应的值是什么
[04:12/23:17]     Name属性对应的值是什么
[04:15/23:17]     还有link test代表的是这个一个一个超链接
[04:19/23:17]     然后它对应的一个文本是什么
[04:21/23:17]     然后这个particle INC和上面这个是一样的
[04:24/23:17]     只是说当你找到多个的时候呢
[04:26/23:17]     它匹配的是第一个
[04:29/23:17]     那这个target name呢
[04:31/23:17]     对应的就是我们的一个标签的一个名称
[04:33/23:17]     那叉丝其实也是我们的一个重点
[04:36/23:17]     对应的过来就是一个X表达式
[04:38/23:17]     那在这儿呢
[04:39/23:17]     我们接下来的实战过程当中
[04:41/23:17]     会给大家介绍这个CS s ID name link test he ta PA SI j5这五种这个非非常常用的一个定位方式吧
[04:52/23:17]     然后其中这四个
[04:54/23:17]     是重点当中的重点
[04:55/23:17]     大家一定要掌握的
[04:57/23:17]     好啊
[04:58/23:17]     就是我们这个这个八大定位方式
[05:01/23:17]     以及他的一个讲解
[05:02/23:17]     那接下来呢
[05:03/23:17]     我们会针对我们前面给大家说的常用的定位方式
[05:08/23:17]     一个一个给大家去进行实战的这样的一个练习
[05:12/23:17]     那我们了解完这八大订阅方式之后呢
[05:15/23:17]     接下来我们通过实战的这样的一个方式呢
[05:18/23:17]     然后带大家感受一下
[05:21/23:17]     然后教大家如何去使用这八大订阅方式
[05:25/23:17]     那它的使用呢
[05:26/23:17]     其实是非常非常简单的
[05:28/23:17]     我们只需要来看一下
[05:29/23:17]     首先来看左边它的一个格式
[05:32/23:17]     那首先上面的这种定位方式呢
[05:35/23:17]     这两首先先说一下这两种定位方式都是可以去进行定位的那上面的这种定位方式呢
[05:42/23:17]     它的一个模式就是find下划线
[05:44/23:17]     Element下划线
[05:46/23:17]     下划线定位方式
[05:47/23:17]     然后这时候有一个括号
[05:49/23:17]     然后括号里面只用传一个参数就是具体的定位元素就OK了
[05:54/23:17]     那第二种这个定位方式呢
[05:57/23:17]     就是使用这个find element直接括号
[06:00/23:17]     然后这个括号里面的第一个参数呢
[06:02/23:17]     去传定位方式
[06:05/23:17]     那第二个括号呢
[06:06/23:17]     去传具体的一个定位元素OK
[06:08/23:17]     这两个是他们格式上的一个差别
[06:11/23:17]     那我们来看右边
[06:13/23:17]     右边其实就是对应的这样的一个事例
[06:17/23:17]     那这个事例里面说了什么呢
[06:19/23:17]     首先第一个
[06:20/23:17]     就是它的一个driver典范element by ID我们会以右边的这个方式呢
[06:26/23:17]     就是以ID的这样的一个定位来看
[06:30/23:17]     同理啊
[06:31/23:17]     比如说你是ID定位方式的话呢
[06:33/23:17]     就是find element这个
[06:35/23:17]     然后小写
[06:36/23:17]     下划线小写ID
[06:37/23:17]     然后括号里面填元素
[06:39/23:17]     然后下面这种定位方式呢
[06:41/23:17]     就是第一个参数传一个
[06:43/23:17]     点大写的ID
[06:44/23:17]     然后这个第二个参数传定位的元素
[06:48/23:17]     那在在selenium最新的版本呢
[06:51/23:17]     官方的建议
[06:52/23:17]     其实是使用下面的这种方式的
[06:55/23:17]     那您使用上面的这种方式呢
[06:56/23:17]     其实这个官方会给你画一个横线
[06:59/23:17]     等一下会给大家去具体进行演示OK
[07:02/23:17]     了解完他的一个语法
[07:05/23:17]     了解完他的一个基本格式之后
[07:06/23:17]     我们先来看通过ID定位
[07:08/23:17]     那通过ID定位的一个方式非常简单
[07:10/23:17]     就是使用这个driver典范element
[07:12/23:17]     然后呗
[07:13/23:17]     的第一个参数传递方式就是ID一个定位方
[07:16/23:17]     第二个传ID这个属性
[07:20/23:17]     它对应的一个值的一个内容
[07:22/23:17]     好
[07:23/23:17]     这时候打开我们的APP
[07:24/23:17]     我们来编写一下他的这几种定位方式
[07:27/23:17]     首先我们先定义一个方法
[07:29/23:17]     比如说就叫外部locate
[07:32/23:17]     然后在这个方法里面呢
[07:33/23:17]     我们会编写它的一个多种定位那再写定位之前
[07:38/23:17]     大家需要注意的是
[07:40/23:17]     首先第一点
[07:41/23:17]     需要先
[07:43/23:17]     首先需要实例化这个一个主要对象
[07:48/23:17]     然后第二点呢
[07:50/23:17]     然后打开一个这个网页
[07:53/23:17]     好
[07:55/23:17]     然后第三点再去进行定位
[07:57/23:17]     然后我们一步一步来实现一下
[07:58/23:17]     第一步先实例化一个Java对象
[08:00/23:17]     那driver就等于我们前面已经说过了
[08:02/23:17]     就是web driver
[08:04/23:17]     然后直接使用alt加回车快捷导入的一个方式
[08:07/23:17]     注意选择最后一个slim.web driver这个包
[08:12/23:17]     然后点什么呢
[08:13/23:17]     点Chrome
[08:14/23:17]     注意Chrome的后面一定要加括号
[08:20/23:17]     一定
[08:22/23:17]     要加
[08:25/23:17]     这个
[08:29/23:17]     然后打开一个网页呢
[08:30/23:17]     我们前面已经学过了
[08:31/23:17]     就使用这个get方法
[08:33/23:17]     那在这里呢
[08:34/23:17]     建议大家
[08:35/23:17]     在练习的过程当中
[08:36/23:17]     可以使用学院官方提供的一个钱
[08:40/23:17]     这个这个月专门用来做web自动化的一个学习的一个页面
[08:44/23:17]     在这里叫做
[08:47/23:17]     这个
[08:51/23:17]     U s Du d在我们的学员系统的u s de d这个路径下
[08:56/23:17]     然后我们把它copy在我们的代码里面
[08:58/23:17]     先给大家看一下这个页面
[09:00/23:17]     那这个页面其实它的这个布局非常简单
[09:04/23:17]     那接下来我们先通通过这个元素定位这样的一个这样的一个选择
[09:10/23:17]     通过这元素定位这样的一个元素
[09:13/23:17]     它的文本叫元素定位
[09:14/23:17]     我们来练习一下他的一个定位
[09:16/23:17]     定位的一个知识
[09:19/23:17]     好
[09:19/23:17]     那这时候回到我们的一个页面
[09:21/23:17]     这时候我们知道了
[09:22/23:17]     我们要打开的是我们这个USRD
[09:24/23:17]     对吧
[09:25/23:17]     那接下来呢
[09:26/23:17]     我们可以通过driver点这个饭的element
[09:30/23:17]     然后find element
[09:31/23:17]     我们说了定位
[09:32/23:17]     第一个参数传递定位
[09:38/23:17]     方式第二个参数传递定位元素对吧
[09:44/23:17]     好那我们来尝试一下第一个参数
[09:46/23:17]     比如说我们使用这个
[09:49/23:17]     然后也是需要进行导入的
[09:54/23:17]     然后倒入一个
[09:56/23:17]     点ID
[09:57/23:17]     然后第二个参数呢
[09:58/23:17]     我们传这个ID这个元素
[10:01/23:17]     它对应的一个值ID属性对应的一个值
[10:04/23:17]     我们来看一下这个元素定位他有没有这个ID属性
[10:08/23:17]     我们网上看
[10:09/23:17]     在这个地方我们可以看到它有一个ID属性对不对
[10:13/23:17]     然后这个ID属性呢
[10:14/23:17]     它对应的值是什么
[10:16/23:17]     是不是对应的这个叫做locate ID
[10:18/23:17]     这是我们复制一下
[10:20/23:17]     然后我们把这个rocket ID作为第二个参数给他传递进来
[10:25/23:17]     就是这个他的一个通过ID定位的一个方式
[10:31/23:17]     然后这时候就是他的这个driver.find element如果找到元素的话呢
[10:37/23:17]     那他就会成功的返回一个web element的一个对象回来
[10:41/23:17]     比如说我们就叫他
[10:44/23:17]     这个
[10:46/23:17]     Web element
[10:47/23:17]     然后我们给他做一个打印
[10:49/23:17]     Print development OK
[10:51/23:17]     然后我们接下来在main方法里面去调用一下这个函数
[10:55/23:17]     Y block it
[10:56/23:17]     然后我们执行一下
[10:59/23:17]     OK
[11:00/23:17]     大家可以看到
[11:02/23:17]     这个中间这个速度很快
[11:03/23:17]     也执行成功了
[11:04/23:17]     这是我们可以看到有它就会产生一个这个web的对象
[11:09/23:17]     我们也记录在这里
[11:11/23:17]     调用这个方法的返回值为
[11:14/23:17]     调用这个方法的返回只认为web development
[11:21/23:17]     OK
[11:22/23:17]     这是我们需要注意一点
[11:23/23:17]     那前面我们说过了
[11:24/23:17]     那除了这种定位方式之外呢
[11:26/23:17]     还有一种定位方式是比如说find element
[11:29/23:17]     后面这个方法名
[11:31/23:17]     就直接跟着下划线
[11:32/23:17]     然后以及定位方式
[11:33/23:17]     那在这儿
[11:34/23:17]     他在这儿呢
[11:36/23:17]     如果说大家要使用这种定位方式
[11:38/23:17]     直接去传我们的一个locate ID就OK啦
[11:42/23:17]     使用这样的方式也可以正常的去进行定位
[11:45/23:17]     我们来尝试一下
[11:47/23:17]     然后我们执行一下
[11:52/23:17]     这是我们可以看到
[11:53/23:17]     执行成功了
[11:54/23:17]     但是呢
[11:55/23:17]     大家注意到一个细节
[11:56/23:17]     就是我们的这个再调用这个方法的时候
[12:00/23:17]     带了一个横线
[12:01/23:17]     带了一个横线的意思就是说官方建议你在使用的这个过程当中
[12:05/23:17]     这个方法在后续的版本更新当中可能会直接被取消
[12:10/23:17]     所以说建议你就不要直接去使用了
[12:12/23:17]     那我们把这个方法注释掉
[12:14/23:17]     大家记得以后就尽量去使用这个这样的第一种的这样的一个方式就OK了
[12:20/23:17]     那这是我们的第一种定位方式
[12:22/23:17]     就是我们的一个ID定位
[12:24/23:17]     那接下来呢
[12:26/23:17]     我们继续往后来看
[12:28/23:17]     那除了ID定位之外呢
[12:30/23:17]     还有第二种方式呢
[12:31/23:17]     就是通过这个name去进行定位
[12:34/23:17]     那这个name它整体的这个方式和我们的这个和我们的ID是一样的
[12:39/23:17]     那第一个也是传递方式
[12:41/23:17]     方式就是前面是点ID
[12:44/23:17]     现在换成点name
[12:45/23:17]     然后第二个参数传入这个name属性它对应的一个值的内容
[12:49/23:17]     这是我们回到我们的页面
[12:50/23:17]     我们看有没有name属性
[12:52/23:17]     在这里专门给大家添加了一个name属性
[12:54/23:17]     叫做locate
[12:55/23:17]     其实通常
[12:56/23:17]     这个前端他不会给你同时添加name和ID属性的
[13:01/23:17]     我们是为了给大家演示方便
[13:03/23:17]     所以给大家添加了一个叫做name的一个属性
[13:06/23:17]     那这时候怎么去使用呢
[13:08/23:17]     还是使用这个
[13:10/23:17]     来我们做一个记录第一个是ID定位
[13:13/23:17]     那第二个是name定位
[13:23/23:17]     好
[13:24/23:17]     使用这个driver还是find element第一个参数
[13:27/23:17]     对不对
[13:28/23:17]     首先拜谁name对吧
[13:30/23:17]     通过name的一个方式
[13:31/23:17]     然后传入name的值进去
[13:35/23:17]     然后这时候我们执行一下
[13:36/23:17]     如果没有任何的一个报错的话呢
[13:38/23:17]     证明我们就执行成功了
[13:47/23:17]     好
[13:58/23:17]     这是我们发现执行成功了
[14:00/23:17]     但是刚刚大家注意到我说的一句话没有
[14:02/23:17]     我们说如果没有报错
[14:06/23:17]     证明元素找到了
[14:08/23:17]     那他怎么样的情况下会出现报错呢
[14:11/23:17]     比如说我写一个错误的定位
[14:13/23:17]     比如说我写一个LOCATE11
[14:15/23:17]     这个元素呢
[14:16/23:17]     在我们的页面上
[14:17/23:17]     应该是没有的
[14:18/23:17]     怎么查呢
[14:19/23:17]     进入到你们的这个element
[14:21/23:17]     然后按住control f
[14:31/23:17]     然后在这儿直接输入这个LOCATE11
[14:39/23:17]     这时候我们可以看到这儿写0F0
[14:41/23:17]     证明这个页面是没有这个元素的
[14:43/23:17]     好
[14:44/23:17]     那这时候我们切回这个页面
[14:45/23:17]     这时候如果说他能找到那处说明就不太科学了
[14:50/23:17]     那这是我们执行一下代码
[14:56/23:17]     OK
[14:57/23:17]     我们发现
[15:16/23:17]     代码出发现这个发生了
[15:18/23:17]     报错发生
[15:19/23:17]     我们看到报错信息是什么
[15:20/23:17]     他说no such element exception
[15:23/23:17]     注意我们看报错信息的时候
[15:24/23:17]     我们就搜这个exception
[15:28/23:17]     通常都是可以搜到的
[15:29/23:17]     代表异常的一个意思
[15:31/23:17]     他报了一个什么异常呢
[15:32/23:17]     他说no such element no such element代表的是什么
[15:37/23:17]     如果如果不好错
[15:40/23:17]     No such element代表元素定位可能出现错误
[15:47/23:17]     代表的是当你使用这样的一个定位方式以及这样的一个值的时候呢
[15:51/23:17]     他他就找不到这样的一个元素
[15:54/23:17]     所以说大家在这里需要去注意
[15:56/23:17]     就是当我们一旦碰到这个no such element的时候
[16:00/23:17]     第一时间去检查一下
[16:00/23:17]     是不是你的元素定位的具体的内容写的具体的只写错了
[16:06/23:17]     还是你的元素定位方式可能出现了一个错误
[16:09/23:17]     好啊
[16:10/23:17]     那这个也是我们在做自动化测试的过程当中常见的一个类型的一个报错
[16:15/23:17]     叫做no such element啊
[16:19/23:17]     那接下来呢
[16:20/23:17]     我们继续往后看
[16:21/23:17]     这个是一个错误的事例
[16:27/23:17]     这个是
[16:29/23:17]     错误实例
[16:31/23:17]     那正确的应该是去掉这个一一
[16:35/23:17]     那我们接下来再来看
[16:37/23:17]     继续往后来看
[16:38/23:17]     第三个叫做CSES选择器定位

![image-20221211215349901](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211215349901.png)[16:42/23:17]     那CS选择器定位又是什么意思呢
[16:44/23:17]     这时候
[16:45/23:17]     回到我们的一个PPT
[16:47/23:17]     往后看
[16:49/23:17]     那这个CS选择题定位和我们前面的ID和name不一样
[16:53/23:17]     ID和name是直接在页面上面的一个唯一的一个属性
[16:59/23:17]     并且他有唯一的一个值
[17:01/23:17]     那我们CSS代表什么呢
[17:04/23:17]     代表的是可能在这个页面上他既没有ID
[17:07/23:17]     也没有name
[17:08/23:17]     那这时候怎么办呢
[17:10/23:17]     就可以通过CS选择器去进行定位
[17:13/23:17]     那CS选择题它的一个格式
[17:15/23:17]     和我们前面是一样的
[17:17/23:17]     那同样
[17:18/23:17]     都是这个driver典范elements
[17:20/23:17]     然后第一个参数选择定位方式的时候需要点CS ss a lecture
[17:26/23:17]     然后在第二个参数的时候呢
[17:28/23:17]     输入是CSS表达式
[17:31/23:17]     那这个CS表达式如何去获取呢
[17:33/23:17]     有两种方式
[17:34/23:17]     第一种方式是直接在浏览器上copy复制一个绝对定位
[17:38/23:17]     比如说我们还是去找这个元素定位
[17:40/23:17]     这时候我们可以右键copy CS ss a lecture
[17:45/23:17]     这是我们的第一种方式
[17:46/23:17]     第二种方式呢
[17:47/23:17]     是编写CSS表达式
[17:50/23:17]     在刚开始学习的过程当中
[17:52/23:17]     大家可以使用复制绝对定位的方式
[17:54/23:17]     但是这个边通过自己去
[17:57/23:17]     自己自行去编写CSS
[18:00/23:17]     表达式也是非常非常重要
[18:02/23:17]     以及必学的这样的一个知识点
[18:05/23:17]     大家在后面呢
[18:06/23:17]     我们会专门有一个章节叫做CS高级定位
[18:09/23:17]     去给大家进行详细的讲解
[18:11/23:17]     OK
[18:12/23:17]     我们首先先用这种比较low的一个方式
[18:14/23:17]     那怎么去
[18:15/23:17]     首先还是先找到它的一个元素
[18:19/23:17]     然后右键在这个地方
[18:21/23:17]     然后选择copy sector
[18:23/23:17]     然后在这儿的时候呢
[18:24/23:17]     我们就还是使用这个driver
[18:26/23:17]     Driver
[18:28/23:17]     典范element
[18:30/23:17]     然后拜点CSS
[18:32/23:17]     然后第二个参数输入我们刚刚copy的选择题
[18:36/23:17]     然后这时候执行一下我们的代码
[18:37/23:17]     如果能够找到就证明
[18:40/23:17]     我们的这个代码没有任何的问题
[18:41/23:17]     大家可以看到没有任何的报错
[18:44/23:17]     那这个是CS选择T定位
[18:46/23:17]     我们接下来再来看还有什么呢
[18:48/23:17]     还有一个叫做X帕斯表达式定位
[18:53/23:17]     那这个X path表达式定位是什么意思
[18:55/23:17]     回到我们的PPT
[18:56/23:17]     我们来看这个X path定位
[18:58/23:17]     其实他有点儿近似于我们的CS
[19:00/23:17]     只是说它使用的是底层
[19:02/23:17]     它使用的是不同的方式
[19:05/23:17]     然后这个X pass呢
[19:07/23:17]     但使用起来他们的方式是一样的
[19:10/23:17]     第一个参数选择X pass一个定位方式
[19:13/23:17]     第二个第二个参数是输入的是X pass一个表达式
[19:17/23:17]     那X pass表达式的获取也有两种方式
[19:19/23:17]     第一种也是跟前面一样
[19:21/23:17]     是直接在浏览器上复制
[19:24/23:17]     第二种是编写X path表达式
[19:26/23:17]     这个X path表达式也是在我们的后面的章节进行详细讲解
[19:30/23:17]     注意啊
[19:31/23:17]     这个CSS表达式和我们的X表达式大家都要学习
[19:35/23:17]     并且都要掌握
[19:36/23:17]     因为这个如果说你们面试的时候说去做UI自动化测试
[19:40/23:17]     是很有可能会去考你们的一个知识点儿
[19:45/23:17]     那我们先不搞这么复杂
[19:47/23:17]     在前面学习的过程当中
[19:49/23:17]     我们先来看这个叉叉丝定位
[19:51/23:17]     我们使用一个比较low的方式怎么去获取
[19:53/23:17]     还是这个元素定位
[19:55/23:17]     我们直接右键在这儿copy
[19:57/23:17]     叉叉丝就OK了
[20:00/23:17]     那接下来我们回到我们的页面里面
[20:02/23:17]     然后driver
[20:03/23:17]     典范的element
[20:05/23:17]     然后再点这个
[20:09/23:17]     XPASIOK
[20:10/23:17]     然后这个参数呢
[20:11/23:17]     我们选择刚刚复制的一个内容
[20:13/23:17]     在这里大家注意到我复制的时候是不是报错了
[20:17/23:17]     因为这两个双引号他认为是一对儿
[20:20/23:17]     所以中间这一个字符串
[20:22/23:17]     然后这两个双引号他认为是一对儿
[20:24/23:17]     所以这一段儿他认为是一个字符串
[20:26/23:17]     那中间这个它没有
[20:28/23:17]     两没有一个成对的双引号
[20:30/23:17]     所以说呢
[20:31/23:17]     碰到这种情况怎么办
[20:34/23:17]     如果说你里面用了双引号
[20:36/23:17]     那你外面就用单引号
[20:40/23:17]     这是Python语法里面需要注意的一个细节
[20:44/23:17]     然后我们直接这样也可以就是把它整个圈住
[20:47/23:17]     然后我们再加一个单引号的符号
[20:51/23:17]     就可以直接直接这个最外层给他剥一层单引号
[20:56/23:17]     然后大家可以看到通过外面切换成单引号这个方式之后
[21:00/23:17]     就不再出现报错了
[21:02/23:17]     然后这时候我们再去执行一下
[21:07/23:17]     也没有任何一个报错信息
[21:09/23:17]     那这个是我们对应的第四种方式
[21:12/23:17]     也就是我们的一个X path表达式的一个定位
[21:14/23:17]     那接下来我们再来看最后的一种方式
[21:19/23:17]     叫做通过
[21:21/23:17]     五这个也是
[21:24/23:17]     其实没有前面四种常用
[21:26/23:17]     也但是有一些同学可能会去使用吧
[21:29/23:17]     就是通过这个链接文本的方式
[21:34/23:17]     那这个链接文本它需要注意的细节是什么呢
[21:37/23:17]     首先第一点第一点
[21:42/23:17]     元素一定是a标签
[21:46/23:17]     这是第一点
[21:47/23:17]     然后这个
[21:50/23:17]     然后第二点是
[21:52/23:17]     标签内的
[21:55/23:17]     文本第二点就是输入的元素为好
[22:02/23:17]     我们先来看怎么去调用
[22:04/23:17]     它是driver典范的element
[22:05/23:17]     然后再拜的
[22:06/23:17]     这个时候呢
[22:07/23:17]     选择的是link test
[22:09/23:17]     那第二个参数
[22:11/23:17]     注意我们输入的这个
[22:13/23:17]     我们之前输入的可能是一些属性对应的值
[22:17/23:17]     但是第二个参数
[22:18/23:17]     我们需要输入的元素是标签内的一个文本
[22:21/23:17]     比如说我们找一下看有没有a标签
[22:24/23:17]     比如说这儿他的这个元素定位它是一个a标签
[22:27/23:17]     我们可以看到它是一个link
[22:29/23:17]     这儿有个a标签
[22:30/23:17]     那这时候我们可以看到哪文本代表什么呢
[22:33/23:17]     文本代表这个
[22:35/23:17]     这个就是夹在Spain当中的span在这个
[22:39/23:17]     Span在HTML里面代表的就是文本
[22:42/23:17]     然后夹在span当中的这个这个这个值呢
[22:45/23:17]     就是叫做这个叫做元素定位的这几个汉字儿
[22:49/23:17]     就是它对应的一个文本
[22:51/23:17]     然后我们把这个内容给他copy过来
[22:55/23:17]     通过这样的一个方式
[22:56/23:17]     我们代表的就是我们定位的就是这个元素定位的
[23:00/23:17]     就是元素定位这样的一个链接
[23:03/23:17]     好
[23:05/23:17]     看能不能够定位成功
[23:08/23:17]     我们发现没有任何的一个问题
[23:11/23:17]     那元素通常
[23:12/23:17]     像这种link test
[23:13/23:17]     我们还会给他带来一个点击操作
[23:15/23:17]     那我们给它加一个click
[23:17/23:17]     这是我们在执行一下
[23:21/23:17]     我们发现也可以执行成功
[23:24/23:17]     OK
[23:25/23:17]     那大家可以看到
[23:26/23:17]     在整个地在元素定位这个过程当中呢
[23:29/23:17]     我们一定要熟悉
[23:31/23:17]     就是首先要熟悉steam有几种定位方式
[23:35/23:17]     我们要熟悉各个定位方式他使用的一个特点
[23:38/23:17]     然后注意需要注意的一个细节
[23:41/23:17]     然后以及我们常用的这五种方式
[23:45/23:17]     尤其是前面四种
[23:47/23:17]     最后一种可能还不是特别常用
[23:49/23:17]     就是这1234种如何去使用
[23:51/23:17]     然后要注意的事项
[23:53/23:17]     然后一定要牢记清楚了
[23:57/23:17]     好
[23:58/23:17]     就是我们的这个常见元素定位章节需要学习的一个内容



### 7、强制等待与隐式等待
[00:00/37:44]     [以下字幕均由机器生成]同学们大家好
[00:00/37:44]     [以下字幕均由机器生成]在这一章节呢
[00:01/37:44]     [以下字幕均由机器生成]我们要学习的内容
[00:03/37:44]     就是我们一个强制的等待与影视等待
[00:07/37:44]     那我们今天这节课呢
[00:09/37:44]     会分成三个部分去进行学习
[00:11/37:44]     首先就是我们的一个强制等待
[00:13/37:44]     也就是我们常说的一个直接等待
[00:17/37:44]     那第二种呢
[00:19/37:44]     我们要来学习完这个强制等待和隐式等待之后呢
[00:22/37:44]     我们再来学习一下影视等待
[00:24/37:44]     学完影视等待之后呢
[00:25/37:44]     我们再来学习学习一下显示等待
[00:27/37:44]     那这三个等待呢
[00:29/37:44]     其实他们的使用方法以及他们的一个使用场景呢
[00:33/37:44]     都是不一样的
[00:34/37:44]     那我们如果要是想做好UI自动化测试
[00:38/37:44]     对于这三种的一个使用方法以及它适合的应用场景
[00:42/37:44]     我们都一定要非常的熟悉
[00:44/37:44]     然后才能够通过这个使用这三种的方式提高我们脚本的一个稳定性
[00:50/37:44]     好
[00:51/37:44]     首先我们先来看一下为什么我们需要去添加等待
[00:56/37:44]     那首先我们先来看一下右边的这一段代码
[00:59/37:44]     那右边这一段代码呢
[01:00/37:44]     它定义了一个方法
[01:02/37:44]     然后这个方法里面呢
[01:03/37:44]     这个方法叫做we sleep
[01:05/37:44]     然后这个we sleep他做了什么事儿呢
[01:07/37:44]     他先打开了一个这个浏览器
[01:11/37:44]     打开一个谷歌浏览器
[01:12/37:44]     然后呢
[01:13/37:44]     又打开了我们的一个网页
[01:14/37:44]     就是我们的学员系统
[01:15/37:44]     大家可以看到VIP检测点空
[01:17/37:44]     然后呢
[01:18/37:44]     又去查找了这个系统当中的这个个人中心的这样的一个元素
[01:23/37:44]     就是他所做的三个步骤
[01:25/37:44]     那我先来带大家执行一下这段代码
[01:29/37:44]     我们再来说为什么我们我们要去天涯等待
[01:32/37:44]     OK
[01:33/37:44]     我们把这一段代码复制到复制到我的拍唱里面
[01:37/37:44]     我们来尝试执行一下
[01:39/37:44]     看会不会a能不能够成功
[01:41/37:44]     还是是成功还是失败
[01:45/37:44]     其实跟大家说的是有可能成功
[01:47/37:44]     也有可能失败
[01:48/37:44]     OK
[01:49/37:44]     那这次是失败了
[01:50/37:44]     那有时候呢
[01:52/37:44]     那这个原因是什么
[01:53/37:44]     首先我们先来看一下他报了什么错
[01:55/37:44]     他报的错是no such element unable to locate element
[02:00/37:44]     那这句
[02:02/37:44]     我们粘贴一下
[02:03/37:44]     这个报错会在我们之后做自动化测试的整个的过程当中
[02:07/37:44]     经常会出现
[02:09/37:44]     我们先来看一下
[02:10/37:44]     我们在这儿加一个分割线
[02:14/37:44]     那这个报错
[02:17/37:44]     报错是这样的一个报错
[02:21/37:44]     那我们现在在下面呢
[02:23/37:44]     那原因是什么
[02:28/37:44]     原因原因呢
[02:30/37:44]     其实就是因为我们在这个定位的这个过程当中
[02:33/37:44]     大家可以看到他刚刚整个进行的这样的一个过程
[02:37/37:44]     我们再打开
[02:38/37:44]     我们再看一下整个过程
[02:40/37:44]     我们观察一下我们页面的加载加载先后顺序
[02:43/37:44]     大家注意到我们是不是先加载了学习进度
[02:47/37:44]     然后先加载上面这几个标签
[02:48/37:44]     然后下面这个才加载出来
[02:51/37:44]     在我们的页面还在加载的这个过程当中
[02:56/37:44]     就是在它上面的这部分内容还在加载的过程当中
[02:59/37:44]     这个代码是不是就执行到了第14行
[03:02/37:44]     那既然他这个个人中心还没有加载出来
[03:04/37:44]     那他的个人中心
[03:05/37:44]     那我们在find element的时候呢
[03:07/37:44]     这个执行这一行一定会报错
[03:11/37:44]     所以说它的一个原因
[03:12/37:44]     就是因为
[03:13/37:44]     页面为
[03:15/37:44]     加载完成
[03:17/37:44]     就去查找元素
[03:20/37:44]     此时元素
[03:22/37:44]     此时这个元素还没
[03:27/37:44]     加载出来好
[03:28/37:44]     那我们怎么样去判断到底是不是因为这个元素有没有加载出来的一个问题呢
[03:34/37:44]     那在这儿我们可以加一个强制等待
[03:36/37:44]     那这个呢
[03:37/37:44]     就是我们第一个要学习的一个等待方式
[03:40/37:44]     叫做强制等待
[03:41/37:44]     这时候返回我们的PPT
[03:44/37:44]     那第一种呢
[03:45/37:44]     就是我们的直接等待
[03:46/37:44]     也是我们的强制等待
[03:48/37:44]     我们刚刚说了他的这个报错
[03:50/37:44]     报了no such element
[03:52/37:44]     那这种情况呢
[03:53/37:44]     我们怎么去判断
[03:54/37:44]     他的一个解决方案就是在报错的元素操作注意
[03:57/37:44]     在报错的元素操作之前添加等待
[04:01/37:44]     我之前看到过有一些同学他添加等待在什么位置呢
[04:04/37:44]     在11号之前
[04:05/37:44]     或者在11号之前
[04:06/37:44]     大家在这两行之前去添加等待是没有用的
[04:09/37:44]     大家一定要记住要在报错行
[04:12/37:44]     那这时候我们来看一下报错行是哪行
[04:14/37:44]     往这儿看一下我们对战
[04:16/37:44]     这时候我们找到我们自己的代码
[04:20/37:44]     什么叫做我们自己的代码
[04:21/37:44]     就是这个叫做webwait.py这个是我们自己创建的代码文件
[04:26/37:44]     然后我们找一下web wait
[04:27/37:44]     然后再往后呢
[04:28/37:44]     就是什么slim底层报错
[04:30/37:44]     我们不要关注
[04:31/37:44]     我们点一下这个从从下方就是倒数第一行
[04:36/37:44]     就是我们自己代码里面的倒数第一个
[04:38/37:44]     然后我们就可以看到
[04:40/37:44]     是不是就是我们的这一行
[04:42/37:44]     也就是我们的这个个人中心这一行
[04:44/37:44]     对吧
[04:45/37:44]     那我们需要在他查找个人中心之前呢
[04:48/37:44]     添加一个强制等待添加三秒吧
[04:51/37:44]     好
[04:52/37:44]     那这时候我们看一下PPT
[04:53/37:44]     它的一个原理就是这个他们的sleep它的一个作用是什么
[04:57/37:44]     其实它就是让我们的县城强制的去修休眠三秒
[05:03/37:44]     休眠三秒之后
[05:04/37:44]     才会去执行后面的这段代码
[05:07/37:44]     OK
[05:09/37:44]     那我们尝试一下
[05:10/37:44]     加了这一个time to sleep
[05:11/37:44]     看看有没有什么效果
[05:13/37:44]     我们执行一下
[05:17/37:44]     OK
[05:18/37:44]     等待三秒
[05:19/37:44]     那这时候个人中心是不是加载出来
[05:21/37:44]     现在还在等待
[05:22/37:44]     那这时候大家可以看到我们的代码是不是就没有任何一个报错了
[05:27/37:44]     为什么没有报错了呢
[05:28/37:44]     因为我们这个时候添加了强制等待
[05:32/37:44]     我们在这儿说一下
[05:33/37:44]     它的一个解决方案
[05:39/37:44]     解决方案
[05:43/37:44]     在这个强制
[05:47/37:44]     在强制
[05:50/37:44]     再报
[05:51/37:44]     错
[05:57/37:44]     这个no such element报错
[06:01/37:44]     之前
[06:03/37:44]     添加
[06:05/37:44]     强制等待
[06:07/37:44]     然后等待页面渲染完成
[06:13/37:44]     那如果
[06:15/37:44]     如果没有
[06:18/37:44]     报错证明就是
[06:21/37:44]     页面
[06:22/37:44]     这个页面渲染
[06:26/37:44]     速度导致的问题
[06:29/37:44]     如果添加了强制等待还报错
[06:35/37:44]     那么可能是别的问题
[06:38/37:44]     比如定位错误
[06:40/37:44]     好
[06:41/37:44]     比如说我们现在把这个个人中心改成一一好
[06:43/37:44]     那这个时候是我们页面上一定没有的这样的一个元素
[06:47/37:44]     那这时候我们再执行一下
[06:48/37:44]     我们看一下结果
[06:55/37:44]     我们看一下是不是报错了
[06:56/37:44]     你这个时候你不管等待多少秒
[06:58/37:44]     就是等待300秒也不会找到的
[07:01/37:44]     那这个呢
[07:02/37:44]     就是我们这个通过添加强制等待的一个方式
[07:05/37:44]     去暂时先去规避掉这样的一个问题
[07:09/37:44]     就是no such element这样的报错的这样一个问题
[07:12/37:44]     那这个呢
[07:13/37:44]     第一种我们在这儿加一个分割线
[07:16/37:44]     第一种叫做强制等待的使用
[07:26/37:44]     那这时候返回我们的PPT
[07:27/37:44]     那这个呢
[07:28/37:44]     就是我们的第一种方式
[07:29/37:44]     是不是非常简单
[07:30/37:44]     其实一共就这一行代码
[07:32/37:44]     记得一定要在你们的报那个no such element的错误之前去添加这个代码
[07:37/37:44]     不要在其他地方去随便添加好
[07:40/37:44]     那这是第一种方式
[07:43/37:44]     那我们再来看第二种方式

![image-20221211220225006](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211220225006.png)[07:44/37:44]     叫做隐式等待
[07:45/37:44]     那隐士等待它解决的是什么问题呢
[07:48/37:44]     我们现在思考一下这样的一个问题
[07:50/37:44]     如果说我们难以确定元素加载的一个具体等待时间的情况下
[07:56/37:44]     怎么去怎么办呢
[07:57/37:44]     举个例子
[07:59/37:44]     比如说我们再找一个个人中心
[08:00/37:44]     之前a可能因为网速的问题
[08:03/37:44]     我这一次我等待三秒就足够了
[08:05/37:44]     那下一次可能因为我们网速变慢了
[08:07/37:44]     我要等待五秒对吧
[08:08/37:44]     那我们这个等待时间是不是要一直去变换
[08:12/37:44]     有时候他等待的快呢
[08:13/37:44]     可能一秒就加载出来了
[08:14/37:44]     但是呢
[08:16/37:44]     我们却要去等待五秒
[08:18/37:44]     那这时候就会带来我们的第二个问题
[08:21/37:44]     我们来说一下第二个问题
[08:23/37:44]     这是我们要来看的
[08:24/37:44]     是我们的一个影视等的使用
[08:31/37:44]     那我们先来说一下强制
[08:35/37:44]     等待的问题
[08:37/37:44]     那强制等待的问题呢
[08:38/37:44]     就是不确定
[08:41/37:44]     页面的加载时间
[08:44/37:44]     可能会导致等待时间
[08:50/37:44]     可能会我在写两种情况吧
[08:52/37:44]     可能会因为等待时间过长
[08:57/37:44]     而影响
[09:03/37:44]     用力的执行效率什么意思
[09:05/37:44]     比如说我们的这个用力呢
[09:09/37:44]     如果说我们不添加这些死等
[09:10/37:44]     我们可能一分钟就执行完了
[09:12/37:44]     但是因为我们在每一个步骤之前
[09:14/37:44]     我们为了不让他出错嘛
[09:15/37:44]     我们在每一个步骤之前都等待五秒
[09:17/37:44]     那这时候我们的这个用力呢
[09:19/37:44]     可能就从一分钟变成了十分钟
[09:21/37:44]     那假如说我们有100条这样的用力
[09:25/37:44]     我们就浪费了九乘以100
[09:27/37:44]     就是900分钟
[09:29/37:44]     那这个呢
[09:30/37:44]     会大大影响我们用力的一个执行效率
[09:32/37:44]     那这是我她带来的第一个问题
[09:34/37:44]     就是如果说等待时间过长的一个问题
[09:37/37:44]     那如果说他第二个问题就是什么呢
[09:40/37:44]     如果说等待时间过短
[09:42/37:44]     过短会怎么样大家思考一下
[09:44/37:44]     过短是不是我的
[09:46/37:44]     过短依然是我的这个页面元素没有加载完儿
[09:49/37:44]     我就去执行了这个find element的代码儿
[09:52/37:44]     而导致什么呢
[09:53/37:44]     而导致代码
[09:56/37:44]     依然会报错
[09:59/37:44]     所以说我们在这儿就可以发现
[10:01/37:44]     强制等待他可能只是用试纸适用于什么
[10:04/37:44]     就是调试的场景
[10:05/37:44]     那一旦呢
[10:06/37:44]     我们的这个代码一旦我们自动化测试代码真正的去投入使用的时候
[10:11/37:44]     我们就会发现
[10:12/37:44]     第一他效率低
[10:14/37:44]     第二他依然没有解决不稳定性的这样的一个问题
[10:19/37:44]     那既然强制等待存在这样的一些问题
[10:21/37:44]     那我们怎么样去规避这个强制等待给我们带来这些问题
[10:25/37:44]     我们应该怎么样去解决它呢
[10:27/37:44]     我们来看一下
[10:28/37:44]     解决方案呢
[10:29/37:44]     其实就是要配合我们的影视等待和显示等待
[10:34/37:44]     去把我们代码里面的所有的强制等待去进行一个替换
[10:38/37:44]     首先我们先来看一下影视等待的一个使用
[10:41/37:44]     就比如说针对于寻找元素这个动作
[10:44/37:44]     什么叫做寻找元素
[10:45/37:44]     就是这个范element
[10:46/37:44]     你一旦调用这个find element方法的时候呢
[10:50/37:44]     一旦他找不到
[10:51/37:44]     他就会报这个叫做no such element的这个no such element的这个ever
[10:57/37:44]     那这如果说我们要想去解决这样的一个问题
[11:01/37:44]     我们可以直接去添加一个影视等待的配置就可以去解决
[11:07/37:44]     那怎么去添加呢
[11:08/37:44]     那这个代码也非常简单
[11:09/37:44]     就是这个driver店
[11:11/37:44]     Him play the in place until e wait
[11:13/37:44]     然后在这个括号里面呢
[11:15/37:44]     我们设定一个他最长的一个等待时间
[11:18/37:44]     比如说是一秒还是几秒
[11:19/37:44]     然后设置这个
[11:22/37:44]     这个是一个
[11:23/37:44]     这个是一个在整个Java实例过程当中都会生效的这样的一个配置
[11:28/37:44]     就是我们在这儿设置一个等待时间
[11:30/37:44]     他会轮询的去这个查找元素是否出现
[11:34/37:44]     如果说整个过程当中没有出现的
[11:37/37:44]     那那么它就会抛出一个异常
[11:40/37:44]     那这个呢
[11:41/37:44]     就是它的一个这个使用
[11:43/37:44]     这个就是它的一个使用
[11:44/37:44]     以及它的一个使用原理
[11:46/37:44]     话不多说
[11:47/37:44]     我们先来使用一下
[11:49/37:44]     我们直接在我们的这个find element的前面呢
[11:52/37:44]     我们给它加一个配置叫做driver
[11:54/37:44]     点
[11:57/37:44]     In place until e wait
[11:59/37:44]     然后我们等待三秒
[12:00/37:44]     跟刚刚的尝试等待效果是一样的
[12:02/37:44]     那这时候我们再来看
[12:03/37:44]     我们去找我们的个人中心的时候
[12:05/37:44]     看会不会报错
[12:06/37:44]     我们执行一下
[12:09/37:44]     OK
[12:10/37:44]     我们发现
[12:11/37:44]     是不是就没有任何的这样的一个报错了
[12:15/37:44]     那这个呢
[12:16/37:44]     就是隐士等待他的一个使用的一个好处
[12:19/37:44]     那我们来点一下
[12:20/37:44]     我们来看一下它的源码是什么源码
[12:22/37:44]     告诉我们呢
[12:23/37:44]     首先这个源码它是一个你需要传一个参数
[12:26/37:44]     叫做他们的time to wait
[12:28/37:44]     是一个必填的这样的一个参数
[12:31/37:44]     然后他说什么呢
[12:32/37:44]     他说设置一个
[12:34/37:44]     设置一个这个影视等待的一个时间
[12:38/37:44]     为了让我们的元素能够去找到
[12:40/37:44]     然后他这个呢
[12:42/37:44]     是全局生效的
[12:43/37:44]     他这个是全局生效的
[12:46/37:44]     在就是在一个在一个时间的一个赛事里面呢
[12:50/37:44]     可以去设置一次
[12:51/37:44]     好
[12:52/37:44]     在这个过程当中呢
[12:54/37:44]     我给大家看一下
[12:55/37:44]     它是这个driver dian Ying him plays an t wait
[12:58/37:44]     它是怎么样去生效的
[13:00/37:44]     首先呢
[13:01/37:44]     我们在这个地方
[13:03/37:44]     在我们的in place certainly wait的这一行的下一行
[13:07/37:44]     就是我们24行打一个断点
[13:08/37:44]     然后我们点击的bug
[13:13/37:44]     这个时候
[13:14/37:44]     我们来看一下
[13:15/37:44]     这时候我们看一下我们的整个的堤坝的这个模式里面
[13:18/37:44]     它这个变量发生什么变化
[13:21/37:44]     这个变量里面呢
[13:22/37:44]     有一个叫做driver
[13:23/37:44]     然后这个driver呢
[13:24/37:44]     然后我们点一下它
[13:26/37:44]     点一下它之后呢
[13:27/37:44]     我们在这个地方
[13:28/37:44]     我们就能够找到有一个叫做timeout的这样的一个选项
[13:33/37:44]     我们在这儿大家注意到没有
[13:34/37:44]     这个有个叫做in the in pleasant UN pleasant wait
[13:40/37:44]     然后在这儿设置的是3.0秒
[13:42/37:44]     大家可以看到吧
[13:43/37:44]     设置是3.0秒
[13:45/37:44]     OK
[13:46/37:44]     那如果说大家可能说
[13:47/37:44]     老师
[13:48/37:44]     那这个是不是系统默认的一个配置
[13:50/37:44]     可以跟大家说的是不是
[13:52/37:44]     如果说我们现在把这一行在注释掉
[13:56/37:44]     然后我们再重启一下我们的代码
[13:58/37:44]     我们点这个按钮
[13:59/37:44]     这个叫做run
[14:01/37:44]     然后我们点一下
[14:03/37:44]     那这时候我们再跑到这里来
[14:04/37:44]     我们再来看一下
[14:05/37:44]     我们再点这个driver
[14:06/37:44]     我们看一下
[14:07/37:44]     我们再看一下timeout这个配置
[14:09/37:44]     这时候大家发现了没
[14:11/37:44]     In pleasant wait这个选项它变成了零秒OK
[14:15/37:44]     通过大家从通过这个过程大家就可以看到
[14:18/37:44]     其实他整个过程就是对我们这个driver实例的这个timeout去做了一个配置
[14:23/37:44]     然后后面我们在每一次find element的时候呢
[14:26/37:44]     他都会去查找这个timeout里面这个in place ST这个wait有没有去做配置
[14:31/37:44]     如果有做配置的话呢
[14:33/37:44]     那么他
[14:34/37:44]     那么这个就他就会遵循这个显示等待这样的一个逻辑
[14:37/37:44]     那这个显示等待为什么要去设置这样的一个超市时间呢
[14:42/37:44]     我们在这儿加一个这个
[14:44/37:44]     超时时间作用什么意思
[14:47/37:44]     比如说我们在这儿
[14:48/37:44]     我们比如说这个超时时间我们设置成三秒
[14:52/37:44]     然后我们故意把这个定位改错
[14:54/37:44]     比如说还是BI X pass
[14:55/37:44]     然后这个通过文本去查找一个方式
[14:58/37:44]     那这种查找方式我具体怎么去写
[15:00/37:44]     这种表达式具体怎么去写
[15:03/37:44]     我们在后面会给大家做详细讲解
[15:05/37:44]     然后我们在个人中心的后面
[15:07/37:44]     比如说加几个
[15:08/37:44]     随便加几个
[15:09/37:44]     确保这个定位是找不到的
[15:11/37:44]     然后这时候我们再执行一下
[15:14/37:44]     我们看看他会不会一直在这里查找
[15:16/37:44]     导致我们的这个进程就一直在阻塞在这里
[15:20/37:44]     这时候我们可以看到
[15:21/37:44]     他还是报错了
[15:22/37:44]     我们看报什么错
[15:23/37:44]     他说no such element对吧
[15:25/37:44]     但是在整个的这个过程当中
[15:27/37:44]     我们就可以注意到
[15:29/37:44]     虽然说虽然说我们给他设置了这样的一个饮食等待
[15:33/37:44]     但是他最后发现当他找不到的时候a他在这个三秒之外它就会干嘛
[15:39/37:44]     他就会直接这个依然会把这个报错信息抛出来
[15:43/37:44]     那这个就是影视等待的这样的一个使用好那我们来总结一下阿强
[15:48/37:44]     这个是为了解决强制等待的一个问题
[15:56/37:44]     这个
[15:59/37:44]     省方法
[16:03/37:44]     代码
[16:05/37:44]     代码一开始运行的时候就添加
[16:11/37:44]     影视
[16:14/37:44]     等待的配置
[16:15/37:44]     注意影视等待
[16:20/37:44]     是全局生效的
[16:25/37:44]     什么叫做全局生效
[16:27/37:44]     比如说他不只适用于犯的什么个人中心
[16:30/37:44]     比如说我现在不仅贩的个人中心
[16:32/37:44]     我还犯的什么题库什么之类的
[16:34/37:44]     那所有的这个一整个过程呢
[16:37/37:44]     如果说按照我们强制等待的方式
[16:38/37:44]     我们是不是需要在每一行的前面加一个time.sleep
[16:42/37:44]     对吧
[16:43/37:44]     但是我们一旦加了这个影视等待之后
[16:46/37:44]     我们就不需要在每一行的前面都去加这个影视奶奶配置
[16:50/37:44]     我们只需要在代码运行一开始就是所有的查找
[16:55/37:44]     所以在所有的饭的
[16:59/37:44]     Element
[17:02/37:44]     动作之前就
[17:05/37:44]     执行四代码
[17:08/37:44]     那这种呢
[17:09/37:44]     就是它的一个使用方法
[17:11/37:44]     好
[17:12/37:44]     那接下来呢
[17:13/37:44]     我们再来看一下
[17:14/37:44]     那如果说我要想去修改隐身的那一个配置
[17:17/37:44]     怎么去修改呢
[17:19/37:44]     那修改也非常简单
[17:21/37:44]     比如说我们在这个位置
[17:22/37:44]     我们直接把它给它改成him pleasant5秒
[17:26/37:44]     这时候他就会全局的去进行修改了
[17:29/37:44]     我们来看一下整个的一个过程
[17:31/37:44]     我们在这儿打一个断点
[17:32/37:44]     然后我们在25号打一个点
[17:35/37:44]     然后27号打一个断点
[17:37/37:44]     然后使用的bug的方式运行
[17:41/37:44]     然后这时候我们来看一下配置
[17:43/37:44]     它是不是三秒的一个等待时间
[17:45/37:44]     然后这时候我们再往后
[17:48/37:44]     然后我们跳到下一个断点
[17:50/37:44]     就是从上25这个断点跳到27这个断点呢
[17:54/37:44]     我们直接点这个按钮
[17:55/37:44]     叫做resume
[17:57/37:44]     点这个resume就是代表从上一个点掉到下一个断点
[18:00/37:44]     这时候我们就会发现
[18:02/37:44]     我们影视等待这个配置是不是改变了
[18:05/37:44]     那这个呢
[18:06/37:44]     就是修改我们影视等待的一个配置的这样的一个方法
[18:12/37:44]     在这儿需要给大家强调的是饮食等待需要注意的有那么几点
[18:16/37:44]     那第一点呢
[18:18/37:44]     待会改成注意吧
[18:23/37:44]     一定要在代码一开始的时候
[18:27/37:44]     使用一定要在代码一开始时候运行
[18:31/37:44]     就添加这个影视等待的一个配置
[18:33/37:44]     那这是他第一点的一个注意事项
[18:35/37:44]     那第二点的一个注意事项
[18:38/37:44]     注意这个影视
[18:46/37:44]     只能解决
[18:49/37:44]     元素查找的问题不能解决元素交互的
[18:56/37:44]     问题
[18:57/37:44]     那有的同学到时候可能会问了说
[18:59/37:44]     老师
[19:01/37:44]     那我比如说他这时候报的不是说这个找不到
[19:05/37:44]     就是不是unable to locate element
[19:07/37:44]     可能报的是什么
[19:09/37:44]     International就是Canada international就是元素不可交互的这样的问题
[19:14/37:44]     那隐士等待呢
[19:15/37:44]     是没办法去解决元素不可交互的一个问题的
[19:19/37:44]     那元素不可交互的问题由谁来解决呢
[19:21/37:44]     这个是我们下一个要学习的部分
[19:23/37:44]     就是我们的
[19:26/37:44]     就是我们的一个显示等待OK
[19:28/37:44]     我们来总结一下
[19:30/37:44]     在一种场景下呢
[19:31/37:44]     元素可以找到
[19:32/37:44]     但是使用点击等操作呢
[19:35/37:44]     就会出现这样的一个报错
[19:37/37:44]     我们来找一个场景吧
[19:39/37:44]     这样子说大家肯定很难理解
[19:40/37:44]     我们直接找一个场景在这儿呢
[19:43/37:44]     我们现在切换一下演练环境
[19:46/37:44]     我们切换一下演练环境
[19:47/37:44]     我们把演练环境切换成不是VIP点测试人了
[19:51/37:44]     我们换成这个VIP点测试点这个斜杠警号斜杠u s de的这个部分呢

![image-20221211220855850](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211220855850.png)[19:57/37:44]     注意一下
[19:58/37:44]     大家注意一下
[19:59/37:44]     大家这个这个切换演练环境的时候去复制这个URL
[20:04/37:44]     不要直接手敲
[20:06/37:44]     手敲可能会找不到
[20:07/37:44]     那我们现在呢
[20:09/37:44]     把这个u s de d给他复制下来
[20:11/37:44]     那接下来我们要做一个什么样的一个事情呢
[20:15/37:44]     我们要做的是这样的一个事情
[20:18/37:44]     这个消息提示
[20:33/37:44]     OK
[20:34/37:44]     我们要使用这个影视等代练来练习一下
[20:38/37:44]     就是看这个显示等待不能去解决的一些问题
[20:43/37:44]     那接下来呢
[20:44/37:44]     我们要完成的这样的一个操作呢
[20:46/37:44]     就是我们会去点击一下这个消息提示
[20:50/37:44]     我们现在在我们这里点击消息提示的时候是正常的
[20:52/37:44]     对不对
[20:53/37:44]     那我们来看一下
[20:55/37:44]     我们实际演练的过程当中
[20:56/37:44]     会不会有什么样的一个问题
[20:58/37:44]     好
[21:00/37:44]     那同样呢
[21:01/37:44]     我们回到我们的web wait这样的一个代码
[21:04/37:44]     我们先把上面的这些饮食等待全部都注释掉
[21:08/37:44]     我们重新定义一个方法吧
[21:10/37:44]     因为这个都不太一样
[21:11/37:44]     重新定一个方法
[21:13/37:44]     就是专门适用于这个显示等待
[21:18/37:44]     显示等待
[21:21/37:44]     那我们就还是wait吧
[21:28/37:44]     显示等待
[21:40/37:44]     瘦吧瘦吧
[21:42/37:44]     那我们在这儿还是做跟上面一样的操作
[21:44/37:44]     我们先打开一个谷歌浏览器
[21:49/37:44]     我们再注意
[21:51/37:44]     访问这个页面不在是我们的学员系统了
[21:54/37:44]     换一下我们换成我们的这个练习的一个网站
[21:58/37:44]     因为这个环境就是如果去找的话
[22:00/37:44]     他可能不稳定
[22:01/37:44]     而且比较难模拟
[22:02/37:44]     所以我们索性就干脆自己去写一个
[22:05/37:44]     然后在这儿住一调用方法
[22:06/37:44]     我们不再是Vs leap了
[22:10/37:44]     我们调用方法也改一下
[22:11/37:44]     叫做微瘦
[22:15/37:44]     好
[22:16/37:44]     那我们现在要访问一个新的环境
[22:18/37:44]     叫做这个u s de d
[22:20/37:44]     然后在这个USB里面呢
[22:22/37:44]     我们直接driver.get打开这个网页
[22:26/37:44]     我们要做一个点击对不对
[22:27/37:44]     那第一步先find find之后使用
[22:30/37:44]     点我们先看他有没有ID
[22:33/37:44]     我们回到这儿
[22:34/37:44]     我们右键检查
[22:36/37:44]     在这儿大家可以看到有一个success BT n ID
[22:39/37:44]     那我们直接copy一下这个ID
[22:42/37:44]     直接使用ID定位然后在这儿呢
[22:44/37:44]     我们直接点click
[22:46/37:44]     这时候我们执行一下代码
[22:48/37:44]     我们看看会不会有什么样的一个问题
[22:50/37:44]     我们直接执行一下
[22:59/37:44]     那整个过程
[23:00/37:44]     大家可能看的不是非常清楚
[23:03/37:44]     大家看着这个代码好像没有任何一个报错
[23:05/37:44]     对吧
[23:06/37:44]     那我们仔细再来看一下
[23:07/37:44]     我们执行一下
[23:08/37:44]     看看他到底有没有点成功
[23:10/37:44]     这个是我们的一个目的
[23:16/37:44]     OK
[23:17/37:44]     其实他已经做了点击动作了
[23:18/37:44]     但是我们可以看到
[23:19/37:44]     正常来说我们点成功是不是会有一个这样的消息提示的这样的一个弹窗
[23:25/37:44]     但是我们在等待五秒
[23:26/37:44]     我们再执行一下
[23:27/37:44]     看看有没有对应哪个弹窗
[23:34/37:44]     大家可以看到没有任何的对应的一个弹窗
[23:38/37:44]     OK
[23:39/37:44]     那针对于这样的一个问题
[23:40/37:44]     我们使用显示等待可不可以解决呢
[23:42/37:44]     我们在这儿加一个显示等待试一下
[23:45/37:44]     比如说我们让他等待一个
[23:49/37:44]     等待一个长1.85秒吧
[23:52/37:44]     然后我们执行一下
[23:58/37:44]     我们就会发现代码很快就结束了
[24:00/37:44]     因为它其实找到这个元素了
[24:02/37:44]     但是这个元素这个时候呢
[24:04/37:44]     他可能是干嘛
[24:05/37:44]     可能是不可点击的
[24:08/37:44]     他就不会报错
[24:10/37:44]     其实他根本没有达到我们想要的一个效果
[24:12/37:44]     我们想要的效果是让他能够去点击这样的一个按钮
[24:16/37:44]     好那针对于这样的一个问题
[24:18/37:44]     我们来看一下问题是什么
[24:22/37:44]     问题元素可以找到
[24:28/37:44]     点击效果却没有触发
[24:35/37:44]     那这个原因是什么呢
[24:38/37:44]     原因原因呢
[24:39/37:44]     其实我在这个PPT里面也给大家做了一个汇总
[24:43/37:44]     原因他可能有非常多种
[24:45/37:44]     比如说就是他元素可以找到
[24:48/37:44]     但是涉及到交互到交互等操作出现报错或者没有效果的一个情况
[24:53/37:44]     就是页面加载是异步加载这样一个过程
[24:56/37:44]     通常呢
[24:58/37:44]     大家可以看一下
[25:02/37:44]     我们我在这儿给大家简单的聊一下这个事儿
[25:06/37:44]     大家可以看到
[25:07/37:44]     我们这个是我们整个页面的一个加载的一个过程
[25:10/37:44]     那我们可以看到它加载怎么加载的
[25:14/37:44]     他不是说框一下一条信息
[25:16/37:44]     把所有的什么JSZS乱七八糟所有的东西全部给我们加载出来
[25:21/37:44]     不是这样的一个过程
[25:22/37:44]     而是他先加载一部分
[25:23/37:44]     在加载一部分
[25:24/37:44]     所以说大家经常可以看到我们访问某个页面的时候
[25:27/37:44]     这个页面是先出来这块儿
[25:29/37:44]     再出来那块儿
[25:30/37:44]     那这是我们的这个
[25:33/37:44]     这个呢
[25:34/37:44]     是我们的第一个
[25:35/37:44]     我们要了解到一个事情
[25:36/37:44]     页面的元素加载是一个异步加载的过程
[25:39/37:44]     那这个通常HTML会先加载完成
[25:42/37:44]     就是我们的这个页面的一个元素的一个布局会先加载完成
[25:48/37:44]     我们的CSS和JS会后加载完成
[25:51/37:44]     那当我们的JS后加载完成
[25:53/37:44]     这个会导致一个什么样的过程呢
[25:55/37:44]     我们可以来画一个这样的一个时间的一个轨迹
[26:08/37:44]     给大家看一下它的一个过程是什么样子
[26:11/37:44]     我们在这儿搞一个画笔
[26:14/37:44]     然后这个呢
[26:15/37:44]     这个红色的框框代表的是我们的HTML的一个加载
[26:19/37:44]     然后绿色的框框呢
[26:20/37:44]     代表的是我们JS和CS一个Jia Jia好
[26:24/37:44]     那这个时候呢
[26:26/37:44]     当我们去做饭的时候
[26:30/37:44]     找一个这个画笔
[26:31/37:44]     当我们去做饭的时候
[26:32/37:44]     其实他只要在在这个红色的框框结束之后
[26:36/37:44]     在红色的框框结束之后去找find
[26:40/37:44]     通常就不会报错
[26:41/37:44]     我们的一些点击
[26:43/37:44]     涉及到JS交互的一些行为
[26:45/37:44]     他是必须要等到我们的绿色的框框加载完成之后再去执行
[26:49/37:44]     才不会去去进行报错
[26:51/37:44]     所以说这个
[26:52/37:44]     就是我们这个影视等待没有办法解决的问题
[26:55/37:44]     因为隐士等待他只管到我们红色框框的这一个流程的一个部分
[27:01/37:44]     他管不到我们绿色框框的这个部分
[27:03/37:44]     那绿色的框框这个时候怎么办呢
[27:06/37:44]     就只能使用隐式等待的一个方式
[27:09/37:44]     就是等待它元素的某一些
[27:11/37:44]     就是可点的一些属性
[27:14/37:44]     或者相关的一些JS逻辑
[27:16/37:44]     下载完成之后
[27:17/37:44]     我们再去对这个元素去进行操作
[27:21/37:44]     那这个也就是我们后面所说的元素是否存在
[27:24/37:44]     就是我们看到他有没有
[27:26/37:44]     这是由HTML决定的
[27:28/37:44]     那元素所有的交互呢
[27:29/37:44]     是由我们的CSS和JS决定的
[27:33/37:44]     内隐世等待只能关注元素能不能够找到
[27:35/37:44]     不关注元素能不能够点击或者进行其他的一个交互
[27:40/37:44]     那显示等待它怎么样去使用的呢
[27:42/37:44]     我们在这儿给大家列列了一个初级的一个使用方式
[27:45/37:44]     因为显示等待他的一个使用要比前两种等待方式都复杂很多
[27:51/37:44]     所以说更尖更进阶的使用我们会放在后面大家去做详细讲解
[27:55/37:44]     我们在这儿先给大家介绍一种用法去解决这样的一个问题
[27:59/37:44]     就是他在我们会实例化一个叫做web driver wait这样的一个类

![image-20221211221301199](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211221301199.png)[28:03/37:44]     然后在这个类实例化的过程当中呢
[28:06/37:44]     我们会给它传上几个参数
[28:08/37:44]     第一个是我们的driver的一个实例
[28:10/37:44]     就是这个我们通过这个web的Chrome得到这样的一个实力
[28:14/37:44]     就是他最长的一个等待时间
[28:16/37:44]     代表的是我针对于这个条件
[28:19/37:44]     我最长可以等待十秒还是20
[28:22/37:44]     十秒这个时候由我们自己去设定的然后第三个呢
[28:25/37:44]     是他的一个轮询时间
[28:26/37:44]     这个轮询时间是可设置可不设置的轮询时间代表就是大家可以看到我们后面有一个until
[28:32/37:44]     就是一个结束条件OK
[28:34/37:44]     我们梳理一下整个过程
[28:36/37:44]     就是说他在这个实例化的时候呢
[28:40/37:44]     他会不停的去调用这个方法呢
[28:42/37:44]     它调用的频次呢
[28:43/37:44]     是由轮询时间去决定的
[28:45/37:44]     那他一共就是它一共钓用多长时间
[28:49/37:44]     就是多长时间就结束了
[28:52/37:44]     就是比如说十秒之后他就不再会去调用
[28:55/37:44]     是由第二个参数最长等待时间去决定的好
[28:58/37:44]     那它的原理就是在这儿
[28:59/37:44]     我们前面已经说过了
[29:00/37:44]     在最长时间等待内呢
[29:02/37:44]     轮询是否满足我们的这样的一个NT里面的一个结束条件
[29:07/37:44]     这样子书
[29:08/37:44]     大家肯定会觉得很懵
[29:09/37:44]     我们还是要靠写代码去了解整个的这样的一个过程
[29:13/37:44]     那同样的我们演练环境还是我们这个USB
[29:17/37:44]     然后在这个代码里面呢
[29:18/37:44]     我们注意一下我们做了什么事儿
[29:20/37:44]     我们在这儿呢
[29:21/37:44]     使用了这个web driver wait
[29:23/37:44]     然后web driver wait里面呢
[29:24/37:44]     传入了几个
[29:25/37:44]     第一个是driver的一个参数
[29:27/37:44]     第二个是最长等待时间的一个参数
[29:28/37:44]     然后调用了until until代表的是就是他这个括弧里面返回的是不是true
[29:35/37:44]     然后在这个里面我们传了一个表达式
[29:37/37:44]     这个expected condition
[29:39/37:44]     这个是selenium官方提供的这样的一个用法
[29:44/37:44]     我们这样说大家肯定很难理解
[29:47/37:44]     我们就直接来写就OK了
[29:49/37:44]     我们在这儿首先实例化一个web
[29:54/37:44]     Wait
[29:56/37:44]     这样的一个方法好
[29:57/37:44]     我们给他做一个导入
[30:01/37:44]     如果你装了selenium的话
[30:02/37:44]     它会自动去装这样的一个库然后呢
[30:06/37:44]     现在我们先不要着急
[30:07/37:44]     我们点进去它的源码
[30:09/37:44]     我们来看一下
[30:10/37:44]     点进去源码我们可以看到
[30:12/37:44]     首先在它的构造函数里面呢
[30:14/37:44]     有一个叫做in it的一个构造函数
[30:16/37:44]     这个in it里面呢
[30:17/37:44]     传了这样的三个参数
[30:19/37:44]     然后同时呢
[30:21/37:44]     他还提供了两个方法
[30:22/37:44]     第一个叫做until
[30:23/37:44]     第二个叫做until note对吧
[30:25/37:44]     好
[30:26/37:44]     那在这儿我们现在
[30:27/37:44]     先不要去做过多过多的一个解析
[30:29/37:44]     因为大家可能很难理解
[30:30/37:44]     我们在
[30:31/37:44]     等到大家在练习两个章节之后
[30:34/37:44]     我们在后面章节会给大家去做web的weight详细的解析
[30:39/37:44]     我们先学会使用
[30:41/37:44]     我们只需要知道第一个参数
[30:43/37:44]     第一个参数是
[30:49/37:44]     我们给他传入一个driver
[30:52/37:44]     那第二个参数呢
[30:54/37:44]     是我们最长等待时间
[30:55/37:44]     我们给她设定为十秒
[30:56/37:44]     然后我们点一下
[30:57/37:44]     这时候就有一个until的一个方法
[30:59/37:44]     然后这个until里面呢
[31:01/37:44]     它需要传是一个method
[31:02/37:44]     那这个method怎么去传呢
[31:04/37:44]     有几种方式
[31:05/37:44]     我们先来给大家介绍第一种方式
[31:07/37:44]     我们在这儿可以使用这个selenium所提供的一就是封装好的一些
[31:14/37:44]     就是这个accepted condition的一个方法
[31:17/37:44]     我们看一下Celine的一个官方网站
[31:22/37:44]     然后在这个地方呢
[31:23/37:44]     有一个web driver wait
[31:25/37:44]     然后在这儿有一个wait
[31:28/37:44]     然后我们找到这个
[31:31/37:44]     显示等待OK
[31:33/37:44]     显示等待这里有一个叫做expected conditions
[31:35/37:44]     然后在这里面呢
[31:37/37:44]     它有就是它这个使用方式
[31:39/37:44]     有非常多
[31:40/37:44]     我们在这儿直接使用一种
[31:44/37:44]     就叫做这个
[31:46/37:44]     Click拨
[31:48/37:44]     或者我们直接看一下
[31:49/37:44]     就是我们PPT里面这个
[31:51/37:44]     Exception expected conditions
[31:54/37:44]     好
[31:55/37:44]     那我们把这个expected conditions直接导入进来
[31:59/37:44]     导入之后呢
[32:00/37:44]     他这里有非常多的一个方法
[32:03/37:44]     我们先使用其中一种叫做element job click the clinical
[32:07/37:44]     那这个element To Be click able里面呢
[32:09/37:44]     他传的参数是
[32:12/37:44]     我们再写一下
[32:15/37:44]     第二个参数是最长等待时间
[32:20/37:44]     然后然后调用NT
[32:25/37:44]     Until
[32:26/37:44]     方法内
[32:29/37:44]     需要结合
[32:34/37:44]     或者自己封装的方法进行使用好
[32:41/37:44]     那在这儿的时候呢
[32:42/37:44]     我们在这儿需要传递的这个就是element job can iqbal
[32:46/37:44]     它所需要的一个参数呢
[32:48/37:44]     就是我们的一个元素定位
[32:49/37:44]     在这儿需要注意的是
[32:53/37:44]     这个
[32:55/37:44]     使用exception condition4
[33:02/37:44]     的参数传入的都是一个元组
[33:06/37:44]     什么叫做一个元组
[33:07/37:44]     我们在上面传范大力名词的时候呢
[33:09/37:44]     我们是以两个参数的方式传入进来的
[33:14/37:44]     那员组呢
[33:15/37:44]     就是代表是我们还是传这两个参数
[33:17/37:44]     但是呢
[33:18/37:44]     我们要给它加一个小括号
[33:20/37:44]     所以说我们在这儿直接败点
[33:23/37:44]     这个去找这个
[33:25/37:44]     Success
[33:30/37:44]     Success保存
[33:32/37:44]     好
[33:33/37:44]     那我们去找他的一个
[33:35/37:44]     点ID success but an这样的一个元素
[33:39/37:44]     然后确定它是可以被点击的
[33:41/37:44]     然后我们再往下去进行执行
[33:43/37:44]     然后这个呢
[33:45/37:44]     就是我们整体的这样的一个逻辑
[33:47/37:44]     在这儿有几个需要注意的点是
[33:49/37:44]     首先我们要知道web driver wait实例化的时候
[33:51/37:44]     它需要最少需要传哪两个参数
[33:53/37:44]     然后第二
[33:54/37:44]     我们要知道需要去掉它的NT
[33:55/37:44]     有方法
[33:56/37:44]     第三
[33:57/37:44]     我们需要知道在调用这个except except ID condition的时候呢
[34:02/37:44]     我们在这里面
[34:03/37:44]     传入的是一个元祖
[34:04/37:44]     传入的是一个括号
[34:06/37:44]     然后里面代表的是它的一个元素信息
[34:08/37:44]     大家可以看到多一层括号
[34:10/37:44]     一定要注意这个点
[34:16/37:44]     大家可以理解为既多一层括号儿
[34:20/37:44]     小括号
[34:22/37:44]     那这时候我们加了这个
[34:24/37:44]     显示等待之后
[34:25/37:44]     我们看一看我们能不能够成功的去进行点击
[34:33/37:44]     这时候我们发现好像
[34:36/37:44]     他一直在等是吧
[34:38/37:44]     这时候我们可以看到这个效果
[34:40/37:44]     大家可能看得不是很清楚
[34:42/37:44]     我们在这儿
[34:43/37:44]     我们再执行一下
[34:44/37:44]     他一直在等那个按钮可以被点击
[34:51/37:44]     大家可以看到消息提示是不是出来了
[34:55/37:44]     是不是已经达成了我们想要的一个效果
[34:57/37:44]     就是真真实实的去对我们的这个按钮去进行一个点击
[35:01/37:44]     那这个呢
[35:02/37:44]     就是我们显示等待的一个基本使用
[35:05/37:44]     在这一章节呢
[35:06/37:44]     对于大家这个显示等待的一个基本使用呢
[35:08/37:44]     就要求大家知道显示等待的使用场景是什么
[35:12/37:44]     以及它的结合这个expected condition的这个element job click board这个使用方法是如何去进行使用的
[35:19/37:44]     也就是我们的一些简单使用
[35:21/37:44]     在这在这我也写了这点
[35:23/37:44]     就是注意在我们这一章节
[35:25/37:44]     我们先关注于使用
[35:28/37:44]     在下一章节我们会给大家具体去讲它的一个使用原理
[35:32/37:44]     那我们来对我们所学习的内容去做一个总结
[35:36/37:44]     其实就是我们今天的三种等待方式
[35:39/37:44]     我们如果说要是熟练的使用这三种等待方式呢
[35:44/37:44]     我们一定要明白它的使用方式和它的一个使用场景
[35:48/37:44]     以及它的使用原理
[35:49/37:44]     我们在这总结一下
[35:50/37:44]     首先第一种呢
[35:51/37:44]     就是我们的一个直接等待
[35:53/37:44]     他使用的一个使用方式呢
[35:55/37:44]     就是这个time to sleep
[35:56/37:44]     然后后面加一个等待时间
[35:57/37:44]     这个等待时间多了个小括号
[36:00/37:44]     大家注意多了个小括号
[36:01/37:44]     然后它的一个使用原理呢
[36:03/37:44]     就是强制我们的县城去进行等待
[36:05/37:44]     那适用场景呢
[36:07/37:44]     它是不是用于正式
[36:09/37:44]     就是正式在跑的
[36:10/37:44]     在上线的一些自动化测试代码的
[36:13/37:44]     因为他前面已经说了
[36:15/37:44]     它还是具有这个不确定性
[36:18/37:44]     包括会影响我们用力执行效率
[36:20/37:44]     那所以说它的使用场景就是作为一个调试代码取临时性的去进行一个添加
[36:25/37:44]     那第二个呢
[36:26/37:44]     就是我们的一个隐士等待
[36:27/37:44]     那隐士等待一个使用方式呢
[36:29/37:44]     需要调用这个driver de in place center
[36:32/37:44]     Wait这样的一个方法
[36:33/37:44]     它这个原理呢
[36:35/37:44]     就是在我们设定的这个等待时间的范围内轮询的去查找我们的元素
[36:40/37:44]     它所解决的问题
[36:41/37:44]     就是解决找不到元素的问题
[36:43/37:44]     但是呢
[36:44/37:44]     他是没有办法去解决元素交互的一个问题的
[36:48/37:44]     交互就是比如说点击
[36:49/37:44]     输入等等这种类型行为
[36:52/37:44]     然后还有第三种呢
[36:54/37:44]     交互行为
[36:55/37:44]     怎么交互的这种行为怎么去解决呢
[36:57/37:44]     就比如说他就可以使用显示等待的一个方式
[37:00/37:44]     那显示等待呢
[37:01/37:44]     它的一个使用就是这个web jar with这样的一个类
[37:04/37:44]     然后在这在调用的过程当中呢
[37:06/37:44]     使用这个传入一个Java实例
[37:09/37:44]     然后传入最长的一个等待时间
[37:11/37:44]     然后直接调用它的NT有方法
[37:13/37:44]     那它的原理呢
[37:14/37:44]     就是设定特定的等待条件进行轮询操作
[37:18/37:44]     它适用的场景就是解决特定条件下的等待问题
[37:21/37:44]     比如说点击等交互性存在交互性的这样的一些行为OK
[37:28/37:44]     那这一部分呢
[37:29/37:44]     就是啊
[37:30/37:44]     我们的在这一章节所
[37:32/37:44]     一定要掌握的三个知识点
[37:35/37:44]     就是他们的使用方式
[37:36/37:44]     原理和使用场景
[37:37/37:44]     那显示等待的这个更高阶的使用
[37:40/37:44]     我们放在后面的章节给大家去进行介绍



### 8、常见控件交互方法
[00:00/19:47]     [以下字幕均由机器生成]我们要学习的内容
[00:01/19:47]     就是常见控件的一个交互方法
[00:04/19:47]     在上一节课的时候呢
[00:06/19:47]     我们学习了常见控件的一个定位方法
[00:09/19:47]     那什么叫做定位呢
[00:10/19:47]     就是比如说我们现在打开一个百度这样的一个页面
[00:15/19:47]     那我们想要搜索或者说想要定位到这个页面的某一个元素
[00:19/19:47]     比如说我们想要定定位百度一下这个button OK
[00:22/19:47]     那我们可以右键一下检查
[00:24/19:47]     然后把鼠标放到这儿
[00:25/19:47]     那这一块儿呢
[00:26/19:47]     我们拿到它的一个元素之后呢
[00:27/19:47]     我们就可以对它进行一个定位
[00:29/19:47]     那这一部分呢
[00:30/19:47]     叫做元素的定位
[00:33/19:47]     但是我们除了需要对这个元素去进行定位之外呢
[00:36/19:47]     我们通常
[00:37/19:47]     还需要去对这个元素进行一系列操作
[00:41/19:47]     比如说有哪些常见操作呢
[00:42/19:47]     比如说我们定位到一个输入框
[00:44/19:47]     我们是不是要进行一些输入的操作
[00:46/19:47]     那我们输入一个霍格沃兹测试开发对吧
[00:51/19:47]     那这个可能是我们要进行操作那比如说可能会有点击对吧
[00:55/19:47]     那我们在这儿我们可能需要点击一下
[00:57/19:47]     按钮或者点击一下某个这个链接等等
[01:01/19:47]     那除了点击之外
[01:02/19:47]     还有比如说清空对吧
[01:05/19:47]     有一些历史的数据呢
[01:06/19:47]     我们需要给他做清空
[01:08/19:47]     那这些呢
[01:09/19:47]     是属于我们的一个常见的操作
[01:12/19:47]     那同理
[01:14/19:47]     那这些操作呢
[01:15/19:47]     其实对应到我们的章节里面
[01:16/19:47]     就是相当于我们的控件的一个交互
[01:19/19:47]     所以说我们这节课呢
[01:21/19:47]     就是以这个控件的交互为主去进行学习
[01:25/19:47]     然后我们今天呢
**[01:26/19:47]     主要是分成两个部分去进行学习**

![image-20221211222102547](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211222102547.png)[01:28/19:47]     那第一个部分呢
[01:29/19:47]     对应过来的就是我们的元素的操作
[01:33/19:47]     就是获取我们元素元素的一个属性信息
[01:37/19:47]     好
[01:38/19:47]     那这两个部分呢
[01:40/19:47]     我们都把它归类到这个叫做元素的交互当中
[01:44/19:47]     首先我们先来看元素的操作
[01:46/19:47]     我们前面所说的我们常见的操作有点击
[01:49/19:47]     输入
[01:50/19:47]     清空三个操作

![image-20221211222127925](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211222127925.png)[01:52/19:47]     那他是怎么样去使用的呢
[01:54/19:47]     其实非常简单
[01:57/19:47]     我们在这儿就可以看到
[01:58/19:47]     首先啊
[01:59/19:47]     它永远的第一步是我们先要定位到某个元素
[02:02/19:47]     因为我们的这个操作一定是建立在对于对某个元素的一个基础之上的定位到之后呢
[02:10/19:47]     通过点可立刻就可以进行点击的操作
[02:14/19:47]     通过点send kiss
[02:15/19:47]     然后括号里面输入这个这个输入输入这个要输入的内容
[02:21/19:47]     就可以进行输入操作
[02:23/19:47]     那点clear呢
[02:24/19:47]     就可以进行清空的这样的一个操作
[02:27/19:47]     那这个呢
[02:28/19:47]     就是我们三个的常见的操作类型
[02:32/19:47]     那接下来呢
[02:33/19:47]     我们以这个百度
[02:35/19:47]     我们以搜狗的这个页面为例吧
[02:36/19:47]     百度最近老是查这个机器人
[02:39/19:47]     我们就以这个搜狗页面吧
[02:40/19:47]     换一个搜狗
[02:45/19:47]     那我们以搜狗的页面为例
[02:48/19:47]     我们来进行这个输入点击
[02:50/19:47]     比如说我们输入一个霍格沃兹测试开发
[02:54/19:47]     然后我们来进行一个点击操作
[02:57/19:47]     然后我们再来进行一个轻松操作
[02:59/19:47]     我们把这三个操作给大家依次的演示一遍
[03:02/19:47]     首先呢
[03:03/19:47]     我们先把这个搜狗的一个链接复制过来
[03:08/19:47]     好
[03:09/19:47]     我们在这里已经新建了一个文件
[03:11/19:47]     叫做web interest the interaction
[03:14/19:47]     那这是我们定义一个方法
[03:16/19:47]     第一个方法
[03:17/19:47]     比如说我们这个时候呢
[03:18/19:47]     可能就是一个
[03:21/19:47]     这个我们叫他element
[03:23/19:47]     Interaction
[03:29/19:47]     好
[03:30/19:47]     那这个是对应的元素的
[03:33/19:47]     操作
[03:34/19:47]     比如说点击
[03:36/19:47]     然后输入晴空
[03:39/19:47]     好
[03:40/19:47]     那第一个步骤
[03:41/19:47]     我们所有的这个US动画测试
[03:43/19:47]     第一个步骤都是实力话找对象
[03:47/19:47]     这是我永远是我们的第一个步骤
[03:49/19:47]     然后第二个步骤呢
[03:50/19:47]     通常都会打开一个网页
[03:52/19:47]     要不然你对谁去做做操作呢
[03:56/19:47]     打开一个网页
[03:58/19:47]     打开一个也好
[04:00/19:47]     那我们第三个步骤呢
[04:01/19:47]     我们给他做一个定位的
[04:04/19:47]     输入框
[04:07/19:47]     进行输入操作
[04:09/19:47]     那就是我们的第三个
[04:11/19:47]     那我我们输入之后呢
[04:14/19:47]     我们可以尝试一下清空操作
[04:16/19:47]     然后就是对输入框进行清空
[04:21/19:47]     好轻松完成之后呢
[04:23/19:47]     这时候我们输入框已经没有内容了
[04:25/19:47]     然后我们再去再次输入
[04:31/19:47]     然后第六个步骤再点击一下搜索
[04:37/19:47]     那这个呢
[04:38/19:47]     我们接下来就尝试把这六个步骤去做一个实现
[04:41/19:47]     我们先把这个思路列举在这儿
[04:43/19:47]     我们等一下要做什么就非常清晰了
[04:45/19:47]     好那我们第一步
[04:47/19:47]     先倒包倒包的这个这个包呢
[04:50/19:47]     就是叫做web driver啊
[04:51/19:47]     快捷导入
[04:58/19:47]     Web driver点库
[05:00/19:47]     好
[05:01/19:47]     那这是我们的第一个步骤
[05:03/19:47]     实例化
[05:04/19:47]     然后接下来呢
[05:05/19:47]     我们打开一个网页
[05:06/19:47]     我们get
[05:07/19:47]     我们说了使用搜狗这个页面对吧
[05:09/19:47]     那我们回去
[05:11/19:47]     然后输入搜狗
[05:12/19:47]     然后接下来呢
[05:13/19:47]     定位到输入框进行操作
[05:14/19:47]     那我们就driver
[05:15/19:47]     然后定位是不是用饭的
[05:17/19:47]     对吧
[05:18/19:47]     我们前面学习过了
[05:19/19:47]     元素的定位用find
[05:22/19:47]     然后在这个地方呢
[05:23/19:47]     我们的第一个参数需要传入定位方式呢
[05:26/19:47]     我们来看一下它有哪一可以支持我们使用哪一种
[05:30/19:47]     我们看一下它的输入框
[05:32/19:47]     看有没有IDOK
[05:34/19:47]     在这个地方有个叫做query ID
[05:35/19:47]     我们复制一下
[05:38/19:47]     好那我们败点
[05:40/19:47]     我们这个
[05:41/19:47]     需要导入一下
[05:43/19:47]     点ID
[05:44/19:47]     然后对应的就是carry
[05:46/19:47]     然后在这个query里面呢
[05:47/19:47]     去进行一个输入操作
[05:49/19:47]     怎么输入调用
[05:50/19:47]     然后这个时候注意点
[05:52/19:47]     然后send case OK
[05:55/19:47]     输入什么呢
[05:56/19:47]     比如说我们输入一个霍格沃兹测试开发
[06:03/19:47]     那我们成功输入之后
[06:06/19:47]     就是为了让大家看到整个的一个效果
[06:08/19:47]     我们中间等个两秒
[06:10/19:47]     因为代码运行是很快的
[06:12/19:47]     我们人眼是需要一个反应时间的
[06:15/19:47]     好那这时候我们等待两秒之后呢
[06:19/19:47]     下一个
[06:22/19:47]     等待两秒
[06:26/19:47]     我们再进行清空的操作
[06:29/19:47]     那清空也是一样
[06:30/19:47]     首先你要定位到你要清空的对象是谁呢
[06:32/19:47]     我们还是这个输入框
[06:34/19:47]     我们复制一下
[06:35/19:47]     然后对对对对他进行clear
[06:37/19:47]     然后clear之后呢
[06:38/19:47]     我们再来一次等待
[06:42/19:47]     在等待两秒
[06:43/19:47]     那这时候就是为了让我们整个过程看起来比较流畅
[06:47/19:47]     第五步第六步等一下再实现
[06:50/19:47]     那我们现在所实现的就是前四个步骤
[06:52/19:47]     实例化一个Java对象
[06:54/19:47]     打开一个网页
[06:55/19:47]     输入操作
[06:56/19:47]     然后清空操作
[06:57/19:47]     没有做任何的点击额
[06:58/19:47]     然后这时候还不够
[07:00/19:47]     我们现在只是定义了这个方法
[07:03/19:47]     我们记得要去做掉用
[07:04/19:47]     这个是函数的一个知识了
[07:06/19:47]     那怎么去调用呢
[07:07/19:47]     就是输入他的一个函数名element
[07:10/19:47]     Interaction
[07:11/19:47]     我们执行一下
[07:15/19:47]     大家可以看到很快的输入一个输入
[07:17/19:47]     然后很快的就做了一个清空
[07:20/19:47]     OK
[07:21/19:47]     那这个呢
[07:22/19:47]     就是我们输入和清空的操作
[07:23/19:47]     整体来说
[07:24/19:47]     大家只要记住点send kiss代表输入
[07:27/19:47]     点clear代表清空
[07:28/19:47]     正好是也是对应的他们的一个英文名好
[07:31/19:47]     那这时候呢
[07:32/19:47]     我们再次给他做一个输入
[07:35/19:47]     好
[07:35/19:47]     driver.find element
[07:38/19:47]     我们就直接复制这一句就好了
[07:41/19:47]     那我们就要护脖子测试开发二好
[07:44/19:47]     然后这时候呢
[07:45/19:47]     我们不只不是在做清空了
[07:48/19:47]     我们要做的是点击一下搜索
[07:50/19:47]     我们来看一下这个搜索按钮
[07:52/19:47]     他有没有IDs TB好刚好直接复制
[07:58/19:47]     那同样的道理
[07:59/19:47]     Driver
[08:00/19:47]     典范的element
[08:02/19:47]     带点ID
[08:06/19:47]     点click OK
[08:08/19:47]     那这个呢
[08:09/19:47]     就是我们的再次输入的一个操作和搜索的一个操作
[08:13/19:47]     那同理
[08:14/19:47]     为了掩饰的整个的一个效果
[08:16/19:47]     我家两两秒
[08:17/19:47]     那其实如果我们在自动化测试的过程当中
[08:21/19:47]     这个强制等待是不应该被添加的
[08:23/19:47]     我们后面会对它进行优化呢
[08:29/19:47]     首先先会输入
[08:30/19:47]     输入之后清空
[08:32/19:47]     清空之后再次输入获得测试开发二对吧
[08:34/19:47]     然后点击搜索OK
[08:36/19:47]     大家可以看到整个的步骤非常的流畅
[08:38/19:47]     然后对应过来呢
[08:39/19:47]     大家只需要记住三个重点
[08:41/19:47]     我们在这里回顾一下
[08:43/19:47]     第一个send kiss输入对吧
[08:48/19:47]     点send kiss代表输入
[08:50/19:47]     然后第二个点clear代表清空
[08:52/19:47]     然后第三个点click代表点击
[08:56/19:47]     这个是我们最常用的三个操作
[08:58/19:47]     大家一定要熟悉熟练起来
[09:02/19:47]     那我们看完这个对应的元素操作之后
[09:05/19:47]     我们已经知道了是点击输入还有清空
[09:08/19:47]     那接下来我们再来看一下还有一个和元素交互相关的
[09:12/19:47]     也是非常重要的一个也是重要的一个知识点呢
[09:15/19:47]     是什么
[09:16/19:47]     就是获取元素的属性信息

![image-20221211222318616](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211222318616.png)

![image-20221211222612022](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211222612022.png)[09:19/19:47]     那我们先说一下我们为什么要学习他
[09:22/19:47]     当我们定位到元素之后
[09:24/19:47]     我们需要去获取这个元素的一些文本信息
[09:26/19:47]     属性信息
[09:28/19:47]     那其中最长获取的就是它的一个文本信息
[09:31/19:47]     然后包括一些其他的
[09:32/19:47]     可能会能够描述到他业务逻辑的一些属性
[09:37/19:47]     那我们可以根据这些信息
[09:39/19:47]     去进行一个断言和调试
[09:41/19:47]     那接下来呢
[09:42/19:47]     我们会使用这样的一个演练地址
[09:44/19:47]     这个是学院给大家提供的一个这个做UI自动化的一个演练地址
[09:48/19:47]     专门有一个前端地址
[09:50/19:47]     然后我们可以看一下
[09:53/19:47]     那接下来我们要完成的一个操作呢
[09:56/19:47]     就是我们会去获取到元素定位里面
[09:59/19:47]     它对应的一个文本内容
[10:01/19:47]     以及他的一些其他的属性
[10:03/19:47]     OK
[10:04/19:47]     那这时候回到我们的代码里面
[10:06/19:47]     我们把上面这个先收起来
[10:07/19:47]     这个是我们的一个叫做元素操作
[10:17/19:47]     这是元素
[10:21/19:47]     元素操作好
[10:22/19:47]     那我们先把它注释掉
[10:24/19:47]     那我们接下来再订一个叫做这个获取元素属性的这样的一个操作
[10:32/19:47]     我们这时候来一个element get at tr
[10:37/19:47]     那这时候我们第一个步骤还是
[10:40/19:47]     主持一下
[10:41/19:47]     第一个步骤还是
[10:44/19:47]     化汁儿
[10:48/19:47]     然后第二个步骤呢
[10:50/19:47]     我们来看一下
[10:51/19:47]     那第二个步骤呢
[10:54/19:47]     还是打开网页
[10:56/19:47]     然后第三个步骤是先定位一个元素
[11:03/19:47]     并且获取
[11:10/19:47]     那我们就第三个步骤
[11:12/19:47]     那我们第四个步骤呢
[11:14/19:47]     打印这个元素对象
[11:18/19:47]     OK
[11:19/19:47]     我们接下来来看
[11:20/19:47]     那这两个老生常谈了
[11:21/19:47]     现在大家写的应该都熟悉的
[11:23/19:47]     不能再熟悉了
[11:25/19:47]     点
[11:27/19:47]     然后第二个driver.get get谁呢
[11:30/19:47]     我们前面说了
[11:31/19:47]     我们要get我们的一个练习的一个页面
[11:35/19:47]     大家到时候可以直接看的PPT这个地址
[11:38/19:47]     注意啊
[11:39/19:47]     大家去copy一下PPT地址
[11:41/19:47]     而不是直接手敲
[11:42/19:47]     手敲可能出错
[11:44/19:47]     然后我们在这儿driver在这个定位一个元素
[11:47/19:47]     对吧
[11:48/19:47]     那我们定位谁呢
[11:49/19:47]     我们就定位这个叫做元素定位的这样的一个元素
[11:54/19:47]     好我们就用他
[11:56/19:47]     他的ID是locate ID
[11:58/19:47]     我们就通过这个ID这个积累方式就OK了
[12:03/19:47]     那这时候注意
[12:04/19:47]     我们在这个时候呢
[12:06/19:47]     我们需要返回一个web element的对象
[12:10/19:47]     那返回这个element的对象目的是什么呢
[12:13/19:47]     就是我想让大家看一下
[12:14/19:47]     就是我们真正的在进行一些元素的一些属性操作的时候呢
[12:19/19:47]     我想先让大家看看
[12:21/19:47]     当我们使用了driver之后
[12:22/19:47]     他返回回来的是这个对象是什么
[12:26/19:47]     然后他的一些常见的属性有哪些
[12:29/19:47]     我们在这儿做一个打印
[12:30/19:47]     那怎么去看呢
[12:31/19:47]     其实你直接打印
[12:32/19:47]     是什么都看不出来的
[12:34/19:47]     比如说我给你们现在去调用一下这个方法
[12:37/19:47]     我们直接打印一下
[12:41/19:47]     你们可以看到直接打印
[12:44/19:47]     你们什么都看不出来
[12:45/19:47]     我们要通过一个很巧妙的方式
[12:47/19:47]     就是debug的一个方式
[12:48/19:47]     那我们需要先在这个print这个地方呢
[12:50/19:47]     注意啊
[12:51/19:47]     不要在这个地方打断点
[12:52/19:47]     因为你的断点是是执行到你当前这一行
[12:56/19:47]     但是他不会执行当前这一行
[12:58/19:47]     如果说你想要看到web element
[13:01/19:47]     就是他这个对象有哪些元素的话呢
[13:04/19:47]     一定要断点打印在他的下一行
[13:06/19:47]     好在这这个注释一下吧
[13:09/19:47]     断点
[13:18/19:47]     在想看的对象的下一行
[13:23/19:47]     就是等我们上一行这个代码执行完成这个web element有这个对象出来了之后
[13:28/19:47]     我们再去再就是锻炼打到这里
[13:32/19:47]     那这时候我们使用注意
[13:35/19:47]     不要用read模式
[13:36/19:47]     而是要用这个小虫子点一下的bug
[13:40/19:47]     OK
[13:41/19:47]     这时候我们可以看到
[13:42/19:47]     这个代码呢
[13:43/19:47]     就是debug停止在了这里
[13:45/19:47]     那这是我们看一下这里是不是有web element呀
[13:48/19:47]     大家看到了吗
[13:49/19:47]     然后这个web element和我们刚刚打印的内容是不是一样的
[13:53/19:47]     什么Selina
[13:54/19:47]     乱七八糟的这种
[13:55/19:47]     你们肯定看不懂
[13:56/19:47]     我们怎么去看呢
[13:57/19:47]     我们点一下这个小三角
[13:59/19:47]     从这我们可以看到
[14:00/19:47]     这个元素好像有蛮多属性
[14:02/19:47]     比如说有ID
[14:04/19:47]     有什么parent
[14:05/19:47]     就是他的一个负极属性
[14:08/19:47]     还有什么这个这个这个应该是截图
[14:11/19:47]     然后尺寸
[14:12/19:47]     他跟name就是它的一个标签名称
[14:14/19:47]     还有他还有它对应的一个TXT
[14:17/19:47]     那大家可以看到
[14:18/19:47]     通常来说
[14:19/19:47]     一个web element元素至少有这么一些属性
[14:22/19:47]     那这些属性其实有一些属性是有用的
[14:26/19:47]     有一些属性是没用的
[14:27/19:47]     但是在一个前提是我们要知道
[14:29/19:47]     他大概可能有哪些属性
[14:31/19:47]     以及我们应该如何去查看
[14:32/19:47]     我们要掌握这个debug的一个方式好
[14:35/19:47]     那
[14:36/19:47]     具体这么多属性
[14:37/19:47]     我们常用的有哪一些呢
[14:39/19:47]     就是我在这儿给大家补充一下
[14:43/19:47]     获取元素的文本信息
[14:45/19:47]     那这个是非常非常常用的
[14:47/19:47]     比如说我们现在在这个页面上面进行一系列操作
[14:50/19:47]     那这时候最后呢
[14:52/19:47]     我们在手工测试的时候
[14:54/19:47]     我们可能会通过页面上的一些这个文本的展示去确定一些这个比如说是是否达到了我们的预期结果
[15:03/19:47]     对吧
[15:05/19:47]     就可以通过我们怎么样去获取
[15:08/19:47]     就直接通过web element代表拿到这个对象
[15:11/19:47]     然后这个对象里面有个叫做TXT的这个属性
[15:14/19:47]     那我们通过这个webelement.txt我们就可以拿到它的一个文本信息
[15:20/19:47]     在这里我想给大家强调一点
[15:22/19:47]     是不是每个元素都含有
[15:27/19:47]     文本信息的
[15:30/19:47]     只有大家可以看到
[15:33/19:47]     比如说只有这种页面上面有文本的
[15:35/19:47]     他才会有文本信息
[15:37/19:47]     如果说你这个元素他压根儿连文本都没有
[15:40/19:47]     那他肯定是没有这个文本信息的好
[15:44/19:47]     那那这个是我们的第五个步骤
[15:46/19:47]     我们来执行一下试一下
[15:51/19:47]     好
[15:52/19:47]     那这时候我们发现我们是不是就成功的获取到了
[15:55/19:47]     我们把这一行也注释掉
[15:56/19:47]     然后这时候我们能够获取到文本信息之后呢
[15:59/19:47]     我们可能还需要做其他的一些操作
[16:01/19:47]     比如说获取
[16:03/19:47]     获取元素的属性信息好
[16:08/19:47]     那这时候可能有同学会问说
[16:09/19:47]     老师什么是属性
[16:11/19:47]     还记得我们在学习元素定位的时候给大家做的这个科普嘛
[16:15/19:47]     就是一个HTML里面呢
[16:17/19:47]     那跟这个尖括号挨在一起的呢
[16:20/19:47]     这个叫做标签的名称
[16:21/19:47]     好
[16:22/19:47]     截个图首先
[16:24/19:47]     这个红圈圈
[16:26/19:47]     这个红圈圈的部分呢
[16:27/19:47]     我们给他叫做标签
[16:28/19:47]     对吧
[16:29/19:47]     那这种KV结构
[16:30/19:47]     我换一个颜色
[16:31/19:47]     那这种KV结构
[16:32/19:47]     比如说肉等于什么什么
[16:34/19:47]     就是这种a等于B的这样的一个样子
[16:37/19:47]     然后对应过来
[16:38/19:47]     它的颜色是一个褐色
[16:40/19:47]     然后它的值是一个蓝色
[16:42/19:47]     那这种呢
[16:43/19:47]     我们通常给它叫做属性
[16:45/19:47]     那一个元素通常可以有多个属性
[16:46/19:47]     大家可以看到这这这有非常非常多的属性
[16:50/19:47]     包括我们的ID
[16:51/19:47]     我们的累
[16:52/19:47]     其实都是这个属于这个元素的一个属性
[16:56/19:47]     我们把它叫做属性
[16:58/19:47]     那这时候大家是不是就理解了
[17:00/19:47]     我们获取元素的属性是在获取什么
[17:02/19:47]     其实就是获取我们定位到这个
[17:04/19:47]     元素里面的这些褐色的部分
[17:07/19:47]     它对应的一个值
[17:09/19:47]     什么意思
[17:10/19:47]     比如说我现在要获取元素的属性
[17:12/19:47]     我想获取这个name name里面它对应的一个值是locate
[17:17/19:47]     好
[17:18/19:47]     那这时候我们来尝试获取一下
[17:19/19:47]     那怎么去获取呢
[17:20/19:47]     在这儿我们可以使用web element
[17:23/19:47]     点一个叫做调用一个叫做at attribute的一个方法
[17:27/19:47]     注意是get attribute
[17:29/19:47]     好
[17:30/19:47]     那我们get attribute里面我们输入
[17:33/19:47]     我们要获取这个元素对应的哪些属性呢
[17:37/19:47]     比如说我们要获取它的一个name
[17:38/19:47]     对吧
[17:40/19:47]     我们把这个结果也给他打印一下
[17:43/19:47]     那这时候
[17:44/19:47]     我们就会注意到
[17:45/19:47]     这时候我们打印出来的这个内容
[17:47/19:47]     一定是和我们这个name是一致的
[17:50/19:47]     所以它打印出来一定是locate
[17:52/19:47]     我们来执行看一下
[17:55/19:47]     OK
[17:56/19:47]     大家可以看到是不是成功的获取到了
[17:58/19:47]     那比如说我们在获取一个ID
[18:03/19:47]     是不是也成功获取到了
[18:05/19:47]     我们可以获取多个
[18:06/19:47]     比如说还有class这些我们都可以去进行获取
[18:12/19:47]     大家可以看到这个也是我们对应的一个class的一个内容是吧
[18:15/19:47]     是不是是不是class叫这个
[18:16/19:47]     那这时候我们可以看到
[18:18/19:47]     那这个属性信息它有什么样的一个作用呢
[18:20/19:47]     在后面的实战
[18:22/19:47]     我们会具体教给大家
[18:24/19:47]     比如说一些一些前端呢
[18:26/19:47]     他在写一些页面的时候
[18:28/19:47]     他喜欢这个
[18:29/19:47]     比如说这个会加一些title的一些属性
[18:32/19:47]     比如说title等于这个XX
[18:34/19:47]     或者他会加一些跟业务逻辑相关的一些文本属性信息
[18:39/19:47]     它有时候不是通过TST去加的
[18:41/19:47]     而是通过这个属性去加的
[18:43/19:47]     那我们就可以通过这个get attribute方法很好的获取到它的一个属性
[18:47/19:47]     OK
[18:48/19:47]     那在这一步呢
[18:49/19:47]     大家需要先了解到他一个概念以及它的一个应用技能
[18:53/19:47]     就是我们去获取元素属性信息的一个小技巧
[18:59/19:47]     那这时候回到我们的PPT
[19:00/19:47]     我们来看一下
[19:01/19:47]     那最后也教给大家
[19:03/19:47]     那我们常用的两个方法
[19:05/19:47]     那它其实还有非常多的一个长
[19:07/19:47]     还有非常多的一个方法
[19:08/19:47]     但是最常用也是最实用的呢
[19:10/19:47]     就是这两个
[19:11/19:47]     第一个就是获取他的一个文本信息
[19:15/19:47]     文本信息就是这些
[19:16/19:47]     就是span里面包含的这一些书
[19:20/19:47]     Span它对应的就是一个文本的一个标签嘛
[19:23/19:47]     然后还有第二个呢
[19:24/19:47]     就是获取
[19:25/19:47]     获取这个元素的属性
[19:27/19:47]     那比如说我们使用这个get attribute里面输入name
[19:32/19:47]     就代表的是获取的是HTML对应的这个元素的一个属性的值OK
[19:38/19:47]     那这部分呢
[19:39/19:47]     就是我们今天所学习的获取元素属性的这样的一个方法



### 9、测试人论坛搜索功能自动化测试（无）

![image-20221211222714975](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211222714975.png)

![image-20221211222734174](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211222734174.png)

![image-20221211222754997](C:\Users\10598\AppData\Roaming\Typora\typora-user-images\image-20221211222754997.png)







![image-20221212043857702](./web自动化 视频文本录制/image-20221212043857702.png)

![image-20221212044109139](./web自动化 视频文本录制t_imgs/image-20221212044109139.png)



























## 24、web 自动化测试II（无）

## 25、web 自动化测试-直播训练营（无）

## 26、web 自动化测试-III（无）

## 27、web 自动化测试-直播训练营（无）

## 28、web 自动化测试-IV（无）

## 29、web 自动化测试-拓展（无）

